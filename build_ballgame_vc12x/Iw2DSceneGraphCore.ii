# 1 "c:/marmalade/7.3/modules/iw2dscenegraphcore/source/Iw2DSceneGraphCore.cpp"
# 1 "D:\\src\\marmalade\\BallGame\\build_ballgame_vc12x//"
# 1 "<command-line>"
# 1 "d:/src/marmalade/BallGame/build_ballgame_vc12x/temp_defines_debug.h" 1
# 1 "<command-line>" 2
# 1 "c:/marmalade/7.3/modules/iw2dscenegraphcore/source/Iw2DSceneGraphCore.cpp"
# 23 "c:/marmalade/7.3/modules/iw2dscenegraphcore/source/Iw2DSceneGraphCore.cpp"
# 1 "c:/marmalade/7.3/modules/iw2dscenegraphcore/h/Iw2DSceneGraphCore.h" 1
# 27 "c:/marmalade/7.3/modules/iw2dscenegraphcore/h/Iw2DSceneGraphCore.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/vector" 1
# 28 "c:/marmalade/7.3/s3e/h/std/c++/vector"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_prolog.h" 1
# 10 "c:/marmalade/7.3/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_config.h" 1
# 62 "c:/marmalade/7.3/s3e/h/std/c++/stl/_config.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl_user_config.h" 1
# 63 "c:/marmalade/7.3/s3e/h/std/c++/stl/_config.h" 2




# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_config_compat.h" 1
# 68 "c:/marmalade/7.3/s3e/h/std/c++/stl/_config.h" 2



# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_site_config.h" 1
# 72 "c:/marmalade/7.3/s3e/h/std/c++/stl/_config.h" 2


# 1 "c:/marmalade/7.3/s3e/h/std/c++/config/stlcomp.h" 1
# 54 "c:/marmalade/7.3/s3e/h/std/c++/config/stlcomp.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/config/stl_gcc_s3e.h" 1
# 67 "c:/marmalade/7.3/s3e/h/std/c++/config/stl_gcc_s3e.h"
     typedef char __stl_char;
# 55 "c:/marmalade/7.3/s3e/h/std/c++/config/stlcomp.h" 2
# 75 "c:/marmalade/7.3/s3e/h/std/c++/stl/_config.h" 2
# 83 "c:/marmalade/7.3/s3e/h/std/c++/stl/_config.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/config/stl_confix.h" 1
# 84 "c:/marmalade/7.3/s3e/h/std/c++/stl/_config.h" 2
# 488 "c:/marmalade/7.3/s3e/h/std/c++/stl/_config.h"
namespace std { }
namespace __std_alias = std;
# 546 "c:/marmalade/7.3/s3e/h/std/c++/stl/_config.h"
namespace _STL { }

namespace stlport = _STL;
# 11 "c:/marmalade/7.3/s3e/h/std/c++/stl/_prolog.h" 2





# 1 "c:/marmalade/7.3/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/7.3/s3e/h/std/c++/stl/_prolog.h" 2
# 29 "c:/marmalade/7.3/s3e/h/std/c++/vector" 2



         



# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.h" 1
# 35 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/cstddef" 1
# 37 "c:/marmalade/7.3/s3e/h/std/c++/cstddef"
# 1 "c:/marmalade/7.3/s3e/h/ext/../std/stddef.h" 1
# 15 "c:/marmalade/7.3/s3e/h/ext/../std/stddef.h"
typedef signed int ptrdiff_t;


    typedef unsigned int wint_t;
    typedef unsigned long int wctype_t;







typedef unsigned int size_t;
# 38 "c:/marmalade/7.3/s3e/h/std/c++/cstddef" 2



namespace _STL {
using ::ptrdiff_t;
using ::size_t;
}
# 36 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.h" 2



# 1 "c:/marmalade/7.3/s3e/h/std/c++/cstring" 1
# 27 "c:/marmalade/7.3/s3e/h/std/c++/cstring"
# 1 "c:/marmalade/7.3/s3e/h/ext/../std/string.h" 1
# 15 "c:/marmalade/7.3/s3e/h/ext/../std/string.h"
# 1 "c:/marmalade/7.3/s3e/h/std/sys/types.h" 1
# 15 "c:/marmalade/7.3/s3e/h/std/sys/types.h"
# 1 "c:/marmalade/7.3/s3e/h/s3eTypes.h" 1
# 35 "c:/marmalade/7.3/s3e/h/s3eTypes.h"
typedef unsigned char s3e_uint8_t;
typedef signed char s3e_int8_t;
typedef unsigned short int s3e_uint16_t;
typedef signed short int s3e_int16_t;
typedef unsigned int s3e_uint32_t;
typedef signed int s3e_int32_t;
# 49 "c:/marmalade/7.3/s3e/h/s3eTypes.h"
  typedef signed long long s3e_int64_t;
  typedef unsigned long long s3e_uint64_t;
# 62 "c:/marmalade/7.3/s3e/h/s3eTypes.h"
typedef s3e_uint64_t uint64_t;
typedef s3e_int64_t int64_t;
typedef s3e_uint32_t uint32_t;
typedef s3e_int32_t int32_t;
typedef s3e_uint16_t uint16_t;
typedef s3e_int16_t int16_t;
typedef s3e_uint8_t uint8_t;
typedef s3e_int8_t int8_t;
# 84 "c:/marmalade/7.3/s3e/h/s3eTypes.h"
    typedef int intptr_t;
    typedef unsigned int uintptr_t;
# 96 "c:/marmalade/7.3/s3e/h/s3eTypes.h"
typedef unsigned int uint;
typedef unsigned short int ushort;
typedef unsigned long int ulong;
typedef unsigned char uint8;
typedef signed char int8;


typedef int64_t int64;
typedef uint64_t uint64;




typedef unsigned int uint32;






typedef signed int int32;






typedef uint16_t uint16;




typedef int16_t int16;
# 207 "c:/marmalade/7.3/s3e/h/s3eTypes.h"
typedef enum s3eResult
{
    S3E_RESULT_SUCCESS = 0,
    S3E_RESULT_ERROR = 1
} s3eResult;




typedef uint8 s3eBool;
# 225 "c:/marmalade/7.3/s3e/h/s3eTypes.h"
typedef wchar_t s3eWChar;
# 237 "c:/marmalade/7.3/s3e/h/s3eTypes.h"
typedef int32 (*s3eCallback) (void* systemData, void* userData);
# 16 "c:/marmalade/7.3/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/7.3/s3e/h/std/stddef.h" 1
# 17 "c:/marmalade/7.3/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/7.3/s3e/h/std/stdint.h" 1
# 19 "c:/marmalade/7.3/s3e/h/std/stdint.h"
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef long int_least32_t;
typedef int64_t int_least64_t;

typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned long uint_least32_t;
typedef uint64_t uint_least64_t;

typedef signed char int_fast8_t;
typedef short int_fast16_t;
typedef long int_fast32_t;
typedef int64_t int_fast64_t;

typedef unsigned char uint_fast8_t;
typedef unsigned short uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef uint64_t uint_fast64_t;

typedef int64_t intmax_t;
typedef uint64_t uintmax_t;
# 18 "c:/marmalade/7.3/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/7.3/s3e/h/std/sys/select.h" 1
# 24 "c:/marmalade/7.3/s3e/h/std/sys/select.h"
struct timeval;

typedef struct fd_set
{
    char fds_bits[256/8];
} fd_set;
# 39 "c:/marmalade/7.3/s3e/h/std/sys/select.h"
extern "C" {

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

}
# 19 "c:/marmalade/7.3/s3e/h/std/sys/types.h" 2



typedef long off_t;

typedef int64_t off64_t;


namespace std
{
typedef ::size_t size_t;
}


typedef uint u_int;
typedef uint8_t u_int8_t;
typedef uint16_t u_int16_t;
typedef uint32_t u_int32_t;
typedef uint64_t u_int64_t;

typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;

typedef int ssize_t;
typedef int pid_t;
typedef short uid_t;
typedef short gid_t;
typedef int idtype_t;
typedef int id_t;
typedef uint32 mode_t;
typedef short dev_t;
typedef short ino_t;
typedef int key_t;
typedef void* caddr_t;
# 16 "c:/marmalade/7.3/s3e/h/ext/../std/string.h" 2

extern "C" {

void *memcpy(void *dest, const void *src, size_t n);
void *memset(void *s, int c, size_t n);
int memcmp(const void *s1, const void *s2, size_t n);
void *memmove(void *dest, const void *src, size_t n);
void *memchr(const void *s, int c, size_t n);
void *memrchr(const void *s, int c, size_t n);
# 34 "c:/marmalade/7.3/s3e/h/ext/../std/string.h"
int strcmp(const char *s1, const char *s2);
int strncmp(const char *s1, const char *s2, size_t n);
char *strsep(char **stringp, const char *delim);
char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);
char *strchr(const char *s, int c);
char *strstr(const char *haystack, const char *needle);
char *strrchr(const char *s, int c);
char *strdup(const char *s);
char *strtok(char *str, const char *delim);
char *strtok_r(char *str, const char *delim, char **saveptr);
char *strcat(char *dest, const char *src);
char *strncat(char *dest, const char *src, size_t n);
size_t strlen(const char *s);
size_t strnlen(const char *s, size_t n);
int strcasecmp(const char *s1, const char *s2);
int strncasecmp(const char *s1, const char *s2, size_t n);
size_t strspn(const char *s, const char *accept);
size_t strcspn(const char *s, const char *reject);
char *strpbrk(const char *s, const char *accept);
int strcoll(const char *s1, const char *s2);
char *strerror(int errnum);
size_t strxfrm(char *dest, const char *src, size_t n);

int strerror_r(int errnum, char *buf, size_t buflen);





size_t strlcpy(char* dest, const char* src, size_t len);
size_t strlcat(char* dest, const char* src, size_t len);

char* strnstr(const char *s, const char *find, size_t slen);

}
# 28 "c:/marmalade/7.3/s3e/h/std/c++/cstring" 2



namespace _STL {
# 1 "c:/marmalade/7.3/s3e/h/std/c++/using/cstring" 1
using ::size_t;
# 17 "c:/marmalade/7.3/s3e/h/std/c++/using/cstring"
 using ::memmove;
 using ::memcpy;




using ::memchr;
using ::strchr;
using ::strpbrk;
using ::strrchr;
using ::strstr;


using ::memcmp;
using ::memset;

using ::strcat;


using ::strcmp;


using ::strcoll;

using ::strcpy;

using ::strcspn;
using ::strerror;
using ::strlen;
using ::strncat;
using ::strncmp;

using ::strncpy;
using ::strspn;

using ::strtok;
using ::strxfrm;
# 33 "c:/marmalade/7.3/s3e/h/std/c++/cstring" 2
}
# 40 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.h" 2



# 1 "c:/marmalade/7.3/s3e/h/std/c++/climits" 1
# 32 "c:/marmalade/7.3/s3e/h/std/c++/climits"
# 1 "c:/marmalade/7.3/s3e/h/std/limits.h" 1
# 33 "c:/marmalade/7.3/s3e/h/std/c++/climits" 2
# 44 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.h" 2



# 1 "c:/marmalade/7.3/s3e/h/std/c++/cstdlib" 1
# 27 "c:/marmalade/7.3/s3e/h/std/c++/cstdlib"
# 1 "c:/marmalade/7.3/s3e/h/ext/../std/stdlib.h" 1
# 16 "c:/marmalade/7.3/s3e/h/ext/../std/stdlib.h"
# 1 "c:/marmalade/7.3/s3e/h/std/malloc.h" 1
# 16 "c:/marmalade/7.3/s3e/h/std/malloc.h"
# 1 "c:/marmalade/7.3/s3e/h/std/alloca.h" 1
# 17 "c:/marmalade/7.3/s3e/h/std/alloca.h"
extern "C" {






    extern void *alloca(size_t __size);
# 39 "c:/marmalade/7.3/s3e/h/std/alloca.h"
}
# 17 "c:/marmalade/7.3/s3e/h/std/malloc.h" 2

extern "C" {

void *calloc(size_t nmemb, size_t size);
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);

}
# 17 "c:/marmalade/7.3/s3e/h/ext/../std/stdlib.h" 2
# 28 "c:/marmalade/7.3/s3e/h/ext/../std/stdlib.h"
extern "C" {

double atof(const char* string);
int atoi(const char *nptr);
long atol(const char *nptr);
int64_t atoll(const char *nptr);
int64_t atoq(const char *nptr);
int abs(int j);
long int labs(long int j);
int64_t llabs(int64_t j);
void qsort(void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *));
void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
void abort(void) __attribute__ ((noreturn));
int putenv(char *string);
char *getenv(const char *name);
int setenv(const char *name, const char *value, int overwrite);
int unsetenv(const char *name);
void exit(int status) __attribute__ ((noreturn));
void _exit(int status) __attribute__ ((noreturn));
void _Exit(int status) __attribute__ ((noreturn));
unsigned long int strtoul(const char *nptr, char **endptr, int base);
uint64_t strtoull(const char *nptr, char **endptr, int base);
long int strtol(const char *nptr, char **endptr, int base);
int64_t strtoll(const char *nptr, char **endptr, int base);
double strtod(const char *nptr, char **endptr);
float strtof(const char *nptr, char **endptr);
long double strtold(const char *nptr, char **endptr);
int atexit(void (*function)(void));
int system(const char *command);
int posix_memalign(void **memptr, size_t alignment, size_t size);
char *mktemp(char *templ);
int mkstemp(char *templ);



int rand(void);
void srand(unsigned int seed);

long int random(void);
void srandom(unsigned int seed);

size_t __ctype_get_mb_cur_max();


int mblen(const char *s, size_t n);
int mbtowc(wchar_t *pwc, const char *s, size_t n);
int wctomb(char *s, wchar_t wc);
size_t mbstowcs(wchar_t *dest, const char *src, size_t n);
size_t wcstombs(char *dest, const wchar_t *src, size_t n);

typedef struct
{
    int quot;
    int rem;
} div_t;

typedef struct
{
    int quot;
    int rem;
} ldiv_t;

typedef struct
{
    int64_t quot;
    int64_t rem;
} lldiv_t;

div_t div(int numerator, int denominator);
ldiv_t ldiv(long numerator, long denominator);
lldiv_t lldiv(int64_t numerator, int64_t denominator);
# 118 "c:/marmalade/7.3/s3e/h/ext/../std/stdlib.h"
}
# 28 "c:/marmalade/7.3/s3e/h/std/c++/cstdlib" 2
# 41 "c:/marmalade/7.3/s3e/h/std/c++/cstdlib"
namespace _STL {
using ::div_t;
using ::ldiv_t;
using ::size_t;


using ::abort;
using ::atexit;
using ::exit;
using ::getenv;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::atof;
using ::atoi;
using ::atol;
using ::mblen;
using ::mbstowcs;
using ::mbtowc;
using ::strtod;
using ::strtol;
using ::strtoul;
using ::system;


using ::wcstombs;
using ::wctomb;

using ::bsearch;
using ::qsort;




using ::div;
using ::labs;
using ::ldiv;
using ::rand;
using ::srand;

}


namespace _STL {



inline long abs(long __x) { return ::labs(__x); }


inline ldiv_t div(long __x, long __y) { return ::ldiv(__x, __y); }
# 103 "c:/marmalade/7.3/s3e/h/std/c++/cstdlib"
}
# 48 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.h" 2



# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_pair.h" 1
# 34 "c:/marmalade/7.3/s3e/h/std/c++/stl/_pair.h"
namespace _STL {

template <class _T1, class _T2>
struct pair {
  typedef _T1 first_type;
  typedef _T2 second_type;

  _T1 first;
  _T2 second;



  pair() : first(_T1()), second(_T2()) {}

  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}


  template <class _U1, class _U2>
  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}

  pair(const pair<_T1,_T2>& __o) : first(__o.first), second(__o.second) {}

 
};

template <class _T1, class _T2>
inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first < __y.first ||
         (!(__y.first < __x.first) && __x.second < __y.second);
}



template <class _T1, class _T2>
inline bool operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x == __y);
}

template <class _T1, class _T2>
inline bool operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return __y < __x;
}

template <class _T1, class _T2>
inline bool operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__y < __x);
}

template <class _T1, class _T2>
inline bool operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x < __y);
}





template <class _T1, class _T2, int _Sz>
inline pair<_T1, _T2 const*> make_pair(_T1 const& __x,
                                       _T2 const (&__y)[_Sz])
{
  return pair<_T1, _T2 const*>(__x, static_cast<_T2 const*>(__y));
}

template <class _T1, class _T2, int _Sz>
inline pair<_T1 const*, _T2> make_pair(_T1 const (&__x)[_Sz],
                                       _T2 const& __y)
{
  return pair<_T1 const*, _T2>(static_cast<_T1 const*>(__x), __y);
}

template <class _T1, class _T2, int _Sz1, int _Sz2>
inline pair<_T1 const*, _T2 const*> make_pair(_T1 const (&__x)[_Sz1],
                                              _T2 const (&__y)[_Sz2])
{
  return pair<_T1 const*, _T2 const*>(static_cast<_T1 const*>(__x),
                                      static_cast<_T2 const*>(__y));
}


template <class _T1, class _T2>
inline pair<_T1, _T2> make_pair(const _T1& __x, const _T2& __y)
{
  return pair<_T1, _T2>(__x, __y);
}


}


namespace _STL { namespace rel_ops {

template <class _Tp>
inline bool operator!=(const _Tp& __x, const _Tp& __y) {
  return !(__x == __y);
}

template <class _Tp>
inline bool operator>(const _Tp& __x, const _Tp& __y) {
  return __y < __x;
}

template <class _Tp>
inline bool operator<=(const _Tp& __x, const _Tp& __y) {
  return !(__y < __x);
}

template <class _Tp>
inline bool operator>=(const _Tp& __x, const _Tp& __y) {
  return !(__x < __y);
}

} }
# 52 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.h" 2



# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_iterator_base.h" 1
# 44 "c:/marmalade/7.3/s3e/h/std/c++/stl/_iterator_base.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/type_traits.h" 1
# 62 "c:/marmalade/7.3/s3e/h/std/c++/stl/type_traits.h"
namespace _STL {

struct __true_type {};
struct __false_type {};


template <int _Is> struct __bool2type {
  typedef __false_type _Ret;
};

template<>
struct __bool2type<1> { typedef __true_type _Ret; };

template<>
struct __bool2type<0> { typedef __false_type _Ret; };


template <class _P1, class _P2, class _P3>
struct _Land3 {
  typedef __false_type _Ret;
};

template<>
struct _Land3<__true_type, __true_type, __true_type> {
  typedef __true_type _Ret;
};



template <class _Tp> struct __type_traits;
template <int _IsPOD> struct __type_traits_aux {
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};

template<>
struct __type_traits_aux<0> {
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};

template<>
struct __type_traits_aux<1> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};
# 188 "c:/marmalade/7.3/s3e/h/std/c++/stl/type_traits.h"
template <class _Tp>
struct __type_traits {
   typedef __true_type this_dummy_member_must_be_first;
# 206 "c:/marmalade/7.3/s3e/h/std/c++/stl/type_traits.h"
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};


template <class _Tp> struct _IsPtr { enum { _Ret = 0 }; };
template <class _Tp> struct _IsPtrType {
  static __false_type _Ret() { return __false_type();}
};
template <class _Tp1, class _Tp2> struct _BothPtrType {
  static __false_type _Ret() { return __false_type();}
};

template <class _Tp1, class _Tp2>
struct _IsSame { enum { _Ret = 0 }; };





template <class _Tp> struct _IsPtr<_Tp*> { enum { _Ret = 1 }; };
template <class _Tp> struct _IsPtrType<_Tp*> {
  static __true_type _Ret() { return __true_type();}
};
template <class _Tp1, class _Tp2> struct _BothPtrType<_Tp1*, _Tp2*> {
  static __true_type _Ret() { return __true_type();}
};
template <class _Tp>
struct _IsSame<_Tp, _Tp> { enum { _Ret = 1 }; };
# 246 "c:/marmalade/7.3/s3e/h/std/c++/stl/type_traits.h"
template<> struct __type_traits<bool> : __type_traits_aux<1> {};

template<> struct __type_traits<char> : __type_traits_aux<1> {};

template<> struct __type_traits<signed char> : __type_traits_aux<1> {};

template<> struct __type_traits<unsigned char> : __type_traits_aux<1> {};




template<> struct __type_traits<short> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned short> : __type_traits_aux<1> {};
template<> struct __type_traits<int> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned int> : __type_traits_aux<1> {};
template<> struct __type_traits<long> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned long> : __type_traits_aux<1> {};


template<> struct __type_traits<long long> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned long long> : __type_traits_aux<1> {};


template<> struct __type_traits<float> : __type_traits_aux<1> {};
template<> struct __type_traits<double> : __type_traits_aux<1> {};


template<> struct __type_traits<long double> : __type_traits_aux<1> {};



template <class _Tp> struct __type_traits<_Tp*> : __type_traits_aux<1> {};





template <class _Tp> struct _Is_integer {
  typedef __false_type _Integral;
};



template<> struct _Is_integer<bool> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<char> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<signed char> {
  typedef __true_type _Integral;
};


template<> struct _Is_integer<unsigned char> {
  typedef __true_type _Integral;
};
# 318 "c:/marmalade/7.3/s3e/h/std/c++/stl/type_traits.h"
template<> struct _Is_integer<short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<long long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long long> {
  typedef __true_type _Integral;
};



template <class _Tp1, class _Tp2>
struct _OKToMemCpy {
  enum { _Same = _IsSame<_Tp1,_Tp2>::_Ret } ;
  typedef typename __type_traits<_Tp1>::has_trivial_assignment_operator _Tr1;
  typedef typename __type_traits<_Tp2>::has_trivial_assignment_operator _Tr2;
  typedef typename __bool2type< _Same >::_Ret _Tr3;
  typedef typename _Land3<_Tr1, _Tr2, _Tr3>::_Ret _Type;
  static _Type _Ret() { return _Type(); }
};

template <class _Tp1, class _Tp2>
inline _OKToMemCpy<_Tp1, _Tp2> _IsOKToMemCpy(_Tp1*, _Tp2*) {
  return _OKToMemCpy<_Tp1, _Tp2>();
}

template <class _Tp>
struct _IsPOD {
  typedef typename __type_traits<_Tp>::is_POD_type _Type;
  static _Type _Ret() { return _Type(); }
};

template <class _Tp>
inline _IsPOD<_Tp> _Is_POD (_Tp*) { return _IsPOD<_Tp>(); }
# 411 "c:/marmalade/7.3/s3e/h/std/c++/stl/type_traits.h"
}
# 45 "c:/marmalade/7.3/s3e/h/std/c++/stl/_iterator_base.h" 2


namespace _STL {

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};


template <class _Category, class _Tp, class _Distance = ptrdiff_t,
          class _Pointer = _Tp*, class _Reference = _Tp& >
struct iterator {
  typedef _Category iterator_category;
  typedef _Tp value_type;
  typedef _Distance difference_type;
  typedef _Pointer pointer;
  typedef _Reference reference;
};
template<>
struct iterator<output_iterator_tag, void, void, void, void> {
  typedef output_iterator_tag iterator_category;

  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;

};
# 96 "c:/marmalade/7.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Iterator>
struct iterator_traits {
  typedef typename _Iterator::iterator_category iterator_category;
  typedef typename _Iterator::value_type value_type;
  typedef typename _Iterator::difference_type difference_type;
  typedef typename _Iterator::pointer pointer;
  typedef typename _Iterator::reference reference;
};
# 115 "c:/marmalade/7.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Tp>
struct iterator_traits<const _Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef ptrdiff_t difference_type;
  typedef const _Tp* pointer;
  typedef const _Tp& reference;
};

template <class _Tp>
struct iterator_traits<_Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef ptrdiff_t difference_type;
  typedef _Tp* pointer;
  typedef _Tp& reference;
};
# 164 "c:/marmalade/7.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Iter>
inline typename iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter&) {
  typedef typename iterator_traits<_Iter>::iterator_category _Category;
  return _Category();
}

template <class _Iter>
inline typename iterator_traits<_Iter>::difference_type* __distance_type(const _Iter&) {
  typedef typename iterator_traits<_Iter>::difference_type _diff_type;
  return static_cast<_diff_type*>(0);
}

template <class _Iter>
inline typename iterator_traits<_Iter>::value_type* __value_type(const _Iter&) {
  typedef typename iterator_traits<_Iter>::value_type _value_type;
  return static_cast<_value_type*>(0);
}
# 236 "c:/marmalade/7.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Tp, class _Distance> struct input_iterator :
  public iterator <input_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
struct output_iterator : public iterator <output_iterator_tag, void, void, void, void> {};
template <class _Tp, class _Distance> struct forward_iterator :
  public iterator<forward_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct bidirectional_iterator :
  public iterator<bidirectional_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct random_access_iterator :
  public iterator<random_access_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
# 281 "c:/marmalade/7.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _InputIterator, class _Distance>
inline void __distance(const _InputIterator& __first, const _InputIterator& __last,
      _Distance& __n, const input_iterator_tag &) {
  _InputIterator __it(__first);
  while (__it != __last) { ++__it; ++__n; }
}
# 305 "c:/marmalade/7.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _RandomAccessIterator, class _Distance>
inline void __distance(const _RandomAccessIterator& __first,
      const _RandomAccessIterator& __last,
      _Distance& __n, const random_access_iterator_tag &) {
  __n += __last - __first;
}


template <class _InputIterator, class _Distance>
inline void distance(const _InputIterator& __first,
    const _InputIterator& __last, _Distance& __n) {
  __distance(__first, __last, __n, typename iterator_traits< _InputIterator >::iterator_category());
}


template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
__distance(const _InputIterator& __first, const _InputIterator& __last, const input_iterator_tag &) {
  typename iterator_traits<_InputIterator>::difference_type __n = 0;
  _InputIterator __it(__first);
  while (__it != __last) {
    ++__it; ++__n;
  }
  return __n;
}
# 359 "c:/marmalade/7.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _RandomAccessIterator>
inline typename iterator_traits<_RandomAccessIterator>::difference_type
__distance(const _RandomAccessIterator& __first, const _RandomAccessIterator& __last,
           const random_access_iterator_tag &) {
  return __last - __first;
}

template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
distance(const _InputIterator& __first, const _InputIterator& __last) {
  return __distance(__first, __last, typename iterator_traits< _InputIterator >::iterator_category());
}



template <class _Tp>
struct _Nonconst_traits;

template <class _Tp>
struct _Const_traits {
  typedef _Tp value_type;
  typedef const _Tp& reference;
  typedef const _Tp* pointer;
  typedef _Nonconst_traits<_Tp> _Non_const_traits;
};

template <class _Tp>
struct _Nonconst_traits {
  typedef _Tp value_type;
  typedef _Tp& reference;
  typedef _Tp* pointer;
  typedef _Nonconst_traits<_Tp> _Non_const_traits;
};
# 414 "c:/marmalade/7.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _InputIter, class _Distance>
inline void __advance(_InputIter& __i, _Distance __n, const input_iterator_tag &) {
  while (__n--) ++__i;
}


template <class _InputIter, class _Distance>
inline void __advance(_InputIter& __i, _Distance __n, const output_iterator_tag &) {
  while (__n--) ++__i;
}
# 432 "c:/marmalade/7.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _BidirectionalIterator, class _Distance>
inline void __advance(_BidirectionalIterator& __i, _Distance __n,
                      const bidirectional_iterator_tag &) {
  if (__n > 0)
    while (__n--) ++__i;
  else
    while (__n++) --__i;
}

template <class _RandomAccessIterator, class _Distance>
inline void __advance(_RandomAccessIterator& __i, _Distance __n,
                      const random_access_iterator_tag &) {
  __i += __n;
}

template <class _InputIterator, class _Distance>
inline void advance(_InputIterator& __i, _Distance __n) {
  __advance(__i, __n, typename iterator_traits< _InputIterator >::iterator_category());
}

}
# 56 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.h" 2


namespace _STL {

template <class _Tp>
inline void swap(_Tp& __a, _Tp& __b) {
  _Tp __tmp = __a;
  __a = __b;
  __b = __tmp;
}

template <class _ForwardIter1, class _ForwardIter2>
inline void iter_swap(_ForwardIter1 __i1, _ForwardIter2 __i2) {
  swap(*__i1, *__i2);
}





template <class _Tp>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b) { return __b < __a ? __b : __a; }
template <class _Tp>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b) { return __a < __b ? __b : __a; }







template <class _Tp, class _Compare>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__b, __a) ? __b : __a;
}

template <class _Tp, class _Compare>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__a, __b) ? __b : __a;
}
# 106 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.h"
template <class _InputIter, class _OutputIter, class _Distance>
inline _OutputIter __copy(_InputIter __first, _InputIter __last,
                          _OutputIter __result,
                          const input_iterator_tag &, _Distance*) {
  for ( ; __first != __last; ++__result, ++__first)
    *__result = *__first;
  return __result;
}
# 134 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.h"
template <class _RandomAccessIter, class _OutputIter, class _Distance>
inline _OutputIter
__copy(_RandomAccessIter __first, _RandomAccessIter __last,
       _OutputIter __result, const random_access_iterator_tag &, _Distance*) {
  for (_Distance __n = __last - __first; __n > 0; --__n) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return __result;
}

inline void*
__copy_trivial(const void* __first, const void* __last, void* __result) {
  return (__last == __first) ? __result :
    ((char*)memmove(__result, __first, ((const char*)__last - (const char*)__first))) +
    ((const char*)__last - (const char*)__first);
}




template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _Distance>
inline _BidirectionalIter2 __copy_backward(_BidirectionalIter1 __first,
                                           _BidirectionalIter1 __last,
                                           _BidirectionalIter2 __result,
                                           const bidirectional_iterator_tag &,
                                           _Distance*)
{
  while (__first != __last)
    *--__result = *--__last;
  return __result;
}

template <class _RandomAccessIter, class _BidirectionalIter, class _Distance>
inline _BidirectionalIter __copy_backward(_RandomAccessIter __first,
                                          _RandomAccessIter __last,
                                          _BidirectionalIter __result,
                                          const random_access_iterator_tag &,
                                          _Distance*)
{
  for (_Distance __n = __last - __first; __n > 0; --__n)
    *--__result = *--__last;
  return __result;
}

inline void*
__copy_trivial_backward(const void* __first, const void* __last, void* __result) {
  const ptrdiff_t _Num = (const char*)__last - (const char*)__first;
  return (_Num > 0) ? memmove((char*)__result - _Num, __first, _Num) : __result ;
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy(__first, __last, __result,
                typename iterator_traits< _InputIter >::iterator_category(),
                (typename iterator_traits< _InputIter >::difference_type*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {


  return (_OutputIter)__copy_trivial(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return __copy_ptrs(__first, __last, __result,
                     _IsOKToMemCpy((typename iterator_traits< _InputIter >::value_type*)0,
                                   (typename iterator_traits< _OutputIter >::value_type*)0)._Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy(__first, __last, __result,
  typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
    return __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter> :: _Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy_backward(__first, __last, __result, typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return (_OutputIter)__copy_trivial_backward(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy_backward(__first, __last, __result, typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return __copy_backward_ptrs(__first, __last, __result,
                              _IsOKToMemCpy((typename iterator_traits< _InputIter >::value_type*)0,
                                            (typename iterator_traits< _OutputIter >::value_type*)0)._Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy_backward(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
    return __copy_backward_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter> :: _Ret() );
}
# 282 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.h"
template <class _InputIter, class _Size, class _OutputIter>
inline
pair<_InputIter, _OutputIter> __copy_n(_InputIter __first, _Size __count,
                                       _OutputIter __result,
                                       const input_iterator_tag &) {
  for ( ; __count > 0; --__count) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return pair<_InputIter, _OutputIter>(__first, __result);
}

template <class _RAIter, class _Size, class _OutputIter>
inline pair<_RAIter, _OutputIter>
__copy_n(_RAIter __first, _Size __count,
         _OutputIter __result,
         const random_access_iterator_tag &) {
  _RAIter __last = __first + __count;
  return pair<_RAIter, _OutputIter>(__last, copy(__first, __last, __result));
}

template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
__copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
 
  return __copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
 
  return __copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}





template <class _ForwardIter, class _Tp>
inline
void fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
 
  for ( ; __first != __last; ++__first)
    *__first = __val;
}

template <class _OutputIter, class _Size, class _Tp>
inline
_OutputIter fill_n(_OutputIter __first, _Size __n, const _Tp& __val) {
 
  for ( ; __n > 0; --__n, ++__first)
    *__first = __val;
  return __first;
}




inline void fill(unsigned char* __first, unsigned char* __last,
                 const unsigned char& __val) {
  unsigned char __tmp = __val;
  memset(__first, __tmp, __last - __first);
}

inline void fill(signed char* __first, signed char* __last,
                 const signed char& __val) {
  signed char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}

inline void fill(char* __first, char* __last, const char& __val) {
  char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}



template <class _Size>
inline unsigned char* fill_n(unsigned char* __first, _Size __n,
                             const unsigned char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}

template <class _Size>
inline signed char* fill_n(char* __first, _Size __n,
                           const signed char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}

template <class _Size>
inline char* fill_n(char* __first, _Size __n, const char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}







template <class _InputIter1, class _InputIter2>
inline
pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                        _InputIter1 __last1,
                                        _InputIter2 __first2) {
 
 
  while (__first1 != __last1 && *__first1 == *__first2) {
    ++__first1;
    ++__first2;
  }
  return pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                        _InputIter1 __last1,
                                        _InputIter2 __first2,
                                        _BinaryPredicate __binary_pred) {
 
 
  while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {
    ++__first1;
    ++__first2;
  }
  return pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2) {
 
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!(*__first1 == *__first2))
      return false;
  return true;
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _BinaryPredicate __binary_pred) {
 
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!__binary_pred(*__first1, *__first2))
      return false;
  return true;
}





template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2);

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp);

inline bool
lexicographical_compare(const unsigned char* __first1,
                        const unsigned char* __last1,
                        const unsigned char* __first2,
                        const unsigned char* __last2)
{
  const size_t __len1 = __last1 - __first1;
  const size_t __len2 = __last2 - __first2;
 
 

  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? (__result < 0) : (__len1 < __len2);
}



inline bool lexicographical_compare(const char* __first1, const char* __last1,
                                    const char* __first2, const char* __last2)
{
 
 

  return lexicographical_compare((const unsigned char*) __first1,
                                 (const unsigned char*) __last1,
                                 (const unsigned char*) __first2,
                                 (const unsigned char*) __last2);
}


template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2);

inline int
__lexicographical_compare_3way(const unsigned char* __first1,
                               const unsigned char* __last1,
                               const unsigned char* __first2,
                               const unsigned char* __last2)
{
  const ptrdiff_t __len1 = __last1 - __first1;
  const ptrdiff_t __len2 = __last2 - __first2;
  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? __result
                       : (__len1 == __len2 ? 0 : (__len1 < __len2 ? -1 : 1));
}



inline int
__lexicographical_compare_3way(const char* __first1, const char* __last1,
                               const char* __first2, const char* __last2)
{
  return __lexicographical_compare_3way((const unsigned char*) __first1,
                                        (const unsigned char*) __last1,
                                        (const unsigned char*) __first2,
                                        (const unsigned char*) __last2);
}




template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2);




template <class _InputIter, class _Tp>
inline typename iterator_traits<_InputIter>::difference_type
count(_InputIter __first, _InputIter __last, const _Tp& __val) {
 
  typename iterator_traits<_InputIter>::difference_type __n = 0;
  for ( ; __first != __last; ++__first)
    if (*__first == __val)
      ++__n;
  return __n;
}


template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val);
template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last, _Predicate __pred);


template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2, _BinaryPred __predicate);


template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp);

template <class _ForwardIter1, class _ForwardIter2,
          class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp);


template <class _ForwardIter, class _Tp>
inline void
replace(_ForwardIter __first, _ForwardIter __last,
        const _Tp& __old_value, const _Tp& __new_value) {
 
  for ( ; __first != __last; ++__first)
    if (*__first == __old_value)
      *__first = __new_value;
}

template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
                              const _Tp& __val, const _Compare& __comp, _Distance*);

}


# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.c" 1
# 32 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.c"
namespace _STL {

template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2) {
 
   
    for ( ; __first1 != __last1 && __first2 != __last2
     ; ++__first1, ++__first2) {
      if (*__first1 < *__first2)
 return true;
      if (*__first2 < *__first1)
 return false;
    }
  return __first1 == __last1 && __first2 != __last2;
}

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp) {
 
   
    for ( ; __first1 != __last1 && __first2 != __last2
     ; ++__first1, ++__first2) {
      if (__comp(*__first1, *__first2))
 return true;
      if (__comp(*__first2, *__first1))
 return false;
    }
  return __first1 == __last1 && __first2 != __last2;
}



template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2)
{
  while (__first1 != __last1 && __first2 != __last2) {
    if (*__first1 < *__first2)
      return -1;
    if (*__first2 < *__first1)
      return 1;
    ++__first1;
    ++__first2;
  }
  if (__first2 == __last2) {
    return !(__first1 == __last1);
  }
  else {
    return -1;
  }
}


template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2)
{
 
   
    return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);
}


template <class _RandomAccessIter, class _Tp>
inline _RandomAccessIter __find(_RandomAccessIter __first, _RandomAccessIter __last,
                                           const _Tp& __val,
                                           const random_access_iterator_tag &)
{
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;
  }

  switch(__last - __first) {
  case 3:
    if (*__first == __val) return __first;
    ++__first;
  case 2:
    if (*__first == __val) return __first;
    ++__first;
  case 1:
    if (*__first == __val) return __first;
    ++__first;
  case 0:
  default:
    return __last;
  }
}

template <class _RandomAccessIter, class _Predicate>
inline _RandomAccessIter __find_if(_RandomAccessIter __first, _RandomAccessIter __last,
                                              _Predicate __pred,
                                              const random_access_iterator_tag &)
{
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;
  }

  switch(__last - __first) {
  case 3:
    if (__pred(*__first)) return __first;
    ++__first;
  case 2:
    if (__pred(*__first)) return __first;
    ++__first;
  case 1:
    if (__pred(*__first)) return __first;

  case 0:
  default:
    return __last;
  }
}

template <class _InputIter, class _Tp>
inline _InputIter __find(_InputIter __first, _InputIter __last,
    const _Tp& __val,
    const input_iterator_tag &)
{
  while (__first != __last && !(*__first == __val))
    ++__first;
  return __first;
}

template <class _InputIter, class _Predicate>
inline _InputIter __find_if(_InputIter __first, _InputIter __last,
                            _Predicate __pred,
                            const input_iterator_tag &)
{
  while (__first != __last && !__pred(*__first))
    ++__first;
  return __first;
}

template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last,
                   _Predicate __pred) {
 
    return __find_if(__first, __last, __pred, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val)
{
 
    return __find(__first, __last, __val, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2,
                     _BinaryPred __predicate)
{
 
   

    if (__first1 == __last1 || __first2 == __last2)
      return __first1;


  _ForwardIter2 __tmp(__first2);
  ++__tmp;
  if (__tmp == __last2) {
    while (__first1 != __last1 && !__predicate(*__first1, *__first2))
      ++__first1;
    return __first1;
  }



  _ForwardIter2 __p1, __p;

  __p1 = __first2; ++__p1;



  while (__first1 != __last1) {
    while (__first1 != __last1) {
      if (__predicate(*__first1, *__first2))
        break;
      ++__first1;
    }
    while (__first1 != __last1 && !__predicate(*__first1, *__first2))
      ++__first1;
    if (__first1 == __last1)
      return __last1;

    __p = __p1;
    _ForwardIter1 __current = __first1;
    if (++__current == __last1) return __last1;

    while (__predicate(*__current, *__p)) {
      if (++__p == __last2)
        return __first1;
      if (++__current == __last1)
        return __last1;
    }

    ++__first1;
  }
  return __first1;
}



template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp) {
  for ( ; __first1 != __last1; ++__first1)
    for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)
      if (__comp(*__first1, *__iter))
        return __first1;
  return __last1;
}
# 282 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.c"
template <class _ForwardIter1, class _ForwardIter2,
  class _BinaryPredicate>
_ForwardIter1 __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
                         _ForwardIter2 __first2, _ForwardIter2 __last2,
                         const forward_iterator_tag &, const forward_iterator_tag &,
                         _BinaryPredicate __comp)
{
  if (__first2 == __last2)
    return __last1;
  else {
    _ForwardIter1 __result = __last1;
    while (1) {
      _ForwardIter1 __new_result
        = search(__first1, __last1, __first2, __last2, __comp);
      if (__new_result == __last1)
        return __result;
      else {
        __result = __new_result;
        __first1 = __new_result;
        ++__first1;
      }
    }
  }
}





}
# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_iterator.h" 1
# 37 "c:/marmalade/7.3/s3e/h/std/c++/stl/_iterator.h"
namespace _STL {
# 46 "c:/marmalade/7.3/s3e/h/std/c++/stl/_iterator.h"
template <class _Iterator>
class reverse_iterator :
  public iterator<typename iterator_traits<_Iterator>::iterator_category,
                  typename iterator_traits<_Iterator>::value_type,
                  typename iterator_traits<_Iterator>::difference_type,
                  typename iterator_traits<_Iterator>::pointer,
                  typename iterator_traits<_Iterator>::reference>
{
protected:
  _Iterator current;
  typedef reverse_iterator<_Iterator> _Self;
public:
  typedef typename iterator_traits<_Iterator>::iterator_category iterator_category;
  typedef typename iterator_traits<_Iterator>::value_type value_type;
  typedef typename iterator_traits<_Iterator>::difference_type difference_type;
  typedef typename iterator_traits<_Iterator>::pointer pointer;
  typedef typename iterator_traits<_Iterator>::reference reference;
  typedef _Iterator iterator_type;
public:
  reverse_iterator() {}
  explicit reverse_iterator(iterator_type __x) : current(__x) {}
  reverse_iterator(const _Self& __x) : current(__x.current) {}
  _Self& operator = (const _Self& __x) { current = __x.base(); return *this; }

  template <class _Iter>
  reverse_iterator(const reverse_iterator<_Iter>& __x) : current(__x.base()) {}
  template <class _Iter>
  _Self& operator = (const reverse_iterator<_Iter>& __x) { current = __x.base(); return *this; }


  iterator_type base() const { return current; }
  reference operator*() const {
    _Iterator __tmp = current;
    return *--__tmp;
  }
  pointer operator->() const { return &(operator*()); }
  _Self& operator++() {
    --current;
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    --current;
    return __tmp;
  }
  _Self& operator--() {
    ++current;
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    ++current;
    return __tmp;
  }

  _Self operator+(difference_type __n) const {
    return _Self(current - __n);
  }
  _Self& operator+=(difference_type __n) {
    current -= __n;
    return *this;
  }
  _Self operator-(difference_type __n) const {
    return _Self(current + __n);
  }
  _Self& operator-=(difference_type __n) {
    current += __n;
    return *this;
  }
  reference operator[](difference_type __n) const { return *(*this + __n); }
};

template <class _Iterator>
inline bool operator==(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return __x.base() == __y.base();
}

template <class _Iterator>
inline bool operator<(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return __y.base() < __x.base();
}



template <class _Iterator>
inline bool operator!=(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return !(__x == __y);
}

template <class _Iterator>
inline bool operator>(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return __y < __x;
}

template <class _Iterator>
inline bool operator<=(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return !(__y < __x);
}

template <class _Iterator>
inline bool operator>=(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return !(__x < __y);
}



template <class _Iterator>



inline typename reverse_iterator<_Iterator>::difference_type

operator-(const reverse_iterator<_Iterator>& __x,
          const reverse_iterator<_Iterator>& __y) {
  return __y.base() - __x.base();
}

template <class _Iterator, class _DifferenceType>
inline reverse_iterator<_Iterator>
operator+(_DifferenceType n,const reverse_iterator<_Iterator>& x) {
  return x.operator+(n);
}



template <class _Container>
class back_insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;

  explicit back_insert_iterator(_Container& __x) : container(&__x) {}
  back_insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    container->push_back(__val);
    return *this;
  }
  back_insert_iterator<_Container>& operator*() { return *this; }
  back_insert_iterator<_Container>& operator++() { return *this; }
  back_insert_iterator<_Container> operator++(int) { return *this; }
};

template <class _Container>
inline back_insert_iterator<_Container> back_inserter(_Container& __x) {
  return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class front_insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  explicit front_insert_iterator(_Container& __x) : container(&__x) {}
  front_insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    container->push_front(__val);
    return *this;
  }
  front_insert_iterator<_Container>& operator*() { return *this; }
  front_insert_iterator<_Container>& operator++() { return *this; }
  front_insert_iterator<_Container>& operator++(int) { return *this; }
};

template <class _Container>
inline front_insert_iterator<_Container> front_inserter(_Container& __x) {
  return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
  typename _Container::iterator iter;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  insert_iterator(_Container& __x, typename _Container::iterator __i)
    : container(&__x), iter(__i) {}
  insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    iter = container->insert(iter, __val);
    ++iter;
    return *this;
  }
  insert_iterator<_Container>& operator*() { return *this; }
  insert_iterator<_Container>& operator++() { return *this; }
  insert_iterator<_Container>& operator++(int) { return *this; }
};

template <class _Container, class _Iterator>
inline insert_iterator<_Container>
inserter(_Container& __x, _Iterator __i)
{
  typedef typename _Container::iterator __iter;
  return insert_iterator<_Container>(__x, __iter(__i));
}

}
# 313 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.c" 2
namespace _STL {


template <class _BidirectionalIter1, class _BidirectionalIter2,
  class _BinaryPredicate>
_BidirectionalIter1
__find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
           _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
           const bidirectional_iterator_tag &, const bidirectional_iterator_tag &,
           _BinaryPredicate __comp)
{
  typedef reverse_iterator<_BidirectionalIter1> _RevIter1;
  typedef reverse_iterator<_BidirectionalIter2> _RevIter2;

  _RevIter1 __rlast1(__first1);
  _RevIter2 __rlast2(__first2);
  _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,
                               _RevIter2(__last2), __rlast2,
                               __comp);

  if (__rresult == __rlast1)
    return __last1;
  else {
    _BidirectionalIter1 __result = __rresult.base();
    advance(__result, -distance(__first2, __last2));
    return __result;
  }
}


template <class _ForwardIter1, class _ForwardIter2,
  class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp)
{
 
   
    return __find_end(__first1, __last1, __first2, __last2,

        typename iterator_traits< _ForwardIter1 >::iterator_category(),
        typename iterator_traits< _ForwardIter2 >::iterator_category(),




        __comp);
}

template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
      const _Tp& __val, const _Compare& __comp, _Distance*)
{
  _Distance __len = distance(__first, __last);
  _Distance __half;
  _ForwardIter __middle;

  while (__len > 0) {
    __half = __len >> 1;
    __middle = __first;
    advance(__middle, __half);
    if (__comp(*__middle, __val)) {
      __first = __middle;
      ++__first;
      __len = __len - __half - 1;
    }
    else
      __len = __half;
  }
  return __first;
}

}
# 576 "c:/marmalade/7.3/s3e/h/std/c++/stl/_algobase.h" 2
# 37 "c:/marmalade/7.3/s3e/h/std/c++/vector" 2



# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_vector.h" 1
# 40 "c:/marmalade/7.3/s3e/h/std/c++/stl/_vector.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h" 1
# 48 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/cstdio" 1
# 35 "c:/marmalade/7.3/s3e/h/std/c++/cstdio"
# 1 "c:/marmalade/7.3/s3e/h/ext/../std/stdio.h" 1
# 19 "c:/marmalade/7.3/s3e/h/ext/../std/stdio.h"
struct __XXFILE;
typedef struct __XXFILE FILE;

typedef uint32 fpos_t;
# 38 "c:/marmalade/7.3/s3e/h/ext/../std/stdio.h"
extern "C" {
# 54 "c:/marmalade/7.3/s3e/h/ext/../std/stdio.h"
extern FILE *__aeabi_stdin;
extern FILE *__aeabi_stdout;
extern FILE *__aeabi_stderr;
# 73 "c:/marmalade/7.3/s3e/h/ext/../std/stdio.h"
FILE *fopen(const char *path, const char *mode);
int fclose(FILE *fp);
int fcloseall();
int fflush(FILE *stream);

FILE *fopen(const char *path, const char *mode);
FILE *fdopen(int fildes, const char *mode);
FILE *freopen(const char *path, const char *mode, FILE *stream);

size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);

int fputc(int c, FILE *stream);
int fputs(const char *s, FILE *stream);
int putc(int c, FILE *stream);
int putchar(int c);
int puts(const char *s);

int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
char *gets(char *s);
int ungetc(int c, FILE *stream);

int fseek(FILE *stream, long offset, int whence);
long ftell(FILE *stream);
void rewind(FILE *stream);
int fgetpos(FILE *stream, fpos_t *pos);
int fsetpos(FILE *stream, fpos_t *pos);

void flockfile(FILE *filehandle);
int ftrylockfile(FILE *filehandle);
void funlockfile(FILE *filehandle);

int getc_unlocked(FILE *stream);
int getchar_unlocked(void);
int putc_unlocked(int c, FILE *stream);
int putchar_unlocked(int c);

FILE *popen(const char *command, const char *type);
int pclose(FILE *stream);

char *tempnam(const char *dir, const char *pfx);




int printf(const char *format, ...) __attribute__((format(printf, 1, 2)));



int fprintf(FILE *stream, const char* format, ...) __attribute__((format(printf, 2, 3)));



int sprintf(char *str, const char* format, ...) __attribute__((format(printf, 2, 3)));



int snprintf(char *str, size_t size, const char *format, ...) __attribute__((format(printf, 3, 4)));




int scanf(const char *format, ...);



int fscanf(FILE *stream, const char *format, ...);



int sscanf(const char *str, const char *format, ...);

void clearerr(FILE *stream);
int feof(FILE *stream);
int ferror(FILE *stream);
int fileno(FILE *stream);

int remove(const char *pathname);
int rename(const char *oldpath, const char *newpath);

void perror(const char *s);



FILE *tmpfile(void);
char *tmpnam(char *s);

void setbuf(FILE *stream, char *buf);
void setbuffer(FILE *stream, char *buf, size_t size);
void setlinebuf(FILE *stream);
int setvbuf(FILE *stream, char *buf, int mode , size_t size);

# 1 "c:/marmalade/7.3/s3e/h/std/stdarg.h" 1
# 55 "c:/marmalade/7.3/s3e/h/std/stdarg.h"
typedef __builtin_va_list va_list;
# 169 "c:/marmalade/7.3/s3e/h/ext/../std/stdio.h" 2

int vfprintf(FILE *stream, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);
int vprintf(const char *format, va_list ap);
int asprintf(char **strp, const char *fmt, ...);
int vasprintf(char **strp, const char *fmt, va_list ap);

int vscanf(const char *format, va_list ap);
int vsscanf(const char *str, const char *format, va_list ap);
int vfscanf(FILE *stream, const char *format, va_list ap);

}
# 36 "c:/marmalade/7.3/s3e/h/std/c++/cstdio" 2
# 58 "c:/marmalade/7.3/s3e/h/std/c++/cstdio"
namespace _STL {
using ::FILE;
using ::fpos_t;
using ::size_t;
# 72 "c:/marmalade/7.3/s3e/h/std/c++/cstdio"
using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::fopen;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::freopen;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;


 using ::getc;
 using ::getchar;
 using ::putc;
 using ::putchar;


using ::gets;
using ::perror;
using ::printf;
using ::puts;
using ::remove;
using ::rename;
using ::rewind;
using ::scanf;
using ::setbuf;
using ::setvbuf;
using ::sprintf;
using ::sscanf;
using ::tmpfile;
using ::tmpnam;
using ::ungetc;
using ::vfprintf;
using ::vprintf;
using ::vsprintf;





}
# 49 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h" 2
# 60 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_new.h" 1
# 11 "c:/marmalade/7.3/s3e/h/std/c++/stl/_new.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/exception" 1
# 58 "c:/marmalade/7.3/s3e/h/std/c++/exception"
# 1 "c:/marmalade/7.3/s3e/h/ext/../std/c++/exception.h" 1
# 18 "c:/marmalade/7.3/s3e/h/ext/../std/c++/exception.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/exception_gcc" 1
# 41 "c:/marmalade/7.3/s3e/h/std/c++/exception_gcc"
#pragma GCC visibility push(default)


extern "C++" {

namespace std
{
# 56 "c:/marmalade/7.3/s3e/h/std/c++/exception_gcc"
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();


    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }


    virtual ~bad_exception() throw();
  };


  typedef void (*terminate_handler) ();

  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();


  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();


  void unexpected() __attribute__ ((__noreturn__));
# 104 "c:/marmalade/7.3/s3e/h/std/c++/exception_gcc"
  bool uncaught_exception() throw();
}

namespace __gnu_cxx
{
# 119 "c:/marmalade/7.3/s3e/h/std/c++/exception_gcc"
  void __verbose_terminate_handler ();
}

}


#pragma GCC visibility pop
# 19 "c:/marmalade/7.3/s3e/h/ext/../std/c++/exception.h" 2
# 59 "c:/marmalade/7.3/s3e/h/std/c++/exception" 2
# 75 "c:/marmalade/7.3/s3e/h/std/c++/exception"
namespace _STL {


using __std_alias::exception;
using __std_alias::bad_exception;
# 106 "c:/marmalade/7.3/s3e/h/std/c++/exception"
}
# 12 "c:/marmalade/7.3/s3e/h/std/c++/stl/_new.h" 2

namespace _STL {

struct nothrow_t {};


extern const nothrow_t nothrow;




class bad_alloc : public exception {
public:
  bad_alloc () throw() { }
  bad_alloc(const bad_alloc&) throw() { }
  bad_alloc& operator=(const bad_alloc&) throw() {return *this;}
  ~bad_alloc () throw() { }
  const char* what() const throw() { return "bad alloc"; }
};

}
# 50 "c:/marmalade/7.3/s3e/h/std/c++/stl/_new.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/new" 1
# 38 "c:/marmalade/7.3/s3e/h/std/c++/new"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/new.h" 1
# 52 "c:/marmalade/7.3/s3e/h/std/c++/new.h"
inline void* operator new(size_t, void* p) { return p;};
inline void* operator new[](size_t, void* p) { return p;};
inline void operator delete(void*, void*) {};
inline void operator delete[](void*, void*) {};
# 39 "c:/marmalade/7.3/s3e/h/std/c++/new" 2
# 51 "c:/marmalade/7.3/s3e/h/std/c++/stl/_new.h" 2
# 80 "c:/marmalade/7.3/s3e/h/std/c++/stl/_new.h"
namespace _STL {





inline void* __stl_new(size_t __n) { void* __y = ::operator new(__n);if (__y == 0){;}return __y; }
inline void __stl_delete(void* __p) { ::operator delete(__p); }

}
# 61 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h" 2



# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_threads.h" 1
# 57 "c:/marmalade/7.3/s3e/h/std/c++/stl/_threads.h"
  typedef size_t __stl_atomic_t;
# 280 "c:/marmalade/7.3/s3e/h/std/c++/stl/_threads.h"
namespace _STL {




template <int __inst>
struct _STLP_mutex_spin {
  enum { __low_max = 30, __high_max = 1000 };

  static unsigned __max;
  static unsigned __last;
  static void _M_do_lock(volatile __stl_atomic_t* __lock);
  static void _S_nsec_sleep(int __log_nsec);
};
# 311 "c:/marmalade/7.3/s3e/h/std/c++/stl/_threads.h"
struct _STLP_mutex_base
{
# 441 "c:/marmalade/7.3/s3e/h/std/c++/stl/_threads.h"
  inline void _M_initialize() {}
  inline void _M_destroy() {}
  inline void _M_acquire_lock() {}
  inline void _M_release_lock() {}

};
# 458 "c:/marmalade/7.3/s3e/h/std/c++/stl/_threads.h"
typedef _STLP_mutex_base _STLP_mutex_nodemand;





class _STLP_mutex : public _STLP_mutex_nodemand {
  public:
    inline _STLP_mutex () { _M_initialize(); }
    inline ~_STLP_mutex () { _M_destroy(); }
  private:
    _STLP_mutex(const _STLP_mutex&);
    void operator=(const _STLP_mutex&);
};
# 569 "c:/marmalade/7.3/s3e/h/std/c++/stl/_threads.h"
struct _Refcount_Base
{

  volatile __stl_atomic_t _M_ref_count;


  _STLP_mutex _M_mutex;



  _Refcount_Base(__stl_atomic_t __n) : _M_ref_count(__n) {}
# 597 "c:/marmalade/7.3/s3e/h/std/c++/stl/_threads.h"
  void _M_incr() { ++_M_ref_count; }
  void _M_decr() { --_M_ref_count; }

};
# 632 "c:/marmalade/7.3/s3e/h/std/c++/stl/_threads.h"
static inline __stl_atomic_t
_Atomic_swap(volatile __stl_atomic_t * __p, __stl_atomic_t __q) {
  __stl_atomic_t __result = *__p;
  *__p = __q;
  return __result;
}






struct _STLP_auto_lock
{
  _STLP_mutex_base& _M_lock;

  _STLP_auto_lock(_STLP_mutex_base& __lock) : _M_lock(__lock)
    { _M_lock._M_acquire_lock(); }
  ~_STLP_auto_lock() { _M_lock._M_release_lock(); }

private:
  void operator=(const _STLP_auto_lock&);
  _STLP_auto_lock(const _STLP_auto_lock&);
};

typedef _STLP_auto_lock _STLP_mutex_lock;
# 710 "c:/marmalade/7.3/s3e/h/std/c++/stl/_threads.h"
}


# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_threads.c" 1
# 714 "c:/marmalade/7.3/s3e/h/std/c++/stl/_threads.h" 2
# 65 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h" 2



# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_construct.h" 1
# 46 "c:/marmalade/7.3/s3e/h/std/c++/stl/_construct.h"
namespace _STL {
# 55 "c:/marmalade/7.3/s3e/h/std/c++/stl/_construct.h"
template <class _Tp>
inline void _Destroy(_Tp* __pointer) {
# 67 "c:/marmalade/7.3/s3e/h/std/c++/stl/_construct.h"
    __pointer->~_Tp();





}
# 92 "c:/marmalade/7.3/s3e/h/std/c++/stl/_construct.h"
template <class _T1, class _T2>
inline void _Construct(_T1* __p, const _T2& __val) {



    new (__p) _T1(__val);
}

template <class _T1>
inline void _Construct(_T1* __p) {







  new (__p) _T1();

}
# 120 "c:/marmalade/7.3/s3e/h/std/c++/stl/_construct.h"
template <class _ForwardIterator>
inline void
__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, const __false_type&) {
  for ( ; __first != __last; ++__first)
    _STL::_Destroy(&*__first);
}

template <class _ForwardIterator>
inline void __destroy_aux(_ForwardIterator, _ForwardIterator, const __true_type&) {}

template <class _ForwardIterator, class _Tp>
inline void
__destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*) {
  typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
  __destroy_aux(__first, __last, _Trivial_destructor());
}

template <class _ForwardIterator>
inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {
  __destroy(__first, __last, (typename iterator_traits< _ForwardIterator >::value_type*)0);
}

inline void _Destroy(char*, char*) {}

inline void _Destroy(wchar_t*, wchar_t*) {}
inline void _Destroy(const wchar_t*, const wchar_t*) {}






template <class _T1, class _T2>
inline void construct(_T1* __p, const _T2& __val) {_Construct(__p, __val); }
template <class _T1>
inline void construct(_T1* __p) { _Construct(__p); }
template <class _Tp>
inline void destroy(_Tp* __pointer) { _STL::_Destroy(__pointer); }
template <class _ForwardIterator>
inline void destroy(_ForwardIterator __first, _ForwardIterator __last) { _STL::_Destroy(__first, __last); }

}
# 69 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h" 2
# 85 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h"
namespace _STL {
# 94 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h"
typedef void (* __oom_handler_type)();

template <int __inst>
class __malloc_alloc {
private:
  static void* _S_oom_malloc(size_t);
  static __oom_handler_type __oom_handler;
public:

  typedef char value_type;





  static void* allocate(size_t __n) {
    void* __result = malloc(__n);
    if (0 == __result) __result = _S_oom_malloc(__n);
    return __result;
  }
  static void deallocate(void* __p, size_t ) { free((char*)__p); }
  static __oom_handler_type set_malloc_handler(__oom_handler_type __f) {
    __oom_handler_type __old = __oom_handler;
    __oom_handler = __f;
    return(__old);
  }
};




class __new_alloc {
public:

  typedef char value_type;





  static void* allocate(size_t __n) { return __stl_new(__n); }
  static void deallocate(void* __p, size_t) { __stl_delete(__p); }
};
# 146 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h"
template <class _Alloc>
class __debug_alloc : public _Alloc {
public:
  typedef _Alloc __allocator_type;
  typedef typename _Alloc::value_type value_type;
private:
  struct __alloc_header {
    size_t __magic: 16;
    size_t __type_size:16;
    unsigned long _M_size;
  };

  enum { __pad=8, __magic=0xdeba, __deleted_magic = 0xdebd,
  __shred_byte= 0xA3
  };

  enum { __extra_before = 16, __extra_after = 8 };



  static size_t __extra_before_chunk() {
    return (long)__extra_before/sizeof(value_type)+
      (size_t)((long)__extra_before%sizeof(value_type)>0);
  }
  static size_t __extra_after_chunk() {
    return (long)__extra_after/sizeof(value_type)+
      (size_t)((long)__extra_after%sizeof(value_type)>0);
  }
public:





  __debug_alloc() {}
  ~__debug_alloc() {}
  static void * allocate(size_t);
  static void deallocate(void *, size_t);
};
# 214 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h"
enum {_ALIGN = 8, _ALIGN_SHIFT=3, _MAX_BYTES = 128};



class _Node_alloc_obj {
public:
    _Node_alloc_obj * _M_free_list_link;
};

template <bool __threads, int __inst>
class __node_alloc {
  public:
  static inline size_t _S_round_up(size_t __bytes) { return (((__bytes) + (size_t)_ALIGN-1) & ~((size_t)_ALIGN - 1)); }
  typedef _Node_alloc_obj _Obj;
private:

  static void* _S_refill(size_t __n);


  static char* _S_chunk_alloc(size_t __p_size, int& __nobjs);

  static _Node_alloc_obj * _S_free_list[16];
  static char* _S_start_free;
  static char* _S_end_free;
  static size_t _S_heap_size;
  static void * _M_allocate(size_t __n);

  static void _M_deallocate(void *__p, size_t __n);
public:

  typedef char value_type;






  static void * allocate(size_t __n) { return (__n > (size_t)_MAX_BYTES) ? __stl_new(__n) : _M_allocate(__n); }

  static void deallocate(void *__p, size_t __n) { if (__n > (size_t)_MAX_BYTES) __stl_delete(__p); else _M_deallocate(__p, __n); }
};





typedef __node_alloc<false, 0> _Node_alloc;
# 301 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h"
typedef __malloc_alloc<0> __sgi_alloc;


typedef __malloc_alloc<0> __single_client_alloc;
typedef __malloc_alloc<0> __multithreaded_alloc;
# 329 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp>
class allocator {
public:

  typedef _Tp value_type;
  typedef value_type * pointer;
  typedef const _Tp* const_pointer;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() {}

  template <class _Tp1> allocator(const allocator<_Tp1>&) {}

  allocator(const allocator<_Tp>&) {}
  ~allocator() {}
  pointer address(reference __x) const { return &__x; }
  const_pointer address(const_reference __x) const { return &__x; }

  _Tp* allocate(size_type __n, const void* = 0) {
    return __n != 0 ? reinterpret_cast<value_type*>(__sgi_alloc::allocate(__n * sizeof(value_type))) : 0;
  }

  void deallocate(pointer __p, size_type __n) {
   
      if (__p != 0) __sgi_alloc::deallocate((void*)__p, __n * sizeof(value_type));
  }

  void deallocate(pointer __p) const { if (__p != 0) __sgi_alloc::deallocate((void*)__p, sizeof(value_type)); }
  size_type max_size() const { return size_t(-1) / sizeof(value_type); }
  void construct(pointer __p, const _Tp& __val) { _STL::_Construct(__p, __val); }
  void destroy(pointer __p) { _STL::_Destroy(__p); }




};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;

  typedef void value_type;


  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };





};


template <class _T1, class _T2> inline bool operator==(const allocator<_T1>&, const allocator<_T2>&) { return true; }
template <class _T1, class _T2> inline bool operator!=(const allocator<_T1>&, const allocator<_T2>&) { return false; }
# 411 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp, class _Allocator>
struct _Alloc_traits
{
  typedef _Allocator _Orig;

  typedef typename _Allocator::template rebind<_Tp> _Rebind_type;
  typedef typename _Rebind_type::other allocator_type;
  static allocator_type create_allocator(const _Orig& __a) { return allocator_type(__a); }





};
# 457 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp, class _Alloc>
inline typename _Alloc_traits<_Tp, _Alloc>::allocator_type
__stl_alloc_create(const _Alloc& __a, const _Tp*) {
  typedef typename _Alloc::template rebind<_Tp>::other _Rebound_type;
  return _Rebound_type(__a);
}
# 480 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h"
template <class _Value, class _Tp, class _MaybeReboundAlloc>
class _STLP_alloc_proxy : public _MaybeReboundAlloc {
private:
  typedef _MaybeReboundAlloc _Base;
  typedef _STLP_alloc_proxy<_Value, _Tp, _MaybeReboundAlloc> _Self;
public:
  _Value _M_data;
  inline _STLP_alloc_proxy(const _MaybeReboundAlloc& __a, _Value __p) : _MaybeReboundAlloc(__a), _M_data(__p) {}
# 509 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h"
};
# 520 "c:/marmalade/7.3/s3e/h/std/c++/stl/_alloc.h"
}
# 41 "c:/marmalade/7.3/s3e/h/std/c++/stl/_vector.h" 2







# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_uninitialized.h" 1
# 45 "c:/marmalade/7.3/s3e/h/std/c++/stl/_uninitialized.h"
namespace _STL {





template <class _InputIter, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
                     const __true_type&) {
  return __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter> :: _Ret());
}

template <class _InputIter, class _ForwardIter>
inline
_ForwardIter
__uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
                     const __false_type&)
{
  _ForwardIter __cur = __result;
  {
    for ( ; __first != __last; ++__first, ++__cur)
      _Construct(&*__cur, *__first);
    return __cur;
  }
  ;



}

template <class _InputIter, class _ForwardIter>
inline _ForwardIter
uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result) {
  return __uninitialized_copy(__first, __last, __result, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
}

inline char*
uninitialized_copy(const char* __first, const char* __last, char* __result) {
  return (char*)__copy_trivial (__first, __last, __result);
}


inline wchar_t*
uninitialized_copy(const wchar_t* __first, const wchar_t* __last, wchar_t* __result) {
  return (wchar_t*)__copy_trivial (__first, __last, __result);
}





template <class _InputIter, class _Size, class _ForwardIter>
inline
pair<_InputIter, _ForwardIter>
__uninitialized_copy_n(_InputIter __first, _Size __count,
                       _ForwardIter __result,
                       const input_iterator_tag &)
{
  _ForwardIter __cur = __result;
  {
    for ( ; __count > 0 ; --__count, ++__first, ++__cur)
      _Construct(&*__cur, *__first);
    return pair<_InputIter, _ForwardIter>(__first, __cur);
  }
  ;



}
# 135 "c:/marmalade/7.3/s3e/h/std/c++/stl/_uninitialized.h"
template <class _RandomAccessIter, class _Size, class _ForwardIter>
inline pair<_RandomAccessIter, _ForwardIter>
__uninitialized_copy_n(_RandomAccessIter __first, _Size __count, _ForwardIter __result, const random_access_iterator_tag &) {
  _RandomAccessIter __last = __first + __count;
  return pair<_RandomAccessIter, _ForwardIter>( __last, __uninitialized_copy(__first, __last, __result,
                                                                             typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type()));
}


template <class _InputIter, class _Size, class _ForwardIter>
inline pair<_InputIter, _ForwardIter>
uninitialized_copy_n(_InputIter __first, _Size __count,
                     _ForwardIter __result) {
  return __uninitialized_copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}




template <class _ForwardIter, class _Tp>
inline void
__uninitialized_fill(_ForwardIter __first, _ForwardIter __last,
                     const _Tp& __x, const __true_type&) {
  _STL::fill(__first, __last, __x);
}

template <class _ForwardIter, class _Tp>
inline void
__uninitialized_fill(_ForwardIter __first, _ForwardIter __last,
                     const _Tp& __x, const __false_type&)
{
  _ForwardIter __cur = __first;
  {
    for ( ; __cur != __last; ++__cur)
      _Construct(&*__cur, __x);
  }
  ;
}

template <class _ForwardIter, class _Tp>
inline void uninitialized_fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __x) {
  __uninitialized_fill(__first, __last, __x, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
}



template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
__uninitialized_fill_n(_ForwardIter __first, _Size __n,
                       const _Tp& __x, const __true_type&) {
  return _STL::fill_n(__first, __n, __x);
}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
__uninitialized_fill_n(_ForwardIter __first, _Size __n,
                       const _Tp& __x, const __false_type&)
{
  _ForwardIter __cur = __first;
  {
    for ( ; __n > 0; --__n, ++__cur)
      _Construct(&*__cur, __x);
    return __cur;
  }
  ;



}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x) {
  return __uninitialized_fill_n(__first, __n, __x, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
}
# 219 "c:/marmalade/7.3/s3e/h/std/c++/stl/_uninitialized.h"
template <class _InputIter1, class _InputIter2, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
                          _InputIter2 __first2, _InputIter2 __last2,
                          _ForwardIter __result, __true_type)
{
  return __uninitialized_copy(__first2, __last2,
                              __uninitialized_copy(__first1, __last1, __result, __true_type()), __true_type());
}

template <class _InputIter1, class _InputIter2, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
                          _InputIter2 __first2, _InputIter2 __last2,
                          _ForwardIter __result, __false_type)
{
  _ForwardIter __mid = __uninitialized_copy(__first1, __last1, __result, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
  {
    return __uninitialized_copy(__first2, __last2, __mid , typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
  }
  ;



}




template <class _ForwardIter, class _Tp, class _InputIter>
inline _ForwardIter
__uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid, const _Tp& __x,
                          _InputIter __first, _InputIter __last)
{
  typedef typename __type_traits<_Tp>::is_POD_type _I_POD;
  __uninitialized_fill(__result, __mid, __x, _I_POD());
  {
    return __uninitialized_copy(__first, __last, __mid, _I_POD());
  }
  ;



}




template <class _InputIter, class _ForwardIter, class _Tp>
inline void
__uninitialized_copy_fill(_InputIter __first1, _InputIter __last1,
                          _ForwardIter __first2, _ForwardIter __last2,
                          const _Tp& __x)
{
  typedef typename __type_traits<_Tp>::is_POD_type _I_POD;
  _ForwardIter __mid2 = __uninitialized_copy(__first1, __last1, __first2, _I_POD());
  {
    __uninitialized_fill(__mid2, __last2, __x, _I_POD());
  }
  ;
}

}
# 49 "c:/marmalade/7.3/s3e/h/std/c++/stl/_vector.h" 2



# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_range_errors.h" 1
# 36 "c:/marmalade/7.3/s3e/h/std/c++/stl/_range_errors.h"
namespace _STL {
void __stl_throw_range_error(const char* __msg);
void __stl_throw_out_of_range(const char* __msg);
void __stl_throw_length_error(const char* __msg);
void __stl_throw_invalid_argument(const char* __msg);
void __stl_throw_overflow_error(const char* __msg);
}
# 53 "c:/marmalade/7.3/s3e/h/std/c++/stl/_vector.h" 2





namespace _STL {





template <class _Tp, class _Alloc>
class _Vector_base {
public:

 
  typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;

  _Vector_base(const _Alloc& __a)
    : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {
  }
  _Vector_base(size_t __n, const _Alloc& __a)
    : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0)
  {
    _M_start = _M_end_of_storage.allocate(__n);
    _M_finish = _M_start;
    _M_end_of_storage._M_data = _M_start + __n;

  }

  ~_Vector_base() {
    if (_M_start !=0)
    _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start);
  }

protected:
  _Tp* _M_start;
  _Tp* _M_finish;
  _STLP_alloc_proxy<_Tp*, _Tp, allocator_type> _M_end_of_storage;
};

template <class _Tp, class _Alloc = allocator< _Tp > >
class vector : public _Vector_base<_Tp, _Alloc>
{
private:
  typedef _Vector_base<_Tp, _Alloc> _Base;
public:
  typedef _Tp value_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type* iterator;
  typedef const value_type* const_iterator;

public:
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef random_access_iterator_tag _Iterator_category;

  typedef _STL::reverse_iterator<const_iterator> const_reverse_iterator; typedef _STL::reverse_iterator<iterator> reverse_iterator;
 
  typedef typename _Vector_base<_Tp, _Alloc>::allocator_type allocator_type;

  allocator_type get_allocator() const {
    return (const allocator_type&)this->_M_end_of_storage;
  }
protected:
  typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialAss;
  typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _IsPODType;


  void _M_insert_overflow(pointer __position, const _Tp& __x, const __false_type&,
     size_type __fill_len, bool __atend = false) {
    const size_type __old_size = size();
    const size_type __len = __old_size + (max)(__old_size, __fill_len);

    pointer __new_start = this->_M_end_of_storage.allocate(__len);
    pointer __new_finish = __new_start;
    {
      __new_finish = __uninitialized_copy(this->_M_start, __position, __new_start, __false_type());

      if (__fill_len == 1) {
        _Construct(__new_finish, __x);
        ++__new_finish;
      } else
        __new_finish = __uninitialized_fill_n(__new_finish, __fill_len, __x, __false_type());
      if (!__atend)

        __new_finish = __uninitialized_copy(__position, this->_M_finish, __new_finish, __false_type());
    }
   
                                                                         ;
    _M_clear();
    _M_set(__new_start, __new_finish, __new_start + __len);
  }

  void _M_insert_overflow(pointer __position, const _Tp& __x, const __true_type&,
     size_type __fill_len, bool __atend = false) {
    const size_type __old_size = size();
    const size_type __len = __old_size + (max)(__old_size, __fill_len);

    pointer __new_start = this->_M_end_of_storage.allocate(__len);
    pointer __new_finish = (pointer)__copy_trivial(this->_M_start, __position, __new_start);

    __new_finish = fill_n(__new_finish, __fill_len, __x);
    if (!__atend)

      __new_finish = (pointer)__copy_trivial(__position, this->_M_finish, __new_finish);
    _M_clear();
    _M_set(__new_start, __new_finish, __new_start + __len);
  }

  void _M_range_check(size_type __n) const {
    if (__n >= size_type(this->_M_finish-this->_M_start))
      __stl_throw_out_of_range("vector");
  }

public:
  iterator begin() { return this->_M_start; }
  const_iterator begin() const { return this->_M_start; }
  iterator end() { return this->_M_finish; }
  const_iterator end() const { return this->_M_finish; }

  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }

  size_type size() const { return size_type(this->_M_finish - this->_M_start); }
  size_type max_size() const { return size_type(-1) / sizeof(_Tp); }
  size_type capacity() const { return size_type(this->_M_end_of_storage._M_data - this->_M_start); }
  bool empty() const { return this->_M_start == this->_M_finish; }

  reference operator[](size_type __n) { return *(begin() + __n); }
  const_reference operator[](size_type __n) const { return *(begin() + __n); }

  reference front() { return *begin(); }
  const_reference front() const { return *begin(); }
  reference back() { return *(end() - 1); }
  const_reference back() const { return *(end() - 1); }

  reference at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }
  const_reference at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }

  explicit vector(const allocator_type& __a = allocator_type()) :
    _Vector_base<_Tp, _Alloc>(__a) {}

  vector(size_type __n, const _Tp& __val,
         const allocator_type& __a = allocator_type())
    : _Vector_base<_Tp, _Alloc>(__n, __a) {
    this->_M_finish = uninitialized_fill_n(this->_M_start, __n, __val);
  }

  explicit vector(size_type __n)
    : _Vector_base<_Tp, _Alloc>(__n, allocator_type() ) {
    this->_M_finish = uninitialized_fill_n(this->_M_start, __n, _Tp());
  }

  vector(const vector<_Tp, _Alloc>& __x)
    : _Vector_base<_Tp, _Alloc>(__x.size(), __x.get_allocator()) {
    this->_M_finish = __uninitialized_copy((const_pointer)__x._M_start,
                                           (const_pointer)__x._M_finish, this->_M_start, _IsPODType());
  }



  template <class _Integer>
  void _M_initialize_aux(_Integer __n, _Integer __val, const __true_type&) {
    this->_M_start = this->_M_end_of_storage.allocate(__n);
    this->_M_end_of_storage._M_data = this->_M_start + __n;
    this->_M_finish = uninitialized_fill_n(this->_M_start, __n, __val);
  }

  template <class _InputIterator>
  void _M_initialize_aux(_InputIterator __first, _InputIterator __last,
                         const __false_type&) {
    _M_range_initialize(__first, __last, typename iterator_traits< _InputIterator >::iterator_category());
  }
# 242 "c:/marmalade/7.3/s3e/h/std/c++/stl/_vector.h"
  template <class _InputIterator>
  vector(_InputIterator __first, _InputIterator __last,
         const allocator_type& __a = allocator_type() ) :
    _Vector_base<_Tp, _Alloc>(__a) {
    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
    _M_initialize_aux(__first, __last, _Integral());
  }
# 258 "c:/marmalade/7.3/s3e/h/std/c++/stl/_vector.h"
  ~vector() { _Destroy(this->_M_start, this->_M_finish); }

  vector<_Tp, _Alloc>& operator=(const vector<_Tp, _Alloc>& __x);

  void reserve(size_type __n);






  void assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }
  void _M_fill_assign(size_type __n, const _Tp& __val);


  template <class _ForwardIter>
  void _M_assign_aux(_ForwardIter __first, _ForwardIter __last, const forward_iterator_tag &)



  {
    size_type __len = distance(__first, __last);

    if (__len > capacity()) {
      iterator __tmp = _M_allocate_and_copy(__len, __first, __last);
    _M_clear();
    _M_set(__tmp, __tmp + __len, __tmp + __len);
    }
    else if (size() >= __len) {
      iterator __new_finish = copy(__first, __last, this->_M_start);
      _Destroy(__new_finish, this->_M_finish);
      this->_M_finish = __new_finish;
    }
    else {

          _ForwardIter __mid = __first;
          advance(__mid, size());



    copy(__first, __mid, this->_M_start);
    this->_M_finish = __uninitialized_copy(__mid, __last, this->_M_finish, _IsPODType());
    }
  }


  template <class _InputIter>
  void _M_assign_aux(_InputIter __first, _InputIter __last,
       const input_iterator_tag &) {
    iterator __cur = begin();
    for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
      *__cur = *__first;
    if (__first == __last)
      erase(__cur, end());
    else
      insert(end(), __first, __last);
  }

  template <class _Integer>
  void _M_assign_dispatch(_Integer __n, _Integer __val, const __true_type&)
    { assign((size_type) __n, (_Tp) __val); }

  template <class _InputIter>
  void _M_assign_dispatch(_InputIter __first, _InputIter __last, const __false_type&)
    { _M_assign_aux(__first, __last, typename iterator_traits< _InputIter >::iterator_category()); }

  template <class _InputIterator>
  void assign(_InputIterator __first, _InputIterator __last) {
    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
    _M_assign_dispatch(__first, __last, _Integral());
  }


  void push_back(const _Tp& __x) {
    if (this->_M_finish != this->_M_end_of_storage._M_data) {
      _Construct(this->_M_finish, __x);
      ++this->_M_finish;
    }
    else
      _M_insert_overflow(this->_M_finish, __x, _IsPODType(), 1UL, true);
  }

  void swap(vector<_Tp, _Alloc>& __x) {
    _STL::swap(this->_M_start, __x._M_start);
    _STL::swap(this->_M_finish, __x._M_finish);
    _STL::swap(this->_M_end_of_storage, __x._M_end_of_storage);
  }

  iterator insert(iterator __position, const _Tp& __x) {
    size_type __n = __position - begin();
    if (this->_M_finish != this->_M_end_of_storage._M_data) {
      if (__position == end()) {
        _Construct(this->_M_finish, __x);
        ++this->_M_finish;
      } else {
        _Construct(this->_M_finish, *(this->_M_finish - 1));
        ++this->_M_finish;
        _Tp __x_copy = __x;
        __copy_backward_ptrs(__position, this->_M_finish - 2, this->_M_finish - 1, _TrivialAss());
        *__position = __x_copy;
      }
    }
    else
      _M_insert_overflow(__position, __x, _IsPODType(), 1UL);
    return begin() + __n;
  }


  void push_back() { push_back(_Tp()); }
  iterator insert(iterator __position) { return insert(__position, _Tp()); }


  void _M_fill_insert (iterator __pos, size_type __n, const _Tp& __x);



  template <class _Integer>
  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
                          const __true_type&) {
    _M_fill_insert(__pos, (size_type) __n, (_Tp) __val);
  }

  template <class _InputIterator>
  void _M_insert_dispatch(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          const __false_type&) {
    _M_range_insert(__pos, __first, __last, typename iterator_traits< _InputIterator >::iterator_category());
  }


  template <class _InputIterator>
  void insert(iterator __pos, _InputIterator __first, _InputIterator __last) {
    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
    _M_insert_dispatch(__pos, __first, __last, _Integral());
  }

  template <class _InputIterator>
  void _M_range_insert(iterator __pos,
         _InputIterator __first,
         _InputIterator __last,
         const input_iterator_tag &) {
    for ( ; __first != __last; ++__first) {
      __pos = insert(__pos, *__first);
      ++__pos;
    }
  }

  template <class _ForwardIterator>
  void _M_range_insert(iterator __position,
                       _ForwardIterator __first,
                       _ForwardIterator __last,
                       const forward_iterator_tag &)





  {
    if (__first != __last) {
      size_type __n = distance(__first, __last);

      if (size_type(this->_M_end_of_storage._M_data - this->_M_finish) >= __n) {
        const size_type __elems_after = this->_M_finish - __position;
        pointer __old_finish = this->_M_finish;
        if (__elems_after > __n) {
          __uninitialized_copy(this->_M_finish - __n, this->_M_finish, this->_M_finish, _IsPODType());
          this->_M_finish += __n;
          __copy_backward_ptrs(__position, __old_finish - __n, __old_finish, _TrivialAss());
          copy(__first, __last, __position);
        }
        else {

          _ForwardIterator __mid = __first;
          advance(__mid, __elems_after);



          __uninitialized_copy(__mid, __last, this->_M_finish, _IsPODType());
          this->_M_finish += __n - __elems_after;
          __uninitialized_copy(__position, __old_finish, this->_M_finish, _IsPODType());
          this->_M_finish += __elems_after;
          copy(__first, __mid, __position);
        }
      }
      else {
        const size_type __old_size = size();
        const size_type __len = __old_size + (max)(__old_size, __n);
        pointer __new_start = this->_M_end_of_storage.allocate(__len);
        pointer __new_finish = __new_start;
        {
          __new_finish = __uninitialized_copy(this->_M_start, __position, __new_start, _IsPODType());
          __new_finish = __uninitialized_copy(__first, __last, __new_finish, _IsPODType());
          __new_finish = __uninitialized_copy(__position, this->_M_finish, __new_finish, _IsPODType());
        }
       
                                                                             ;
        _M_clear();
        _M_set(__new_start, __new_finish, __new_start + __len);
      }
    }
  }
  void insert (iterator __pos, size_type __n, const _Tp& __x)
  { _M_fill_insert(__pos, __n, __x); }

  void pop_back() {
    --this->_M_finish;
    _Destroy(this->_M_finish);
  }
  iterator erase(iterator __position) {
    if (__position + 1 != end())
      __copy_ptrs(__position + 1, this->_M_finish, __position, _TrivialAss());
    --this->_M_finish;
    _Destroy(this->_M_finish);
    return __position;
  }
  iterator erase(iterator __first, iterator __last) {
    pointer __i = __copy_ptrs(__last, this->_M_finish, __first, _TrivialAss());
    _Destroy(__i, this->_M_finish);
    this->_M_finish = __i;
    return __first;
  }

  void resize(size_type __new_size, _Tp __x) {
    if (__new_size < size())
      erase(begin() + __new_size, end());
    else
      insert(end(), __new_size - size(), __x);
  }
  void resize(size_type __new_size) { resize(__new_size, _Tp()); }
  void clear() {
    erase(begin(), end());
  }

protected:

  void _M_clear() {

    _Destroy(this->_M_start, this->_M_finish);
    this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);

  }

  void _M_set(pointer __s, pointer __f, pointer __e) {
    this->_M_start = __s;
    this->_M_finish = __f;
    this->_M_end_of_storage._M_data = __e;
  }


  template <class _ForwardIterator>
  pointer _M_allocate_and_copy(size_type __n, _ForwardIterator __first,
    _ForwardIterator __last)




  {
    pointer __result = this->_M_end_of_storage.allocate(__n);
    {

      __uninitialized_copy(__first, __last, __result, _IsPODType());



      return __result;
    }
    ;



  }



  template <class _InputIterator>
  void _M_range_initialize(_InputIterator __first,
                           _InputIterator __last, const input_iterator_tag &) {
    for ( ; __first != __last; ++__first)
      push_back(*__first);
  }

  template <class _ForwardIterator>
  void _M_range_initialize(_ForwardIterator __first,
                           _ForwardIterator __last, const forward_iterator_tag &) {
    size_type __n = distance(__first, __last);
    this->_M_start = this->_M_end_of_storage.allocate(__n);
    this->_M_end_of_storage._M_data = this->_M_start + __n;
    this->_M_finish = __uninitialized_copy(__first, __last, this->_M_start, _IsPODType());
  }


};



# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_relops_cont.h" 1





template <class _Tp, class _Alloc>
inline bool operator==(const vector<_Tp, _Alloc>& __x,
                                   const vector<_Tp, _Alloc>& __y) {
  return __x.size() == __y.size() &&
    equal(__x.begin(), __x.end(), __y.begin());
}


template <class _Tp, class _Alloc>
inline bool operator<(const vector<_Tp, _Alloc>& __x,
                                  const vector<_Tp, _Alloc>& __y) {
  return lexicographical_compare(__x.begin(), __x.end(),
     __y.begin(), __y.end());
}

template <class _Tp, class _Alloc> inline bool operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {return !(__x == __y);}template <class _Tp, class _Alloc> inline bool operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {return __y < __x;}template <class _Tp, class _Alloc> inline bool operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) { return !(__y < __x);}template <class _Tp, class _Alloc> inline bool operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) { return !(__x < __y);}


template <class _Tp, class _Alloc>
inline void swap(vector<_Tp, _Alloc>& __x,
                             vector<_Tp, _Alloc>& __y) {
  __x.swap(__y);
}
# 554 "c:/marmalade/7.3/s3e/h/std/c++/stl/_vector.h" 2
# 568 "c:/marmalade/7.3/s3e/h/std/c++/stl/_vector.h"
}


# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_vector.c" 1
# 43 "c:/marmalade/7.3/s3e/h/std/c++/stl/_vector.c"
namespace _STL {

template <class _Tp, class _Alloc>
void
vector<_Tp, _Alloc>::reserve(size_type __n) {
  if (capacity() < __n) {
    const size_type __old_size = size();
    pointer __tmp;
    if (this->_M_start) {
      __tmp = _M_allocate_and_copy(__n, this->_M_start, this->_M_finish);
      _M_clear();
    } else {
      __tmp = this->_M_end_of_storage.allocate(__n);
    }
    _M_set(__tmp, __tmp + __old_size, __tmp + __n);
  }
}

template <class _Tp, class _Alloc>
void
vector<_Tp, _Alloc>::_M_fill_insert(
        iterator __position,
        size_type __n, const _Tp& __x) {
  if (__n != 0) {
    if (size_type(this->_M_end_of_storage._M_data - this->_M_finish) >= __n) {
      _Tp __x_copy = __x;
      const size_type __elems_after = this->_M_finish - __position;
      pointer __old_finish = this->_M_finish;
      if (__elems_after > __n) {
        __uninitialized_copy(this->_M_finish - __n, this->_M_finish, this->_M_finish, _IsPODType());
        this->_M_finish += __n;
        __copy_backward_ptrs(__position, __old_finish - __n, __old_finish, _TrivialAss());
        _STL::fill(__position, __position + __n, __x_copy);
      }
      else {
        uninitialized_fill_n(this->_M_finish, __n - __elems_after, __x_copy);
        this->_M_finish += __n - __elems_after;
        __uninitialized_copy(__position, __old_finish, this->_M_finish, _IsPODType());
        this->_M_finish += __elems_after;
        _STL::fill(__position, __old_finish, __x_copy);
      }
    }
    else
      _M_insert_overflow(__position, __x, _IsPODType(), __n);
  }
}

template <class _Tp, class _Alloc>
vector<_Tp,_Alloc>&
vector<_Tp,_Alloc>::operator=(const vector<_Tp, _Alloc>& __x)
{
  if (&__x != this) {
    const size_type __xlen = __x.size();
    if (__xlen > capacity()) {
      pointer __tmp = _M_allocate_and_copy(__xlen, (const_pointer)__x._M_start+0, (const_pointer)__x._M_finish+0);
      _M_clear();
      this->_M_start = __tmp;
      this->_M_end_of_storage._M_data = this->_M_start + __xlen;
    }
    else if (size() >= __xlen) {
      pointer __i = __copy_ptrs((const_pointer)__x._M_start+0, (const_pointer)__x._M_finish+0, (pointer)this->_M_start, _TrivialAss());
      _STL::_Destroy(__i, this->_M_finish);
    }
    else {
      __copy_ptrs((const_pointer)__x._M_start, (const_pointer)__x._M_start + size(), (pointer)this->_M_start, _TrivialAss());
      __uninitialized_copy((const_pointer)__x._M_start + size(), (const_pointer)__x._M_finish+0, this->_M_finish, _IsPODType());
    }
    this->_M_finish = this->_M_start + __xlen;
  }
  return *this;
}

template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::_M_fill_assign(size_t __n, const _Tp& __val) {
  if (__n > capacity()) {
    vector<_Tp, _Alloc> __tmp(__n, __val, get_allocator());
    __tmp.swap(*this);
  }
  else if (__n > size()) {
    fill(begin(), end(), __val);
    this->_M_finish = _STL::uninitialized_fill_n(this->_M_finish, __n - size(), __val);
  }
  else
    erase(_STL::fill_n(begin(), __n, __val), end());
}

}
# 572 "c:/marmalade/7.3/s3e/h/std/c++/stl/_vector.h" 2



# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_bvector.h" 1
# 39 "c:/marmalade/7.3/s3e/h/std/c++/stl/_bvector.h"
namespace _STL {

struct _Bit_reference {
  unsigned int* _M_p;
  unsigned int _M_mask;
  _Bit_reference(unsigned int* __x, unsigned int __y)
    : _M_p(__x), _M_mask(__y) {}

public:
  _Bit_reference() : _M_p(0), _M_mask(0) {}

  operator bool() const {
   return !(!(*_M_p & _M_mask));
  }
  _Bit_reference& operator=(bool __x) {
    if (__x) *_M_p |= _M_mask;
    else *_M_p &= ~_M_mask;
    return *this;
  }
  _Bit_reference& operator=(const _Bit_reference& __x) {
   return *this = bool(__x);
  }
  bool operator==(const _Bit_reference& __x) const {
   return bool(*this) == bool(__x);
  }
  bool operator<(const _Bit_reference& __x) const {
    return !bool(*this) && bool(__x);
  }

  _Bit_reference& operator |= (bool __x) {
   if (__x)
    *_M_p |= _M_mask;
   return *this;
  }
  _Bit_reference& operator &= (bool __x) {
   if (!__x)
    *_M_p &= ~_M_mask;
   return *this;
  }
  void flip() { *_M_p ^= _M_mask; }
};


inline void swap(_Bit_reference& __x, _Bit_reference& __y)
{
  bool __tmp = (bool)__x;
  __x = __y;
  __y = __tmp;
}

struct _Bit_iterator_base;

struct _Bit_iterator_base
{
  typedef ptrdiff_t difference_type;

  unsigned int* _M_p;
  unsigned int _M_offset;

  void _M_bump_up() {
    if (_M_offset++ == (int(8*sizeof(unsigned int))) - 1) {
      _M_offset = 0;
      ++_M_p;
    }
  }

  void _M_bump_down() {
    if (_M_offset-- == 0) {
      _M_offset = (int(8*sizeof(unsigned int))) - 1;
      --_M_p;
    }
  }

  _Bit_iterator_base() : _M_p(0), _M_offset(0) {}
  _Bit_iterator_base(unsigned int* __x, unsigned int __y) : _M_p(__x), _M_offset(__y) {}



  void _M_advance (difference_type __i) {
    difference_type __n = __i + _M_offset;
    _M_p += __n / (int(8*sizeof(unsigned int)));
    __n = __n % (int(8*sizeof(unsigned int)));
    if (__n < 0) {
      _M_offset = (unsigned int) __n + (int(8*sizeof(unsigned int)));
      --_M_p;
    } else
      _M_offset = (unsigned int) __n;
  }

  difference_type _M_subtract(const _Bit_iterator_base& __x) const {
    return (int(8*sizeof(unsigned int))) * (_M_p - __x._M_p) + _M_offset - __x._M_offset;
  }
};

inline bool operator==(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return __y._M_p == __x._M_p && __y._M_offset == __x._M_offset;
}
inline bool operator!=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return __y._M_p != __x._M_p || __y._M_offset != __x._M_offset;
}

inline bool operator<(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return __x._M_p < __y._M_p || (__x._M_p == __y._M_p && __x._M_offset < __y._M_offset);
}

inline bool operator>(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return operator <(__y , __x);
}
inline bool operator<=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return !(__y < __x);
}
inline bool operator>=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return !(__x < __y);
}

template <class _Ref, class _Ptr>
struct _Bit_iter : public _Bit_iterator_base
{
  typedef _Ref reference;
  typedef _Ptr pointer;
  typedef _Bit_iter<_Ref, _Ptr> _Self;
  typedef random_access_iterator_tag iterator_category;
  typedef bool value_type;
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;

  _Bit_iter(unsigned int* __x, unsigned int __y) : _Bit_iterator_base(__x, __y) {}
  _Bit_iter() {}

  _Bit_iter(const _Bit_iter<_Bit_reference, _Bit_reference*>& __x):
    _Bit_iterator_base((const _Bit_iterator_base&)__x) {}




  reference operator*() const {
    return _Bit_reference(_M_p, 1UL << _M_offset);
  }
  _Self& operator++() {
    _M_bump_up();
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    _M_bump_up();
    return __tmp;
  }
  _Self& operator--() {
    _M_bump_down();
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    _M_bump_down();
    return __tmp;
  }
  _Self& operator+=(difference_type __i) {
    _M_advance(__i);
    return *this;
  }
  _Self& operator-=(difference_type __i) {
    *this += -__i;
    return *this;
  }
  _Self operator+(difference_type __i) const {
    _Self __tmp = *this;
    return __tmp += __i;
  }
  _Self operator-(difference_type __i) const {
    _Self __tmp = *this;
    return __tmp -= __i;
  }
  difference_type operator-(const _Self& __x) const {
    return _M_subtract(__x);
  }
  reference operator[](difference_type __i) { return *(*this + __i); }
};

template <class _Ref, class _Ptr>
inline _Bit_iter<_Ref,_Ptr>
operator+(ptrdiff_t __n, const _Bit_iter<_Ref, _Ptr>& __x) {
   return __x + __n;
}
# 230 "c:/marmalade/7.3/s3e/h/std/c++/stl/_bvector.h"
typedef _Bit_iter<bool, const bool*> _Bit_const_iterator;
typedef _Bit_iter<_Bit_reference, _Bit_reference*> _Bit_iterator;





template <class _Alloc>
class _Bvector_base
{
public:
 
  typedef typename _Alloc_traits<bool, _Alloc>::allocator_type allocator_type;
  typedef unsigned int __chunk_type;
  typedef typename _Alloc_traits<__chunk_type,
          _Alloc>::allocator_type __chunk_allocator_type;
  allocator_type get_allocator() const {
    return (const __chunk_allocator_type&)_M_end_of_storage;
  }
  static allocator_type __get_dfl_allocator() { return allocator_type(); }

  _Bvector_base(const allocator_type& __a)
    : _M_start(), _M_finish(), _M_end_of_storage(__a,
       (__chunk_type*)0) {
  }
  ~_Bvector_base() { _M_deallocate();
  }

protected:

  unsigned int* _M_bit_alloc(size_t __n)
    { return _M_end_of_storage.allocate((__n + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int)))); }
  void _M_deallocate() {
    if (_M_start._M_p)
      _M_end_of_storage.deallocate(_M_start._M_p,
       _M_end_of_storage._M_data - _M_start._M_p);
  }

  _Bit_iterator _M_start;
  _Bit_iterator _M_finish;
  _STLP_alloc_proxy<__chunk_type*, __chunk_type, __chunk_allocator_type> _M_end_of_storage;
};
# 313 "c:/marmalade/7.3/s3e/h/std/c++/stl/_bvector.h"
template <class _Alloc>
class vector <bool, _Alloc> : public _Bvector_base<_Alloc >
{
  typedef _Bvector_base<_Alloc > _Base;
  typedef vector <bool, _Alloc> _Self;
public:
  typedef bool value_type;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef _Bit_reference reference;
  typedef bool const_reference;
  typedef _Bit_reference* pointer;
  typedef const bool* const_pointer;
  typedef random_access_iterator_tag _Iterator_category;

  typedef _Bit_iterator iterator;
  typedef _Bit_const_iterator const_iterator;


  typedef _STL::reverse_iterator<const_iterator> const_reverse_iterator;
  typedef _STL::reverse_iterator<iterator> reverse_iterator;
# 349 "c:/marmalade/7.3/s3e/h/std/c++/stl/_bvector.h"
  typedef typename _Bvector_base<_Alloc >::allocator_type allocator_type;
  typedef typename _Bvector_base<_Alloc >::__chunk_type __chunk_type ;





protected:

  void _M_initialize(size_type __n) {
    unsigned int* __q = this->_M_bit_alloc(__n);
    this->_M_end_of_storage._M_data = __q + (__n + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int)));
    this->_M_start = iterator(__q, 0);
    this->_M_finish = this->_M_start + difference_type(__n);
  }
  void _M_insert_aux(iterator __position, bool __x) {
    if (this->_M_finish._M_p != this->_M_end_of_storage._M_data) {
      __copy_backward(__position, this->_M_finish, this->_M_finish + 1, random_access_iterator_tag(), (difference_type*)0 );
      *__position = __x;
      ++this->_M_finish;
    }
    else {
      size_type __len = size() ? 2 * size() : (int(8*sizeof(unsigned int)));
      unsigned int* __q = this->_M_bit_alloc(__len);
      iterator __i = copy(begin(), __position, iterator(__q, 0));
      *__i++ = __x;
      this->_M_finish = copy(__position, end(), __i);
      this->_M_deallocate();
      this->_M_end_of_storage._M_data = __q + (__len + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int)));
      this->_M_start = iterator(__q, 0);
    }
  }


  template <class _InputIterator>
  void _M_initialize_range(_InputIterator __first, _InputIterator __last,
   const input_iterator_tag &) {
    this->_M_start = iterator();
    this->_M_finish = iterator();
    this->_M_end_of_storage._M_data = 0;
    for ( ; __first != __last; ++__first)
      push_back(*__first);
  }

  template <class _ForwardIterator>
  void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
                           const forward_iterator_tag &) {
    size_type __n = distance(__first, __last);
    _M_initialize(__n);

    copy(__first, __last, this->_M_start);
  }

  template <class _InputIterator>
  void _M_insert_range(iterator __pos,
                       _InputIterator __first, _InputIterator __last,
                       const input_iterator_tag &) {
    for ( ; __first != __last; ++__first) {
      __pos = insert(__pos, *__first);
      ++__pos;
    }
  }

  template <class _ForwardIterator>
  void _M_insert_range(iterator __position,
                       _ForwardIterator __first, _ForwardIterator __last,
                       const forward_iterator_tag &) {
    if (__first != __last) {
      size_type __n = distance(__first, __last);
      if (capacity() - size() >= __n) {
        __copy_backward(__position, end(), this->_M_finish + difference_type(__n), random_access_iterator_tag(), (difference_type*)0 );
        copy(__first, __last, __position);
        this->_M_finish += difference_type(__n);
      }
      else {
        size_type __len = size() + (max)(size(), __n);
        unsigned int* __q = this->_M_bit_alloc(__len);
        iterator __i = copy(begin(), __position, iterator(__q, 0));
        __i = copy(__first, __last, __i);
        this->_M_finish = copy(__position, end(), __i);
        this->_M_deallocate();
        this->_M_end_of_storage._M_data = __q + (__len + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int)));
        this->_M_start = iterator(__q, 0);
      }
    }
  }



public:
  iterator begin() { return this->_M_start; }
  const_iterator begin() const { return this->_M_start; }
  iterator end() { return this->_M_finish; }
  const_iterator end() const { return this->_M_finish; }

  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const {
    return const_reverse_iterator(end());
  }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const {
    return const_reverse_iterator(begin());
  }

  size_type size() const { return size_type(end() - begin()); }
  size_type max_size() const { return size_type(-1); }
  size_type capacity() const {
    return size_type(const_iterator(this->_M_end_of_storage._M_data, 0) - begin());
  }
  bool empty() const { return begin() == end(); }
  reference operator[](size_type __n)
  { return *(begin() + difference_type(__n)); }
  const_reference operator[](size_type __n) const
  { return *(begin() + difference_type(__n)); }

  void _M_range_check(size_type __n) const {
    if (__n >= this->size())
      __stl_throw_range_error("vector<bool>");
  }

  reference at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }
  const_reference at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

  explicit vector(const allocator_type& __a = allocator_type())
    : _Bvector_base<_Alloc >(__a) {}

  vector(size_type __n, bool __val,
            const allocator_type& __a =
     allocator_type())
    : _Bvector_base<_Alloc >(__a)
  {
    _M_initialize(__n);
    fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), __val ? ~0 : 0);
  }

  explicit vector(size_type __n)
    : _Bvector_base<_Alloc >(allocator_type())
  {
    _M_initialize(__n);
    fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), 0);
  }

  vector(const _Self& __x) : _Bvector_base<_Alloc >(__x.get_allocator()) {
    _M_initialize(__x.size());
    copy(__x.begin(), __x.end(), this->_M_start);
  }


  template <class _Integer>
  void _M_initialize_dispatch(_Integer __n, _Integer __x, const __true_type&) {
    _M_initialize(__n);
    fill(this->_M_start._M_p, this->_M_end_of_storage._M_data, __x ? ~0 : 0);
  }

  template <class _InputIterator>
  void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                              const __false_type&) {
    _M_initialize_range(__first, __last, typename iterator_traits< _InputIterator >::iterator_category());
  }
# 520 "c:/marmalade/7.3/s3e/h/std/c++/stl/_bvector.h"
  template <class _InputIterator>
  vector(_InputIterator __first, _InputIterator __last,
            const allocator_type& __a = allocator_type())
    : _Base(__a)
  {
    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
    _M_initialize_dispatch(__first, __last, _Integral());
  }
# 547 "c:/marmalade/7.3/s3e/h/std/c++/stl/_bvector.h"
  ~vector() { }

  vector <bool, _Alloc>& operator=(const vector <bool, _Alloc>& __x) {
    if (&__x == this) return *this;
    if (__x.size() > capacity()) {
      this->_M_deallocate();
      _M_initialize(__x.size());
    }
    copy(__x.begin(), __x.end(), begin());
    this->_M_finish = begin() + difference_type(__x.size());
    return *this;
  }






  void _M_fill_assign(size_t __n, bool __x) {
    if (__n > size()) {
      fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), __x ? ~0 : 0);
      insert(end(), __n - size(), __x);
    }
    else {
      erase(begin() + __n, end());
      fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), __x ? ~0 : 0);
    }
  }
  void assign(size_t __n, bool __x) { _M_fill_assign(__n, __x); }



  template <class _InputIterator>
  void assign(_InputIterator __first, _InputIterator __last) {
    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
    _M_assign_dispatch(__first, __last, _Integral());
  }

  template <class _Integer>
  void _M_assign_dispatch(_Integer __n, _Integer __val, const __true_type&)
    { _M_fill_assign((size_t) __n, (bool) __val); }

  template <class _InputIter>
  void _M_assign_dispatch(_InputIter __first, _InputIter __last, const __false_type&)
    { _M_assign_aux(__first, __last, typename iterator_traits< _InputIter >::iterator_category()); }

  template <class _InputIterator>
  void _M_assign_aux(_InputIterator __first, _InputIterator __last,
                     const input_iterator_tag &) {
    iterator __cur = begin();
    for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
      *__cur = *__first;
    if (__first == __last)
      erase(__cur, end());
    else
      insert(end(), __first, __last);
  }

  template <class _ForwardIterator>
  void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                     const forward_iterator_tag &) {
    size_type __len = distance(__first, __last);
    if (__len < size())
      erase(copy(__first, __last, begin()), end());
    else {
      _ForwardIterator __mid = __first;
      advance(__mid, size());
      copy(__first, __mid, begin());
      insert(end(), __mid, __last);
    }
  }



  void reserve(size_type __n) {
    if (capacity() < __n) {
      unsigned int* __q = this->_M_bit_alloc(__n);
      _Bit_iterator __z(__q, 0);
      this->_M_finish = copy(begin(), end(), __z);
      this->_M_deallocate();
      this->_M_start = iterator(__q, 0);
      this->_M_end_of_storage._M_data = __q + (__n + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int)));
    }
  }

  reference front() { return *begin(); }
  const_reference front() const { return *begin(); }
  reference back() { return *(end() - 1); }
  const_reference back() const { return *(end() - 1); }
  void push_back(bool __x) {
    if (this->_M_finish._M_p != this->_M_end_of_storage._M_data) {
      *(this->_M_finish) = __x;
      ++this->_M_finish;
    }
    else
      _M_insert_aux(end(), __x);
  }
  void swap(vector <bool, _Alloc>& __x) {
    _STL::swap(this->_M_start, __x._M_start);
    _STL::swap(this->_M_finish, __x._M_finish);
    _STL::swap(this->_M_end_of_storage, __x._M_end_of_storage);
  }
  iterator insert(iterator __position, bool __x = bool()) {
    difference_type __n = __position - begin();
    if (this->_M_finish._M_p != this->_M_end_of_storage._M_data && __position == end()) {
      *(this->_M_finish) = __x;
      ++this->_M_finish;
    }
    else
      _M_insert_aux(__position, __x);
    return begin() + __n;
  }



  template <class _Integer>
  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
                          const __true_type&) {
    _M_fill_insert(__pos, (size_type) __n, (bool) __x);
  }

  template <class _InputIterator>
  void _M_insert_dispatch(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          const __false_type&) {
    _M_insert_range(__pos, __first, __last, typename iterator_traits< _InputIterator >::iterator_category());
  }


  template <class _InputIterator>
  void insert(iterator __position,
              _InputIterator __first, _InputIterator __last) {
    typedef typename _Is_integer<_InputIterator>::_Integral _Is_Integral;
    _M_insert_dispatch(__position, __first, __last, _Is_Integral());
  }
# 727 "c:/marmalade/7.3/s3e/h/std/c++/stl/_bvector.h"
  void _M_fill_insert(iterator __position, size_type __n, bool __x) {
    if (__n == 0) return;
    if (capacity() - size() >= __n) {
      __copy_backward(__position, end(), this->_M_finish + difference_type(__n), random_access_iterator_tag(), (difference_type*)0 );
      fill(__position, __position + difference_type(__n), __x);
      this->_M_finish += difference_type(__n);
    }
    else {
      size_type __len = size() + (max)(size(), __n);
      unsigned int* __q = this->_M_bit_alloc(__len);
      iterator __i = copy(begin(), __position, iterator(__q, 0));
      fill_n(__i, __n, __x);
      this->_M_finish = copy(__position, end(), __i + difference_type(__n));
      this->_M_deallocate();
      this->_M_end_of_storage._M_data = __q + (__len + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int)));
      this->_M_start = iterator(__q, 0);
    }
  }

  void insert(iterator __position, size_type __n, bool __x) {
    _M_fill_insert(__position, __n, __x);
  }

  void pop_back() {
      --this->_M_finish;
  }
  iterator erase(iterator __position) {
    if (__position + 1 != end())
      copy(__position + 1, end(), __position);
      --this->_M_finish;
    return __position;
  }
  iterator erase(iterator __first, iterator __last) {
    this->_M_finish = copy(__last, end(), __first);
    return __first;
  }
  void resize(size_type __new_size, bool __x = bool()) {
    if (__new_size < size())
      erase(begin() + difference_type(__new_size), end());
    else
      insert(end(), __new_size - size(), __x);
  }
  void flip() {
    for (unsigned int* __p = this->_M_start._M_p; __p != this->_M_end_of_storage._M_data; ++__p)
      *__p = ~*__p;
  }

  void clear() { erase(begin(), end()); }
};
# 789 "c:/marmalade/7.3/s3e/h/std/c++/stl/_bvector.h"
  typedef vector <bool, allocator<bool> > bit_vector;


}
# 576 "c:/marmalade/7.3/s3e/h/std/c++/stl/_vector.h" 2
# 41 "c:/marmalade/7.3/s3e/h/std/c++/vector" 2







# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/7.3/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/7.3/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/7.3/s3e/h/std/c++/stl/_epilog.h" 2
# 49 "c:/marmalade/7.3/s3e/h/std/c++/vector" 2
# 28 "c:/marmalade/7.3/modules/iw2dscenegraphcore/h/Iw2DSceneGraphCore.h" 2
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeom.h" 1
       
# 21 "c:/marmalade/7.3/modules/iwgeom/h/IwGeom.h"
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h" 1
       
# 18 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
# 1 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h" 1
# 16 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h"
# 1 "c:/marmalade/7.3/s3e/h/s3eDebug.h" 1
# 15 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
# 1 "c:/marmalade/7.3/s3e/h/s3eTypes.h" 1
# 16 "c:/marmalade/7.3/s3e/h/s3eDebug.h" 2
# 55 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
typedef enum s3eDebugProperty
{



    S3E_DEBUG_TRACE_ENABLED = 0,





    S3E_DEBUG_TRACE_TO_FILE = 1,




    S3E_DEBUG_ASSERT_ENABLED = 2,





    S3E_DEBUG_AVAILABLE = 3,




    S3E_DEBUG_FONT_SCALE = 4,




    S3E_DEBUG_FONT_WIDTH = 5,




    S3E_DEBUG_FONT_HEIGHT = 6

} s3eDebugProperty;
# 112 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
extern "C" int32 s3eDebugGetInt(s3eDebugProperty property);
# 130 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
extern "C" s3eResult s3eDebugSetInt(s3eDebugProperty property, int32 value);







typedef enum s3eDebugCallback
{
# 154 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
    S3E_DEBUG_ASSERT = 0,
# 169 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
    S3E_DEBUG_ERROR = 1,

    S3E_DEBUG_CALLBACK_MAX
} s3eDebugCallback;
# 197 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
extern "C" s3eResult s3eDebugRegister(s3eDebugCallback cbid, s3eCallback fn, void* userData);
# 214 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
extern "C" s3eResult s3eDebugUnRegister(s3eDebugCallback cbid, s3eCallback fn);
# 223 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
typedef enum s3eDebugError
{
    S3E_DEBUG_ERR_NONE = 0,
    S3E_DEBUG_ERR_PARAM = 1,
    S3E_DEBUG_ERR_TOO_MANY = 2,
    S3E_DEBUG_ERR_ALREADY_REG = 3,
    S3E_DEBUG_ERR_NOT_FOUND = 4
} s3eDebugError;
# 243 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
extern "C" s3eDebugError s3eDebugGetError();
# 256 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
extern "C" const char* s3eDebugGetErrorString();

typedef enum s3eErrorShowResult
{

    S3E_ERROR_SHOW_CONTINUE = 0,

    S3E_ERROR_SHOW_STOP = 1,

    S3E_ERROR_SHOW_IGNORE = 2,





    S3E_ERROR_SHOW_AGAIN = 3
} s3eErrorShowResult;




typedef enum s3eMessageType
{





    S3E_MESSAGE_CONTINUE = 0,





    S3E_MESSAGE_CONTINUE_STOP = 1,






    S3E_MESSAGE_CONTINUE_STOP_IGNORE = 2
} s3eMessageType;







extern "C" s3eBool s3eDebugIsDebuggerPresent();
# 322 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
extern "C" void s3eDebugOutputString(const char* pStr);
# 334 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
extern "C" s3eErrorShowResult s3eDebugErrorShow(s3eMessageType type, const char* string);






extern "C" s3eErrorShowResult s3eDebugErrorPrintf(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;
# 359 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
extern "C" s3eErrorShowResult s3eDebugAssertShow(s3eMessageType type, const char* string);
# 372 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
extern "C" void s3eDebugTraceLine(const char* string);






extern "C" int s3eDebugTracePrintf(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;






extern "C" void s3eDebugTraceClearFile();
# 399 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
extern "C" void s3eDebugTraceFlush();
# 424 "c:/marmalade/7.3/s3e/h/s3eDebug.h"
extern "C" void s3eDebugPrint(int x, int y, const char* string, s3eBool wrap);






extern "C" void s3eDebugPrintf(int x, int y, s3eBool wrap, const char* fmt, ...)

__attribute__((format(printf, 4, 5)))

;







extern "C" s3eBool s3eDebugTraceChannelSwitch(const char* channel, s3eBool new_state);
# 17 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h" 2
# 1 "c:/marmalade/7.3/s3e/h/s3eDevice.h" 1
# 56 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
typedef enum s3eDeviceError
{
    S3E_DEVICE_ERR_NONE = 0,
    S3E_DEVICE_ERR_PARAM = 1,
    S3E_DEVICE_ERR_TOO_MANY = 2,
    S3E_DEVICE_ERR_ALREADY_REG = 3,
    S3E_DEVICE_ERR_NOT_FOUND = 4,
    S3E_DEVICE_ERR_UNAVAIL = 5,
    S3E_DEVICE_ERR_DEVICE = 6,
    S3E_DEVICE_ERR_UNSUPPORTED = 7,
    S3E_DEVICE_ERR_MEM = 8,
    S3E_DEVICE_ERR_GENERIC = 9,
    S3E_DEVICE_ERR_INVALID_DRIVE = 10,
    S3E_DEVICE_ERR_INVALID_PATH = 11
} s3eDeviceError;
# 83 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
extern "C" s3eDeviceError s3eDeviceGetError();
# 97 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
extern "C" const char* s3eDeviceGetErrorString();
# 106 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
typedef enum s3eDeviceFPUType
{
    S3E_DEVICE_FPU_NONE = 0,
    S3E_DEVICE_FPU_VFP = 1,
    S3E_DEVICE_FPU_VFPV3 = 2,
    S3E_DEVICE_FPU_NEON = 3
} s3eDeviceFPUType;






typedef enum s3eDeviceProperty
{







    S3E_DEVICE_OS = 0,





    S3E_DEVICE_CLASS = 1,
# 150 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_ID = 2,
# 164 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_PHONE_NUMBER = 3,





    S3E_DEVICE_LANGUAGE = 4,






    S3E_DEVICE_STATE = 5,
# 186 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_FREE_RAM = 6,
# 195 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_TOTAL_RAM = 7,
# 209 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_ARCHITECTURE = 8,
# 226 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_S3E_VERSION = 9,
# 236 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_BATTERY_LEVEL = 10,






    S3E_DEVICE_LEFT_SOFTKEY_IS_BACK = 11,
# 254 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_MAINS_POWER = 12,
# 263 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_OS_VERSION = 13,
# 276 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_CHIPSET = 14,
# 285 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_EXIT_CODE = 15,
# 298 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_FPU = 16,





    S3E_DEVICE_BACK_SOFTKEY_POSITION = 17,





    S3E_DEVICE_ADVANCE_SOFTKEY_POSITION = 18,
# 321 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_SDK_VERSION = 19,
# 330 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_LOCALE = 20,





    S3E_DEVICE_NAME = 21,







    S3E_DEVICE_SUPPORTS_SIGNAL_HANDLING = 22,







    S3E_DEVICE_EXIT_SIGNAL = 23,
# 367 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_PROXIMITY = 24,
# 399 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_UNIQUE_ID = 25,
# 417 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_IMSI = 26,
# 428 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_SILENT_MODE = 27,




    S3E_DEVICE_NUM_CPU_CORES = 28,
# 443 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_MEM_TOTAL = 29,
# 463 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_MEM_FREE = 30,





    S3E_DEVICE_TIMEZONE = 31,
# 482 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_3D_MODE = 32,
# 492 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_PROCESS_ID = 33,





    S3E_DEVICE_SUPPORTS_SUSPEND_RESUME = 34,





    S3E_DEVICE_DX_FEATURE_LEVEL = 35,




    S3E_DEVICE_TIMEZONE_STD = 36,




    S3E_DEVICE_TIMEZONE_DST = 37

} s3eDeviceProperty;






typedef enum s3eDeviceLicPlatID
{
    S3E_LICPLAT_ID_NONE = 0x0000,


    S3E_LICPLAT_ID_WINDOWS = 0x0001,

    S3E_LICPLAT_LINUX = 0x0002,

    S3E_LICPLAT_OSX = 0x0004,


    S3E_LICPLAT_IPHONE = 0x0008,

    S3E_LICPLAT_ANDROID = 0x0010,

    S3E_LICPLAT_QNX = 0x0020,

    S3E_LICPLAT_ROKU = 0x0040,

    S3E_LICPLAT_WP8 = 0x0080,

    S3E_LICPLAT_TIZEN = 0x0100,

    S3E_LICPLAT_WS8 = 0x0200,

    S3E_LICPLAT_UNSET = 0x10000000,
    S3E_LICPLAT_ALL = 0x7FFFFFFF
} s3eDeviceLicPlatID;







typedef enum s3eDeviceOSID
{
    S3E_OS_ID_NONE = 0,

    S3E_OS_ID_WINDOWS = 3,

    S3E_OS_ID_LINUX = 5,

    S3E_OS_ID_ARM_SEMIH = 8,

    S3E_OS_ID_OSX = 13,

    S3E_OS_ID_IPHONE = 14,

    S3E_OS_ID_ANDROID = 19,

    S3E_OS_ID_QNX = 24,

    S3E_OS_ID_ROKU = 25,

    S3E_OS_ID_WP8 = 26,

    S3E_OS_ID_TIZEN = 27,

    S3E_OS_ID_WS8 = 28,

    S3E_OS_ID_WS81 = 29,

    S3E_OS_ID_WP81 = 30,

    S3E_OS_ID_LAST = 31,







    S3E_OS_ID_SYMBIAN = 1,

    S3E_OS_ID_BREW = 2,

    S3E_OS_ID_WINMOBILE = 4,

    S3E_OS_ID_WIPI = 6,

    S3E_OS_ID_NDS = 7,

    S3E_OS_ID_NUCLEUS = 9,

    S3E_OS_ID_NGI = 10,

    S3E_OS_ID_WINCE = 11,

    S3E_OS_ID_SHARPEMP = 12,

    S3E_OS_ID_UIQ = 15,

    S3E_OS_ID_PS3 = 16,

    S3E_OS_ID_X360 = 17,

    S3E_OS_ID_WEBOS = 20,

    S3E_OS_ID_PSP = 21,

    S3E_OS_ID_WII = 22,

    S3E_OS_ID_MEEGO = 23,

} s3eDeviceOSID;







typedef enum s3eDeviceClassID
{
    S3E_DEVICE_CLASS_UNKNOWN = 0,

    S3E_DEVICE_CLASS_WINDOWS_GENERIC = 3000,
    S3E_DEVICE_CLASS_WINDOWS_PHONE = 3010,
    S3E_DEVICE_CLASS_WINDOWS_STORE = 3020,
    S3E_DEVICE_CLASS_LINUX_GENERIC = 5000,
    S3E_DEVICE_CLASS_LINUX_DESKTOP = 5001,
    S3E_DEVICE_CLASS_LINUX_EMBED = 5002,
    S3E_DEVICE_CLASS_ARM_SEMIH_GENERIC = 8000,
    S3E_DEVICE_CLASS_OSX_DESKTOP = 11000,
    S3E_DEVICE_CLASS_IPHONE = 12000,
    S3E_DEVICE_CLASS_ANDROID_GENERIC = 16000,
    S3E_DEVICE_CLASS_QNX = 19000,
    S3E_DEVICE_CLASS_TIZEN_GENERIC = 20000,

    S3E_DEVICE_CLASS_SYMBIAN_GENERIC = 1000,
    S3E_DEVICE_CLASS_SYMBIAN_SERIES60 = 1001,
    S3E_DEVICE_CLASS_SYMBIAN_SERIES60_EMULATOR = 1002,
    S3E_DEVICE_CLASS_SYMBIAN_UIQ = 1003,
    S3E_DEVICE_CLASS_SYMBIAN_UIQ_EMULATOR = 1004,
    S3E_DEVICE_CLASS_BREW_GENERIC = 2000,
    S3E_DEVICE_CLASS_BREW_QCIF_3G = 2001,
    S3E_DEVICE_CLASS_BREW_QCIF_25G = 2002,
    S3E_DEVICE_CLASS_BREW_SQCIF_25G = 2003,
    S3E_DEVICE_CLASS_BREW_QVGA_3G = 2004,
    S3E_DEVICE_CLASS_WINCE_GENERIC = 4000,
    S3E_DEVICE_CLASS_WINMOBILE_SP = 4001,
    S3E_DEVICE_CLASS_WINMOBILE_PPC = 4002,
    S3E_DEVICE_CLASS_WIPI_GENERIC = 6000,
    S3E_DEVICE_CLASS_NDS_GENERIC = 7000,
    S3E_DEVICE_CLASS_NDS_NDSI = 7001,
    S3E_DEVICE_CLASS_NUCLEUS_GENERIC = 9000,
    S3E_DEVICE_CLASS_NGI_GENERIC = 10000,
    S3E_DEVICE_CLASS_PS3 = 13000,
    S3E_DEVICE_CLASS_X360 = 14000,
    S3E_DEVICE_CLASS_BADA_GENERIC = 15000,
    S3E_DEVICE_CLASS_PSP = 17000,
    S3E_DEVICE_CLASS_WII = 18000

} s3eDeviceClassID;




typedef enum s3eDeviceLanguage
{
    S3E_DEVICE_LANGUAGE_UNKNOWN = 0,
    S3E_DEVICE_LANGUAGE_ENGLISH = 1,
    S3E_DEVICE_LANGUAGE_FRENCH = 2,
    S3E_DEVICE_LANGUAGE_GERMAN = 3,
    S3E_DEVICE_LANGUAGE_SPANISH = 4,
    S3E_DEVICE_LANGUAGE_ITALIAN = 5,
    S3E_DEVICE_LANGUAGE_PORTUGUESE = 6,
    S3E_DEVICE_LANGUAGE_DUTCH = 7,
    S3E_DEVICE_LANGUAGE_TURKISH = 8,
    S3E_DEVICE_LANGUAGE_CROATIAN = 9,
    S3E_DEVICE_LANGUAGE_CZECH = 10,
    S3E_DEVICE_LANGUAGE_DANISH = 11,
    S3E_DEVICE_LANGUAGE_FINNISH = 12,
    S3E_DEVICE_LANGUAGE_HUNGARIAN = 13,
    S3E_DEVICE_LANGUAGE_NORWEGIAN = 14,
    S3E_DEVICE_LANGUAGE_POLISH = 15,
    S3E_DEVICE_LANGUAGE_RUSSIAN = 16,
    S3E_DEVICE_LANGUAGE_SERBIAN = 17,
    S3E_DEVICE_LANGUAGE_SLOVAK = 18,
    S3E_DEVICE_LANGUAGE_SLOVENIAN = 19,
    S3E_DEVICE_LANGUAGE_SWEDISH = 20,
    S3E_DEVICE_LANGUAGE_UKRAINIAN = 21,
    S3E_DEVICE_LANGUAGE_GREEK = 22,
    S3E_DEVICE_LANGUAGE_JAPANESE = 23,
    S3E_DEVICE_LANGUAGE_SIMPL_CHINESE = 24,
    S3E_DEVICE_LANGUAGE_TRAD_CHINESE = 25,
    S3E_DEVICE_LANGUAGE_KOREAN = 26,
    S3E_DEVICE_LANGUAGE_ICELANDIC = 27,
    S3E_DEVICE_LANGUAGE_FLEMISH = 28,
    S3E_DEVICE_LANGUAGE_THAI = 29,
    S3E_DEVICE_LANGUAGE_AFRIKAANS = 30,
    S3E_DEVICE_LANGUAGE_ALBANIAN = 31,
    S3E_DEVICE_LANGUAGE_AMHARIC = 32,
    S3E_DEVICE_LANGUAGE_ARABIC = 33,
    S3E_DEVICE_LANGUAGE_ARMENIAN = 34,
    S3E_DEVICE_LANGUAGE_AZERBAIJANI = 35,
    S3E_DEVICE_LANGUAGE_TAGALOG = 36,
    S3E_DEVICE_LANGUAGE_BELARUSSIAN = 37,
    S3E_DEVICE_LANGUAGE_BENGALI = 38,
    S3E_DEVICE_LANGUAGE_BULGARIAN = 39,
    S3E_DEVICE_LANGUAGE_BURMESE = 40,
    S3E_DEVICE_LANGUAGE_CATALAN = 41,
    S3E_DEVICE_LANGUAGE_ESTONIAN = 42,
    S3E_DEVICE_LANGUAGE_FARSI = 43,
    S3E_DEVICE_LANGUAGE_GAELIC = 44,
    S3E_DEVICE_LANGUAGE_GEORGIAN = 45,
    S3E_DEVICE_LANGUAGE_GUJARATI = 46,
    S3E_DEVICE_LANGUAGE_HEBREW = 47,
    S3E_DEVICE_LANGUAGE_HINDI = 48,
    S3E_DEVICE_LANGUAGE_INDONESIAN = 49,
    S3E_DEVICE_LANGUAGE_IRISH = 50,
    S3E_DEVICE_LANGUAGE_KANNADA = 51,
    S3E_DEVICE_LANGUAGE_KAZAKH = 52,
    S3E_DEVICE_LANGUAGE_KHMER = 53,
    S3E_DEVICE_LANGUAGE_LAO = 54,
    S3E_DEVICE_LANGUAGE_LATVIAN = 55,
    S3E_DEVICE_LANGUAGE_LITHUANIAN = 56,
    S3E_DEVICE_LANGUAGE_MACEDONIAN = 57,
    S3E_DEVICE_LANGUAGE_MALAY = 58,
    S3E_DEVICE_LANGUAGE_MALAYALAM = 59,
    S3E_DEVICE_LANGUAGE_MARATHI = 60,
    S3E_DEVICE_LANGUAGE_MOLDOVIAN = 61,
    S3E_DEVICE_LANGUAGE_MONGOLIAN = 62,
    S3E_DEVICE_LANGUAGE_PUNJABI = 63,
    S3E_DEVICE_LANGUAGE_ROMANIAN = 64,
    S3E_DEVICE_LANGUAGE_SINHALESE = 65,
    S3E_DEVICE_LANGUAGE_SOMALI = 66,
    S3E_DEVICE_LANGUAGE_SWAHILI = 67,
    S3E_DEVICE_LANGUAGE_TAJIK = 68,
    S3E_DEVICE_LANGUAGE_TAMIL = 69,
    S3E_DEVICE_LANGUAGE_TELUGU = 70,
    S3E_DEVICE_LANGUAGE_TIBETAN = 71,
    S3E_DEVICE_LANGUAGE_TIGRINYA = 72,
    S3E_DEVICE_LANGUAGE_TURKMEN = 73,
    S3E_DEVICE_LANGUAGE_URDU = 74,
    S3E_DEVICE_LANGUAGE_UZBEK = 75,
    S3E_DEVICE_LANGUAGE_VIETNAMESE = 76,
    S3E_DEVICE_LANGUAGE_WELSH = 77,
    S3E_DEVICE_LANGUAGE_ZULU = 78
} s3eDeviceLanguage;
# 777 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
typedef enum s3eDeviceArchitecture
{
    S3E_DEVICE_ARCHITECTURE_ARM4T = 0,
    S3E_DEVICE_ARCHITECTURE_ARM4 = 1,
    S3E_DEVICE_ARCHITECTURE_ARM5T = 2,
    S3E_DEVICE_ARCHITECTURE_ARM5TE = 3,
    S3E_DEVICE_ARCHITECTURE_ARM5TEJ = 4,
    S3E_DEVICE_ARCHITECTURE_ARM6 = 5,
    S3E_DEVICE_ARCHITECTURE_ARM6K = 6,
    S3E_DEVICE_ARCHITECTURE_ARM6T2 = 7,
    S3E_DEVICE_ARCHITECTURE_ARM6Z = 8,
    S3E_DEVICE_ARCHITECTURE_ARM7A = 12,
    S3E_DEVICE_ARCHITECTURE_X86 = 9,
    S3E_DEVICE_ARCHITECTURE_PPC = 10,
    S3E_DEVICE_ARCHITECTURE_AMD64 = 11,
    S3E_DEVICE_ARCHITECTURE_MIPS = 13,
    S3E_DEVICE_ARCHITECTURE_MAX = 14
} s3eDeviceArchitecture;
# 803 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
typedef enum s3eDeviceSoftKeyPosition
{
    S3E_DEVICE_SOFTKEY_BOTTOM_LEFT = 0,
    S3E_DEVICE_SOFTKEY_BOTTOM_RIGHT = 1,
    S3E_DEVICE_SOFTKEY_TOP_RIGHT = 2,
    S3E_DEVICE_SOFTKEY_TOP_LEFT = 3
} s3eDeviceSoftKeyPosition;
# 844 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
extern "C" const char* s3eDeviceGetString(s3eDeviceProperty property);
# 879 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
extern "C" int32 s3eDeviceGetInt(s3eDeviceProperty property);
# 899 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceSetInt(s3eDeviceProperty property, int32 value);
# 927 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
extern "C" int64 s3eDeviceYield(int32 ms =0);
# 949 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceUnYield();
# 977 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceYieldUntilEvent(int32 ms =0x7fffffffL);
# 1012 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceExecPushNext(const char* filename, const char* config_prepend =__null, const char* config_append =__null);
# 1028 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceExit(int code =0) __attribute__ ((noreturn));






typedef enum s3eDeviceState
{




    S3E_DEVICE_STATE_PAUSED = 3,





    S3E_DEVICE_STATE_EXITING = 4,




    S3E_DEVICE_STATE_RUNNING = 5
} s3eDeviceState;
# 1065 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
typedef enum s3eDeviceCallback
{
# 1078 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_PAUSE = 0,
# 1090 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_UNPAUSE = 1,
# 1102 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_EXIT = 2,
# 1118 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_VOL_UP = 17,
# 1134 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_VOL_DOWN = 18,
# 1152 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_MAINS_POWER_CHANGED = 20,
# 1164 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_BACKGROUND = 22,
# 1176 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_FOREGROUND = 23,
# 1193 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_NETWORK_ONLINE = 24,
# 1210 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_NETWORK_OFFLINE = 25,
# 1226 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_SIMULATOR_RESTART = 26,
# 1243 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_APPLICATION_ACTIVE = 27,
# 1260 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_APPLICATION_INACTIVE = 28,
# 1277 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_APPLICATION_FULLSCREEN = 29,
# 1294 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_APPLICATION_THUMBNAIL = 30,
# 1311 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    S3E_DEVICE_APPLICATION_INVISIBLE = 31,

    S3E_DEVICE_CALLBACK_MAX
} s3eDeviceCallback;
# 1332 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
typedef struct s3eDeviceVolChangeInfo
{





    s3eBool m_VolUp;
# 1357 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
    s3eBool m_OverrideDefaultBehaviour;
} s3eDeviceVolChangeInfo;





typedef struct s3eDeviceStateChangeInfo
{



    int32 m_State;
} s3eDeviceStateChangeInfo;
# 1392 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceRegister(s3eDeviceCallback cbid, s3eCallback fn, void* userdata);
# 1412 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceUnRegister(s3eDeviceCallback cbid, s3eCallback fn);







extern "C" void s3eDeviceRequestQuit();
# 1431 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
extern "C" s3eBool s3eDeviceCheckQuitRequest();
# 1441 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
extern "C" s3eBool s3eDeviceCheckPauseRequest();
# 1455 "c:/marmalade/7.3/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceBacklightOn();


extern "C" s3eBool s3eDeviceNetworkCheckStart();


extern "C" s3eBool s3eDeviceNetworkCheckStop();


extern "C" void s3eDeviceLoaderCallStart(s3eBool lock, void* function);


extern "C" void s3eDeviceLoaderCallDone(s3eBool lock, void* function);
# 18 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h" 2
# 1 "c:/marmalade/7.3/modules/iwutil/h/IwCore.h" 1
# 19 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h" 2



# 1 "c:/marmalade/7.3/s3e/h/std/stdio.h" 1
# 23 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h" 2
# 1 "c:/marmalade/7.3/s3e/h/std/stdlib.h" 1
# 24 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h" 2
# 51 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h"
typedef void(*IwAssertTextCallback)(char* pBuffer);

extern "C" {

typedef s3eErrorShowResult(*IwAssertCallback)(const char* channel, const char* pExpr, const char* pFilename, int32 line, const char* message);
typedef s3eErrorShowResult(*IwErrorCallback)(const char* message);
# 65 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h"
 s3eBool IwDebugTraceIsChannelOn(const char* channel, s3eBool default_on);
# 74 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h"
void IwDebugTraceDisable(s3eBool disable);




 void IwDebugTraceSetTraceChannel(const char* channel);
# 91 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h"
 s3eBool IwDebugTraceChannelSwitch(const char* channel, s3eBool new_state);
# 101 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h"
 void IwDebugTraceLinePrintf(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;






 void IwDebugTraceLineVPrintf(const char* fmt, va_list args);


 void IwDebugAssertSetUID(uint32 n);







 s3eBool IwDebugAssertIsChannelOn(const char* channel);







 void IwDebugClearConfigCache();
# 141 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h"
 void IwDebugAssertSetMessage(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;
# 156 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h"
 void IwDebugAssertSetSolution(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;







 s3eErrorShowResult IwDebugAssertShow(const char* pExpr, const char* pFilename, int32 line, uint8 ignorable);






 IwAssertTextCallback IwAssertRegisterTextCallback(IwAssertTextCallback fn);






 IwAssertCallback IwAssertRegisterCallback(IwAssertCallback fn);
# 192 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h"
 s3eErrorShowResult IwDebugErrorShow(const char* Args, ...)

__attribute__((format(printf, 1, 2)))

;






 IwErrorCallback IwDebugErrorRegisterCallback(IwErrorCallback fn);

}
# 347 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h"
    static inline void IwDebugExit()
    {
        abort();
    }
# 581 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo" 1
# 21 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_prolog.h" 1
# 16 "c:/marmalade/7.3/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/7.3/s3e/h/std/c++/stl/_prolog.h" 2
# 22 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo" 2





# 1 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo.h" 1
# 20 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/exception" 1
# 75 "c:/marmalade/7.3/s3e/h/std/c++/exception"
namespace _STL {


using __std_alias::exception;
using __std_alias::bad_exception;
# 106 "c:/marmalade/7.3/s3e/h/std/c++/exception"
}
# 21 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo.h" 2
namespace std
{
    using _STL::exception;
}
# 1 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo_gcc" 1
# 39 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo_gcc"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/exception" 1
# 75 "c:/marmalade/7.3/s3e/h/std/c++/exception"
namespace _STL {


using __std_alias::exception;
using __std_alias::bad_exception;
# 106 "c:/marmalade/7.3/s3e/h/std/c++/exception"
}
# 40 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo_gcc" 2

#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 85 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo_gcc"
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);

  protected:
    const char *__name;

  protected:
    explicit type_info(const char *__n): __name(__n) { }

  public:



    const char* name() const;


    bool before(const type_info& __arg) const;



    bool operator==(const type_info& __arg) const;
# 138 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo_gcc"
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


  public:
# 165 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo_gcc"
    virtual bool __is_pointer_p() const;

    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  };






  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }


    virtual ~bad_cast() throw();

    virtual const char* what() const throw();
  };


  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }


    virtual ~bad_typeid() throw();

    virtual const char* what() const throw();
  };
}

#pragma GCC visibility pop

}
# 26 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo.h" 2
# 28 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo" 2
# 43 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo"
namespace _STL {



using __std_alias::type_info;



using __std_alias::bad_typeid;
# 61 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo"
using __std_alias::bad_cast;


}
# 78 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/7.3/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/7.3/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/7.3/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/7.3/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/7.3/s3e/h/std/c++/stl/_epilog.h" 2
# 79 "c:/marmalade/7.3/s3e/h/std/c++/typeinfo" 2
# 582 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h" 2


template <class _To, class _From>
_To IwSafeCast(_From from)
{

    if (from != __null && dynamic_cast<_To>(from) == __null)
        {
            const _STL::type_info& srctype = typeid(*from);
            const char* src = srctype.name();
            const char* target = typeid(_To).name();
            do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("CORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Mis-casting pointer: 0x%p is a pointer to type '%s', which is not derived from '%s'", from, src, target); switch (IwDebugAssertShow("false",
 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h"
# 593 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h"
            ,
 594
# 593 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h"
            , (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0)
                               ;
    }

    return static_cast <_To> (from);
}
# 19 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h" 2
# 1 "c:/marmalade/7.3/modules/iwutil/h/IwDivide.h" 1
# 78 "c:/marmalade/7.3/modules/iwutil/h/IwDivide.h"
static inline uint64 i3d_uldiv_split(uint32 toplo, uint32 tophi, uint32 bottom)
{
    unsigned accumhi = 0;
    unsigned accumlo = 0;


    int i=31;




    if(tophi & 0xffff0000)
        i -= 16;
    if(tophi==0)
        i=0;

    for (; i>=0; i--)
    {
        accumhi = accumhi << 1;

        if ((tophi>>(i)) >= (bottom))
        {
            accumhi++;


            tophi = tophi - (bottom<<i);
        }
    }
# 125 "c:/marmalade/7.3/modules/iwutil/h/IwDivide.h"
    if (tophi==0) goto fast_bit32;

    accumlo = accumlo << 1; if ((toplo>>31)+(tophi<<(32-31)) >= (bottom) || (tophi>>31)!=0) { accumlo++; if ((bottom<<31) > toplo) tophi--; toplo = toplo - (bottom<<31); tophi = tophi - (bottom>>(32-31)); if (!tophi) goto fast_bit31; }
    accumlo = accumlo << 1; if ((toplo>>30)+(tophi<<(32-30)) >= (bottom) || (tophi>>30)!=0) { accumlo++; if ((bottom<<30) > toplo) tophi--; toplo = toplo - (bottom<<30); tophi = tophi - (bottom>>(32-30)); if (!tophi) goto fast_bit30; }
    accumlo = accumlo << 1; if ((toplo>>29)+(tophi<<(32-29)) >= (bottom) || (tophi>>29)!=0) { accumlo++; if ((bottom<<29) > toplo) tophi--; toplo = toplo - (bottom<<29); tophi = tophi - (bottom>>(32-29)); if (!tophi) goto fast_bit29; }
    accumlo = accumlo << 1; if ((toplo>>28)+(tophi<<(32-28)) >= (bottom) || (tophi>>28)!=0) { accumlo++; if ((bottom<<28) > toplo) tophi--; toplo = toplo - (bottom<<28); tophi = tophi - (bottom>>(32-28)); if (!tophi) goto fast_bit28; }
    accumlo = accumlo << 1; if ((toplo>>27)+(tophi<<(32-27)) >= (bottom) || (tophi>>27)!=0) { accumlo++; if ((bottom<<27) > toplo) tophi--; toplo = toplo - (bottom<<27); tophi = tophi - (bottom>>(32-27)); if (!tophi) goto fast_bit27; }
    accumlo = accumlo << 1; if ((toplo>>26)+(tophi<<(32-26)) >= (bottom) || (tophi>>26)!=0) { accumlo++; if ((bottom<<26) > toplo) tophi--; toplo = toplo - (bottom<<26); tophi = tophi - (bottom>>(32-26)); if (!tophi) goto fast_bit26; }
    accumlo = accumlo << 1; if ((toplo>>25)+(tophi<<(32-25)) >= (bottom) || (tophi>>25)!=0) { accumlo++; if ((bottom<<25) > toplo) tophi--; toplo = toplo - (bottom<<25); tophi = tophi - (bottom>>(32-25)); if (!tophi) goto fast_bit25; }
    accumlo = accumlo << 1; if ((toplo>>24)+(tophi<<(32-24)) >= (bottom) || (tophi>>24)!=0) { accumlo++; if ((bottom<<24) > toplo) tophi--; toplo = toplo - (bottom<<24); tophi = tophi - (bottom>>(32-24)); if (!tophi) goto fast_bit24; }
    accumlo = accumlo << 1; if ((toplo>>23)+(tophi<<(32-23)) >= (bottom) || (tophi>>23)!=0) { accumlo++; if ((bottom<<23) > toplo) tophi--; toplo = toplo - (bottom<<23); tophi = tophi - (bottom>>(32-23)); if (!tophi) goto fast_bit23; }
    accumlo = accumlo << 1; if ((toplo>>22)+(tophi<<(32-22)) >= (bottom) || (tophi>>22)!=0) { accumlo++; if ((bottom<<22) > toplo) tophi--; toplo = toplo - (bottom<<22); tophi = tophi - (bottom>>(32-22)); if (!tophi) goto fast_bit22; }
    accumlo = accumlo << 1; if ((toplo>>21)+(tophi<<(32-21)) >= (bottom) || (tophi>>21)!=0) { accumlo++; if ((bottom<<21) > toplo) tophi--; toplo = toplo - (bottom<<21); tophi = tophi - (bottom>>(32-21)); if (!tophi) goto fast_bit21; }
    accumlo = accumlo << 1; if ((toplo>>20)+(tophi<<(32-20)) >= (bottom) || (tophi>>20)!=0) { accumlo++; if ((bottom<<20) > toplo) tophi--; toplo = toplo - (bottom<<20); tophi = tophi - (bottom>>(32-20)); if (!tophi) goto fast_bit20; }
    accumlo = accumlo << 1; if ((toplo>>19)+(tophi<<(32-19)) >= (bottom) || (tophi>>19)!=0) { accumlo++; if ((bottom<<19) > toplo) tophi--; toplo = toplo - (bottom<<19); tophi = tophi - (bottom>>(32-19)); if (!tophi) goto fast_bit19; }
    accumlo = accumlo << 1; if ((toplo>>18)+(tophi<<(32-18)) >= (bottom) || (tophi>>18)!=0) { accumlo++; if ((bottom<<18) > toplo) tophi--; toplo = toplo - (bottom<<18); tophi = tophi - (bottom>>(32-18)); if (!tophi) goto fast_bit18; }
    accumlo = accumlo << 1; if ((toplo>>17)+(tophi<<(32-17)) >= (bottom) || (tophi>>17)!=0) { accumlo++; if ((bottom<<17) > toplo) tophi--; toplo = toplo - (bottom<<17); tophi = tophi - (bottom>>(32-17)); if (!tophi) goto fast_bit17; }
    accumlo = accumlo << 1; if ((toplo>>16)+(tophi<<(32-16)) >= (bottom) || (tophi>>16)!=0) { accumlo++; if ((bottom<<16) > toplo) tophi--; toplo = toplo - (bottom<<16); tophi = tophi - (bottom>>(32-16)); if (!tophi) goto fast_bit16; }
    accumlo = accumlo << 1; if ((toplo>>15)+(tophi<<(32-15)) >= (bottom) || (tophi>>15)!=0) { accumlo++; if ((bottom<<15) > toplo) tophi--; toplo = toplo - (bottom<<15); tophi = tophi - (bottom>>(32-15)); if (!tophi) goto fast_bit15; }
    accumlo = accumlo << 1; if ((toplo>>14)+(tophi<<(32-14)) >= (bottom) || (tophi>>14)!=0) { accumlo++; if ((bottom<<14) > toplo) tophi--; toplo = toplo - (bottom<<14); tophi = tophi - (bottom>>(32-14)); if (!tophi) goto fast_bit14; }
    accumlo = accumlo << 1; if ((toplo>>13)+(tophi<<(32-13)) >= (bottom) || (tophi>>13)!=0) { accumlo++; if ((bottom<<13) > toplo) tophi--; toplo = toplo - (bottom<<13); tophi = tophi - (bottom>>(32-13)); if (!tophi) goto fast_bit13; }
    accumlo = accumlo << 1; if ((toplo>>12)+(tophi<<(32-12)) >= (bottom) || (tophi>>12)!=0) { accumlo++; if ((bottom<<12) > toplo) tophi--; toplo = toplo - (bottom<<12); tophi = tophi - (bottom>>(32-12)); if (!tophi) goto fast_bit12; }
    accumlo = accumlo << 1; if ((toplo>>11)+(tophi<<(32-11)) >= (bottom) || (tophi>>11)!=0) { accumlo++; if ((bottom<<11) > toplo) tophi--; toplo = toplo - (bottom<<11); tophi = tophi - (bottom>>(32-11)); if (!tophi) goto fast_bit11; }
    accumlo = accumlo << 1; if ((toplo>>10)+(tophi<<(32-10)) >= (bottom) || (tophi>>10)!=0) { accumlo++; if ((bottom<<10) > toplo) tophi--; toplo = toplo - (bottom<<10); tophi = tophi - (bottom>>(32-10)); if (!tophi) goto fast_bit10; }
    accumlo = accumlo << 1; if ((toplo>>9)+(tophi<<(32-9)) >= (bottom) || (tophi>>9)!=0) { accumlo++; if ((bottom<<9) > toplo) tophi--; toplo = toplo - (bottom<<9); tophi = tophi - (bottom>>(32-9)); if (!tophi) goto fast_bit9; }
    accumlo = accumlo << 1; if ((toplo>>8)+(tophi<<(32-8)) >= (bottom) || (tophi>>8)!=0) { accumlo++; if ((bottom<<8) > toplo) tophi--; toplo = toplo - (bottom<<8); tophi = tophi - (bottom>>(32-8)); if (!tophi) goto fast_bit8; }
    accumlo = accumlo << 1; if ((toplo>>7)+(tophi<<(32-7)) >= (bottom) || (tophi>>7)!=0) { accumlo++; if ((bottom<<7) > toplo) tophi--; toplo = toplo - (bottom<<7); tophi = tophi - (bottom>>(32-7)); if (!tophi) goto fast_bit7; }
    accumlo = accumlo << 1; if ((toplo>>6)+(tophi<<(32-6)) >= (bottom) || (tophi>>6)!=0) { accumlo++; if ((bottom<<6) > toplo) tophi--; toplo = toplo - (bottom<<6); tophi = tophi - (bottom>>(32-6)); if (!tophi) goto fast_bit6; }
    accumlo = accumlo << 1; if ((toplo>>5)+(tophi<<(32-5)) >= (bottom) || (tophi>>5)!=0) { accumlo++; if ((bottom<<5) > toplo) tophi--; toplo = toplo - (bottom<<5); tophi = tophi - (bottom>>(32-5)); if (!tophi) goto fast_bit5; }
    accumlo = accumlo << 1; if ((toplo>>4)+(tophi<<(32-4)) >= (bottom) || (tophi>>4)!=0) { accumlo++; if ((bottom<<4) > toplo) tophi--; toplo = toplo - (bottom<<4); tophi = tophi - (bottom>>(32-4)); if (!tophi) goto fast_bit4; }
    accumlo = accumlo << 1; if ((toplo>>3)+(tophi<<(32-3)) >= (bottom) || (tophi>>3)!=0) { accumlo++; if ((bottom<<3) > toplo) tophi--; toplo = toplo - (bottom<<3); tophi = tophi - (bottom>>(32-3)); if (!tophi) goto fast_bit3; }
    accumlo = accumlo << 1; if ((toplo>>2)+(tophi<<(32-2)) >= (bottom) || (tophi>>2)!=0) { accumlo++; if ((bottom<<2) > toplo) tophi--; toplo = toplo - (bottom<<2); tophi = tophi - (bottom>>(32-2)); if (!tophi) goto fast_bit2; }
    accumlo = accumlo << 1; if ((toplo>>1)+(tophi<<(32-1)) >= (bottom) || (tophi>>1)!=0) { accumlo++; if ((bottom<<1) > toplo) tophi--; toplo = toplo - (bottom<<1); tophi = tophi - (bottom>>(32-1)); if (!tophi) goto fast_bit1; }
    accumlo = accumlo << 1; if ((toplo>>0) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<0); }

    return (uint64)accumlo | ((uint64)accumhi)<<32;

fast_bit32:
    accumlo = accumlo << 1; if ((toplo>>31) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<31); } fast_bit31:
    accumlo = accumlo << 1; if ((toplo>>30) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<30); } fast_bit30:
    accumlo = accumlo << 1; if ((toplo>>29) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<29); } fast_bit29:
    accumlo = accumlo << 1; if ((toplo>>28) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<28); } fast_bit28:
    accumlo = accumlo << 1; if ((toplo>>27) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<27); } fast_bit27:
    accumlo = accumlo << 1; if ((toplo>>26) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<26); } fast_bit26:
    accumlo = accumlo << 1; if ((toplo>>25) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<25); } fast_bit25:
    accumlo = accumlo << 1; if ((toplo>>24) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<24); } fast_bit24:
    accumlo = accumlo << 1; if ((toplo>>23) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<23); } fast_bit23:
    accumlo = accumlo << 1; if ((toplo>>22) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<22); } fast_bit22:
    accumlo = accumlo << 1; if ((toplo>>21) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<21); } fast_bit21:
    accumlo = accumlo << 1; if ((toplo>>20) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<20); } fast_bit20:
    accumlo = accumlo << 1; if ((toplo>>19) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<19); } fast_bit19:
    accumlo = accumlo << 1; if ((toplo>>18) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<18); } fast_bit18:
    accumlo = accumlo << 1; if ((toplo>>17) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<17); } fast_bit17:
    accumlo = accumlo << 1; if ((toplo>>16) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<16); } fast_bit16:
    accumlo = accumlo << 1; if ((toplo>>15) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<15); } fast_bit15:
    accumlo = accumlo << 1; if ((toplo>>14) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<14); } fast_bit14:
    accumlo = accumlo << 1; if ((toplo>>13) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<13); } fast_bit13:
    accumlo = accumlo << 1; if ((toplo>>12) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<12); } fast_bit12:
    accumlo = accumlo << 1; if ((toplo>>11) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<11); } fast_bit11:
    accumlo = accumlo << 1; if ((toplo>>10) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<10); } fast_bit10:
    accumlo = accumlo << 1; if ((toplo>>9) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<9); } fast_bit9:
    accumlo = accumlo << 1; if ((toplo>>8) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<8); } fast_bit8:
    accumlo = accumlo << 1; if ((toplo>>7) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<7); } fast_bit7:
    accumlo = accumlo << 1; if ((toplo>>6) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<6); } fast_bit6:
    accumlo = accumlo << 1; if ((toplo>>5) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<5); } fast_bit5:
    accumlo = accumlo << 1; if ((toplo>>4) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<4); } fast_bit4:
    accumlo = accumlo << 1; if ((toplo>>3) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<3); } fast_bit3:
    accumlo = accumlo << 1; if ((toplo>>2) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<2); } fast_bit2:
    accumlo = accumlo << 1; if ((toplo>>1) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<1); } fast_bit1:
    accumlo = accumlo << 1; if ((toplo>>0) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<0); }
# 224 "c:/marmalade/7.3/modules/iwutil/h/IwDivide.h"
    return (uint64)accumlo | ((uint64)accumhi)<<32;
}

static inline uint64 i3d_ldiv_split(uint32 toplo, int32 tophi, int32 bottom)
{
    if(tophi<0) {
        if(bottom>0)
            return -(int64)i3d_uldiv_split(toplo, -tophi, bottom);
        else
            return i3d_uldiv_split(toplo, -tophi, -bottom);
    }
    else {
        if(bottom<0)
            return i3d_uldiv_split(toplo, tophi, -bottom);
        else
            return i3d_uldiv_split(toplo, tophi, bottom);
    }
}

static inline uint64 i3d_uldiv(uint64 udividend, uint32 udivisor)
{
    return i3d_uldiv_split((uint32)(udividend&0xffffffff), (uint32)(udividend>>32), udivisor);
}





static inline int64 i3d_ldiv(int64 dividend,
                    int32 divisor)
{
    if(dividend<0) {
        if(divisor>0)
            return -(int64)i3d_uldiv(-dividend,divisor);
        else
            return i3d_uldiv(-dividend,-divisor);
    }
    else {
        if(divisor<0)
            return -(int64)i3d_uldiv(dividend,-divisor);
        else
            return i3d_uldiv(dividend,divisor);
    }
}
# 293 "c:/marmalade/7.3/modules/iwutil/h/IwDivide.h"
static inline int32 i3d_lmod(int64 dividend, int32 divisor)
{
        return (int32)(dividend - (((int64)(((int64)(dividend))/((int32)(divisor)))) * divisor));
}
# 20 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h" 2
# 1 "c:/marmalade/7.3/modules/iwutil/h/IwMath.h" 1
# 16 "c:/marmalade/7.3/modules/iwutil/h/IwMath.h"
# 1 "c:/marmalade/7.3/s3e/h/std/float.h" 1
# 31 "c:/marmalade/7.3/s3e/h/std/float.h"
  extern "C" {
# 109 "c:/marmalade/7.3/s3e/h/std/float.h"
extern "C" {

unsigned _controlfp(unsigned, unsigned);
unsigned _clearfp(void);
unsigned _statusfp(void);

}
# 150 "c:/marmalade/7.3/s3e/h/std/float.h"
    }
# 17 "c:/marmalade/7.3/modules/iwutil/h/IwMath.h" 2



# 1 "c:/marmalade/7.3/modules/iwutil/h/IwDebug.h" 1
# 21 "c:/marmalade/7.3/modules/iwutil/h/IwMath.h" 2
# 87 "c:/marmalade/7.3/modules/iwutil/h/IwMath.h"
static inline int32 IwRoundFraction(double aValue)
{
    double lPositive = (aValue < 0.0f) ? -aValue : aValue;
    double lDecimal = lPositive - (double) ((int32) lPositive);
    int32 lRetVal;

    if (aValue < 0.0f)
    {
        if (lDecimal >= 0.5f)
        {
            lRetVal = ((int32) aValue) - 1;
        }
        else
        {
            lRetVal = (int32) aValue;
        }
    }
    else
    {
        if (lDecimal >= 0.5f)
        {
            lRetVal = ((int32) aValue) + 1;
        }
        else
        {
            lRetVal = (int32) aValue;
        }
    }
    return lRetVal;
}







static inline uint8 iwlzc(uint32 a)
{
    uint8 r=0;
    if ((a >> 16) == 0) {r+=16; a<<=16;}
    if ((a >> 24) == 0) {r+=8; a<<=8;}
    if ((a >> 28) == 0) {r+=4; a<<=4;}
    if ((a >> 30) == 0) {r+=2; a<<=2;}
    if ((a >> 31) == 0) {r+=1;}
    return r;
}






static inline uint8 iwlog2(uint32 a)
{
    return (uint8)(31-iwlzc(a));
}
# 158 "c:/marmalade/7.3/modules/iwutil/h/IwMath.h"
static inline uint32 clz(uint32 a)
{

    int32 r=0;
    if ((a >> 16) == 0) {r+=16; a<<=16;}
    if ((a >> 24) == 0) {r+=8; a<<=8;}
    if ((a >> 28) == 0) {r+=4; a<<=4;}
    if ((a >> 30) == 0) {r+=2; a<<=2;}
    if ((a >> 31) == 0) {r+=1;}
    return r;
}
# 21 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h" 2
# 1 "c:/marmalade/7.3/modules/iwutil/h/IwRuntime.h" 1
       
# 30 "c:/marmalade/7.3/modules/iwutil/h/IwRuntime.h"
# 1 "c:/marmalade/7.3/s3e/h/s3eTimer.h" 1
# 54 "c:/marmalade/7.3/s3e/h/s3eTimer.h"
typedef enum s3eTimerProperty
{
    S3E_TIMER_RESOLUTION
} s3eTimerProperty;
# 66 "c:/marmalade/7.3/s3e/h/s3eTimer.h"
typedef enum s3eTimerError
{
    S3E_TIMER_ERR_NONE = 0,
    S3E_TIMER_ERR_PARAM = 1,
    S3E_TIMER_ERR_TOO_MANY = 2,
    S3E_TIMER_ERR_ALREADY_REG = 3,
    S3E_TIMER_ERR_NOT_FOUND = 4,
    S3E_TIMER_ERR_UNAVAIL = 5
} s3eTimerError;
# 87 "c:/marmalade/7.3/s3e/h/s3eTimer.h"
extern "C" s3eTimerError s3eTimerGetError();
# 100 "c:/marmalade/7.3/s3e/h/s3eTimer.h"
extern "C" const char* s3eTimerGetErrorString();
# 116 "c:/marmalade/7.3/s3e/h/s3eTimer.h"
extern "C" int32 s3eTimerGetInt(s3eTimerProperty property);
# 130 "c:/marmalade/7.3/s3e/h/s3eTimer.h"
extern "C" int64 s3eTimerGetUST();
# 141 "c:/marmalade/7.3/s3e/h/s3eTimer.h"
extern "C" int64 s3eTimerGetUSTNanoseconds();




extern "C" uint64 s3eTimerGetMs();





extern "C" int64 s3eTimerGetUTC();
# 161 "c:/marmalade/7.3/s3e/h/s3eTimer.h"
extern "C" int64 s3eTimerGetLocaltimeOffset(int64* when =__null);
# 193 "c:/marmalade/7.3/s3e/h/s3eTimer.h"
extern "C" s3eResult s3eTimerSetTimer(uint32 ms, s3eCallback fn, void* userData);
# 214 "c:/marmalade/7.3/s3e/h/s3eTimer.h"
extern "C" s3eResult s3eTimerCancelTimer(s3eCallback fn, void* userData);
# 31 "c:/marmalade/7.3/modules/iwutil/h/IwRuntime.h" 2

extern "C" {
# 41 "c:/marmalade/7.3/modules/iwutil/h/IwRuntime.h"
typedef struct _IwCallStack
{
    const char** m_Stack;
    const char** m_StackPtr;

} IwCallStack;

void IwCallStackLeave(void* pObj);
void IwCallStackSetStackSizeLimit(uint32 limit);
void IwCallStackSetStackAddress(uint32 addr);
void IwCallStackPrintStack(char* pBuffer);
IwCallStack* IwCallStackGet();







void IwCallStackInit();
void IwCallStackTerm();


s3eBool IwCallStackEnter(const char* pName, void* pObj);




void IwCallStackFunctionDumpToFile(const char* filename);





    void IwCallStackSetCallStackTracing(bool bOnOrOff);



void IwProfileStartProfile(const char* name);
void IwProfileStopProfile();
void IwProfileIncrementFrameCounter();
void IwProfileReset();

}
# 93 "c:/marmalade/7.3/modules/iwutil/h/IwRuntime.h"
class CIwCallStack
{
public:

    CIwCallStack(const char* pName)
    {
        m_Entered = IwCallStackEnter(pName, (void*)this);
    }
    ~CIwCallStack()
    {
        if( m_Entered )
            IwCallStackLeave((void*)this);
    }
    s3eBool m_Entered;
};
# 214 "c:/marmalade/7.3/modules/iwutil/h/IwRuntime.h"
class CIwProfileNode
{
public:
    CIwProfileNode(const char* name, CIwProfileNode* parent);
    ~CIwProfileNode();

    CIwProfileNode* GetSubNode(const char* name);

    CIwProfileNode* GetParent() {return m_Parent;}
    CIwProfileNode* GetSibling() {return m_Sibling;}
    CIwProfileNode* GetChild() {return m_Child;}

    void Reset();
    void Call();
    bool Return();
    void NewFrame();

    const char* GetName() {return m_Name;}
    long GetTotalCalls() {return m_TotalCalls;}
    float GetTotalTime() {return m_TotalTime;}
    float GetLastTime() {return m_LastTime;}

    long GetLastFrameCalls(){ return m_LastFrameCalls; }
    float GetLastFrameTime() { return m_LastFrameTime; }
    float GetFrameTimeAvg() { return m_FrameWeightedAvg; }

    bool IsRemainingTimeNode() { return m_IsOtherTimeNode; }

protected:
    const char* m_Name;
    long m_TotalCalls;
    float m_TotalTime;
    float m_LastTime;
    float m_WeightedAvg;

    long m_FrameCalls;
    float m_FrameTime;
    float m_FrameWeightedAvg;

    long m_LastFrameCalls;
    float m_LastFrameTime;

    int32 m_StartTime;
    long m_RecursionCounter;

    bool m_IsOtherTimeNode;

    CIwProfileNode* m_Parent;
    CIwProfileNode* m_Child;
    CIwProfileNode* m_Sibling;
};




class CIwProfileIterator
{
public:

    void First();
    void Next();
    bool IsDone();

    void EnterChild(long index);
    void EnterParent();


    const char* GetCurrentName() {return m_CurrentChild->GetName();}
    long GetCurrentTotalCalls() {return m_CurrentChild->GetTotalCalls();}
    float GetCurrentTotalTime() {return m_CurrentChild->GetTotalTime();}
    float GetCurrentLastTime() {return m_CurrentChild->GetLastTime();}
    float GetCurrentLastFrameTime() {return m_CurrentChild->GetLastFrameTime();}
    long GetCurrentLastFrameCalls() {return m_CurrentChild->GetLastFrameCalls();}
    float GetCurrentFrameTimeAvg() {return m_CurrentChild->GetFrameTimeAvg();}
    bool IsCurrentRemainingTimeNode() {return m_CurrentChild->IsRemainingTimeNode();}




    const char* GetCurrentParentName() {return m_CurrentParent->GetName();}
    long GetCurrentParentTotalCalls() {return m_CurrentParent->GetTotalCalls();}
    float GetCurrentParentTotalTime() {return m_CurrentParent->GetTotalTime();}


protected:
    CIwProfileNode* m_CurrentParent;
    CIwProfileNode* m_CurrentChild;

    CIwProfileIterator(CIwProfileNode* start);
    friend class CIwProfileManager;
};




class CIwProfileManager
{
public:
    CIwProfileManager(uint32 maxNodes=200);
    ~CIwProfileManager();

    inline void SetActive(bool active) {m_Active = active;}
    void StartProfile(const char* name);
    void StopProfile();

    void Reset();
    void IncrementFrameCounter();
    inline long GetFrameCountSinceReset() {return m_FrameCounter;}
    float GetTimeSinceReset();

    inline CIwProfileIterator* GetIterator() {return new CIwProfileIterator(&m_Root);}
    inline void ReleaseIterator(CIwProfileIterator* iterator ) {delete iterator;}


    static CIwProfileManager& Get();

    static CIwProfileManager* g_Singleton;

    CIwProfileNode* AllocNode(const char* name, CIwProfileNode* parent);

private:
    bool m_Active;
    CIwProfileNode m_Root;
    CIwProfileNode* m_CurrentNode;
    long m_FrameCounter;
    int64 m_ResetTime;
    uint32* m_Memory;
    uint32* m_MemoryCursor;
    int32 m_FreeNodes;
};




class CIwProfileSample
{
public:
    CIwProfileSample(const char* name) {IwProfileStartProfile(name);}
    ~CIwProfileSample() {IwProfileStopProfile();}
};
# 22 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h" 2
# 49 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
void IwGeomInit();






void IwGeomTerminate();
# 161 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
typedef int32 iwfixed;




typedef uint32 iwufixed;




typedef int16 iwsfixed;




typedef uint16 iwusfixed;




typedef int32 iwqfixed;
# 191 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
typedef int32 iwangle;




typedef int32 iwqangle;
# 227 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline iwsfixed IW_SFIXED_FROM_FIXED(iwfixed a)
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(a >> 31 == a >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(349); IwDebugAssertSetMessage ("Conversion overflow"); switch (IwDebugAssertShow("a >> 31 == a >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 229, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (iwsfixed)a;
}
# 271 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_FROM_FLOAT(float a)
{

    int64 fix64 = (int64)(a * (float)(1 << 12));
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(fix64 >> 63 == fix64 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(94); IwDebugAssertSetMessage ("Conversion overflow"); switch (IwDebugAssertShow("fix64 >> 63 == fix64 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 275, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return (iwfixed)(a * (float)(1 << 12));
}
# 290 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline iwsfixed IW_SFIXED_FROM_FLOAT_CAST(float a)
{

    int64 fix64 = (int64)a;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(fix64 >> 63 == fix64 >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(94); IwDebugAssertSetMessage ("Conversion overflow"); switch (IwDebugAssertShow("fix64 >> 63 == fix64 >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 294, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return (iwsfixed)a;
}

static inline iwfixed IW_FIXED_FROM_FLOAT_CAST(float a)
{

    int64 fix64 = (int64)a;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(fix64 >> 63 == fix64 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(94); IwDebugAssertSetMessage ("Conversion overflow"); switch (IwDebugAssertShow("fix64 >> 63 == fix64 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 303, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return (iwfixed)a;
}
# 365 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline iwangle IW_ANGLE_DIFFERENCE(iwangle x, iwangle y)
{
    iwangle z = ((iwangle)((x - y) & (((iwangle)(1 << 12)) - 1)));

    if (z <= ((iwangle)(1 << (12 - 1))))
        return z;
    else
        return z - ((iwangle)(1 << 12));
}
# 387 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL(iwfixed a, iwfixed b)
{

    int64 test = (int64)a * b;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(350); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 391, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return (a * b) >> 12;
}
# 405 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL_SAFE(iwfixed a, iwfixed b)
{
    int64 res = (((int64)a * b) >> 12);
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(res >> 63 == res >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(351); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("res >> 63 == res >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 408, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (iwfixed)res;
}
# 422 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline iwsfixed IW_SFIXED_MUL(iwfixed a, iwfixed b)
{
    return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(a, b));
}
# 436 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline iwqfixed IW_QFIXED_MUL(iwqfixed a, iwqfixed b)
{

    int64 test = (int64)a * b;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(352); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 440, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return (a * b) >> 30;
}
# 454 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline iwqfixed IW_QFIXED_MUL_SAFE(iwqfixed a, iwqfixed b)
{
    int64 res = (((int64)a * b) >> 30);
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(res >> 63 == res >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(353); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("res >> 63 == res >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 457, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (iwfixed)res;
}
# 470 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL3(iwfixed a, iwfixed b, iwfixed c, iwfixed d, iwfixed e, iwfixed f)
{

    int64 test1 = (int64)a * d;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test1 >> 63 == test1 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(357); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test1 >> 63 == test1 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 474, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    int64 test2 = (int64)b * e;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test2 >> 63 == test2 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(358); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test2 >> 63 == test2 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 476, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    int64 test3 = (int64)c * f;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test3 >> 63 == test3 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(359); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test3 >> 63 == test3 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 478, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test1 += test2;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test1 >> 63 == test1 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(360); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test1 >> 63 == test1 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 480, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test1 += test3;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test1 >> 63 == test1 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(361); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test1 >> 63 == test1 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 482, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (iwfixed)(test1 >> 12);



}
# 499 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL3_SAFE(iwfixed a, iwfixed b, iwfixed c, iwfixed d, iwfixed e, iwfixed f)
{
    int64 res = ((((int64)a * d) + ((int64)b * e) + ((int64)c * f)) >> 12);
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(res >> 63 == res >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(354); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("res >> 63 == res >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 502, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (iwfixed)res;
}
# 516 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL2(iwfixed a, iwfixed b, iwfixed d, iwfixed e)
{

    int64 test1 = (int64)a * d;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test1 >> 63 == test1 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(357); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test1 >> 63 == test1 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 520, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    int64 test2 = (int64)b * e;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test2 >> 63 == test2 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(358); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test2 >> 63 == test2 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 522, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test1 += test2;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test1 >> 63 == test1 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(360); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test1 >> 63 == test1 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 524, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (iwfixed)(test1 >> 12);



}
# 542 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL2_SAFE(iwfixed a, iwfixed b, iwfixed d, iwfixed e)
{
    int64 res = ((((int64)a * d) + ((int64)b * e)) >> 12);
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(res >> 63 == res >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(354); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("res >> 63 == res >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 545, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (iwfixed)res;
}
# 562 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_DIV(iwfixed a, iwfixed b)
{
    if (!(b & ((1 << 12) - 1)))
    {
        return (iwfixed)(((int32)(a))/((int32)(b >> 12)));
    }
    else
    {

        int64 test = ((int64)a << 12);
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(355); IwDebugAssertSetMessage ("Divide overflow"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 572, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        return (iwfixed)(((int32)(a << 12))/((int32)(b)));
    }
}
# 593 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_DIV_SAFE(iwfixed a, iwfixed b)
{
    if ((a>>19) == (a>>31) || !(b & ((1 << 12) - 1))) return IW_FIXED_DIV(a, b);
    int64 result = ((int64)a << 12);
    result = ((int64)(((int64)(result))/((int32)(b))));
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(result >> 63 == result >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(356); IwDebugAssertSetMessage ("Divide overflow"); switch (IwDebugAssertShow("result >> 63 == result >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 598, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (iwfixed)result;
}


extern "C" {
# 613 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
iwfixed IwGeomSin(iwangle x);






iwfixed IwGeomCos(iwangle x);






iwqfixed IwGeomQSin(iwqangle x);






iwqfixed IwGeomQCos(iwqangle x);






iwfixed IwGeomTan(iwangle x);






iwfixed IwGeomACos(iwfixed v);






iwqfixed IwGeomQACos(iwqfixed v);






iwfixed IwGeomASin(iwfixed v);






iwqfixed IwGeomQASin(iwqfixed v);






iwqfixed IwGeomQATan2(iwqfixed u, iwqfixed v);
# 687 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
iwangle IwGeomAtan2(int y, int x);
# 703 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
extern double cos(double);
extern double acos(double);
extern double sin(double);
extern double asin(double);
extern double sqrt(double);
extern double tan(double);
extern double atan2(double,double);
# 720 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
}
# 731 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline int32 IW_MULCHECK(const int32 a, const int32 b)
{

        int64 test = (int64)a*b;
        int64 testbig = test >> 31;
        int64 testsmall = test >> 63;
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(testsmall == testbig)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(362); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("testsmall == testbig", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 737, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return a*b;
}
# 752 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline int32 IW_MUL64_SHIFT(int32 a, int32 b, int32 shift)
{

        int64 test = ((int64)a*b) >> shift;
        int64 testbig = test >> 31;
        int64 testsmall = test >> 63;
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(testsmall == testbig)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(336); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("testsmall == testbig", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 758, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


    return (int32)(((int64)a * b) >> shift);
}
# 774 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline int32 IW_MUL64_3_SHIFT(int32 a, int32 b, int32 c, int32 d, int32 e, int32 f, int32 shift)
{

        int64 test = (((int64)a * d) + ((int64)b * e) + ((int64)c * f)) >> shift;
        int64 testbig = test >> 31;
        int64 testsmall = test >> 63;
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(testsmall == testbig)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(338); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("testsmall == testbig", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 780, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


    return (int32) ((((int64)a * d) + ((int64)b * e) + ((int64)c * f)) >> shift);
}
# 795 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline int32 IW_MUL_3_SHIFT(int32 a, int32 b, int32 c, int32 d, int32 e, int32 f, int32 shift)
{

    int64 test1 = (int64)a * d;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test1 >> 63 == test1 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(1796); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test1 >> 63 == test1 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 799, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    int64 test2 = (int64)b * e;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test2 >> 63 == test2 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(1797); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test2 >> 63 == test2 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 801, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    int64 test3 = (int64)c * f;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test3 >> 63 == test3 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(1798); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test3 >> 63 == test3 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 803, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test1 += test2;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test1 >> 63 == test1 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(1799); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test1 >> 63 == test1 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 805, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test1 += test3;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test1 >> 63 == test1 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(1800); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test1 >> 63 == test1 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 807, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (iwfixed)(test1 >> shift);



}
# 825 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h"
static inline int32 IW_MUL_2_SHIFT(int32 a, int32 b, int32 d, int32 e, int32 shift)
{

    int64 test1 = (int64)a * d;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test1 >> 63 == test1 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(1796); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test1 >> 63 == test1 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 829, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    int64 test2 = (int64)b * e;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test2 >> 63 == test2 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(1797); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test2 >> 63 == test2 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 831, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test1 += test2;
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test1 >> 63 == test1 >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(1799); IwDebugAssertSetMessage ("Multiply overflow"); switch (IwDebugAssertShow("test1 >> 63 == test1 >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h", 833, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (iwfixed)(test1 >> shift);



}




# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomLegacy.h" 1
       
# 844 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h" 2
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSqrt.h" 1
       
# 38 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSqrt.h"
iwfixed IW_GEOM_SQRT(iwfixed a);






iwqfixed IW_GEOM_QSQRT(iwqfixed a);
# 54 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSqrt.h"
int32 IW_GEOM_SQRT2(int32 a);
# 79 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSqrt.h"
extern iwfixed g_SqrtTable [];


void IwSqrtInit();
# 93 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSqrt.h"
static inline iwfixed IW_GEOM_SQRT_FAST(iwfixed x){
    uint32 m = clz(x);

    if (m <= (32 - 12 + 1)) {
        m = ((32 - 12 + 1) - m + 1) & (~1);




        int32 totalshift = (0>>1) + 12 - (m>>1);

        if (((x<<1)>>m)&1){
            if (totalshift > 0)
                return g_SqrtTable[(x>>m)+1]>>totalshift;
            else
                return g_SqrtTable[(x>>m)+1]<<(-totalshift);
        } else {
            if (totalshift > 0)
                return g_SqrtTable[x>>m]>>totalshift;
            else
                return g_SqrtTable[x>>m]<<(-totalshift);
        }
    } else {
        m = (m - (32 - 12 + 1) - 1) & (~1);




        return g_SqrtTable[x<<m]>>((0 + m)>>1)>>12;
    }
}
# 133 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSqrt.h"
static inline iwfixed IW_GEOM_SQRT2_FAST(iwfixed x){
    uint32 m = clz(x);

    if (m <= (32 - 12 + 1)) {
        m = ((32 - 12 + 1) - m + 1) & (~1);




        int32 totalshift = (0>>1) + (12>>1) - (m>>1);

        if (((x<<1)>>m)&1){
            if (totalshift > 0)
                return g_SqrtTable[(x>>m)+1]>>totalshift;
            else
                return g_SqrtTable[(x>>m)+1]<<(-totalshift);
        } else {
            if (totalshift > 0)
                return g_SqrtTable[x>>m]>>totalshift;
            else
                return g_SqrtTable[x>>m]<<(-totalshift);
        }
    } else {
        m = (m - (32 - 12 + 1) - 1) & (~1);




        return g_SqrtTable[x<<m]>>((0 + m + 12)>>1);
    }
}
# 190 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSqrt.h"
void IwInverseSqrtInit();






extern iwfixed g_InverseSqrtTable[];
# 209 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSqrt.h"
static inline iwfixed IW_GEOM_INVERSE_SQRT(iwfixed x)
{
    uint32 m = clz(x);







    if (m <= (32 - 12 + 1)){
        m = ((32 - 12 + 1) - m + 1)>>1;





        return (g_InverseSqrtTable[x>>(m<<1)]<<(6>>1))>>m;
    } else {
        m = (m - (32 - 12 + 1))>>1;





        return g_InverseSqrtTable[x<<(m<<1)]<<((6>>1) - m);
    }
}
# 250 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSqrt.h"
static inline iwfixed IW_GEOM_INVERSE_SQRT2(iwfixed x){
    uint32 m = clz(x);







    if (m <= (32 - 12 + 1)){
        m = ((32 - 12 + 1) - m + 1)>>1;





        return (g_InverseSqrtTable[x>>(m<<1)]<<((6 + 12)>>1))>>m;
    } else {
        m = (m - (32 - 12 + 1))>>1;





        return g_InverseSqrtTable[x<<(m<<1)]<<(((6 + 12)>>1) - m);
    }
}
# 845 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomCore.h" 2
# 22 "c:/marmalade/7.3/modules/iwgeom/h/IwGeom.h" 2
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec.h" 1
       
# 33 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec.h"
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h" 1
       
# 31 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h"
# 1 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h" 1
       
# 18 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
# 1 "c:/marmalade/7.3/s3e/h/s3eFile.h" 1
# 50 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef struct s3eFile s3eFile;
# 83 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef enum s3eFileSeekOrigin
{
    S3E_FILESEEK_SET = 0,
    S3E_FILESEEK_CUR = 1,
    S3E_FILESEEK_END = 2
} s3eFileSeekOrigin;




typedef struct s3eFileList s3eFileList;
# 114 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef enum s3eFileProperty
{






    S3E_FILE_ROM_EXISTS = 1,





    S3E_FILE_BYTES_TOTAL = 2,




    S3E_FILE_BYTES_FREE = 3
} s3eFileProperty;
# 144 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef enum s3eFileStats
{







    S3E_FILE_ISFILE = 0,







    S3E_FILE_ISDIR = 1,






    S3E_FILE_ISUSER = 2,
# 181 "c:/marmalade/7.3/s3e/h/s3eFile.h"
    S3E_FILE_ISWRITABLE = 3,





    S3E_FILE_SIZE = 4,
# 197 "c:/marmalade/7.3/s3e/h/s3eFile.h"
    S3E_FILE_MODIFIED_DATE = 5,
# 209 "c:/marmalade/7.3/s3e/h/s3eFile.h"
    S3E_FILE_DRIVE_BYTES_FREE = 6,
# 218 "c:/marmalade/7.3/s3e/h/s3eFile.h"
    S3E_FILE_DRIVE = 7,
# 227 "c:/marmalade/7.3/s3e/h/s3eFile.h"
    S3E_FILE_DRIVE_BYTES_TOTAL = 8,






    S3E_FILE_REAL_PATH = 9,
} s3eFileStats;
# 253 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" int32 s3eFileGetInt(s3eFileProperty property);
# 278 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" int64 s3eFileGetFileInt(const char* filename, s3eFileStats stat);
# 303 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" char* s3eFileGetFileString(const char* filename, s3eFileStats stat, char* str, int len);
# 312 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef enum s3eFileError
{
    S3E_FILE_ERR_NONE = 0,
    S3E_FILE_ERR_PARAM = 1,
    S3E_FILE_ERR_TOO_MANY = 2,
    S3E_FILE_ERR_ALREADY_REG = 3,
    S3E_FILE_ERR_NOT_FOUND = 4,
    S3E_FILE_ERR_UNAVAIL = 5,
    S3E_FILE_ERR_DEVICE = 6,
    S3E_FILE_ERR_UNSUPPORTED = 7,
    S3E_FILE_ERR_MEM = 8,
    S3E_FILE_ERR_GENERIC = 9,
    S3E_FILE_ERR_INVALID_DRIVE = 10,
    S3E_FILE_ERR_INVALID_PATH = 11,
    S3E_FILE_ERR_DATA = 12,

    S3E_FILE_ERR_INVALID_MODE = 1000,
    S3E_FILE_ERR_EXISTS = 1001,
    S3E_FILE_ERR_NOT_EMPTY = 1002,
    S3E_FILE_ERR_ACCESS = 1003,
    S3E_FILE_ERR_NO_MORE = 1004,
    S3E_FILE_ERR_EOF = 1005
} s3eFileError;
# 347 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eFileError s3eFileGetError();
# 361 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" const char* s3eFileGetErrorString();
# 412 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eFile* s3eFileOpen(const char* filename, const char* mode);
# 431 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eFile* s3eFileOpenFromMemory(void* buffer, uint32 bufferLen);
# 448 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileClose(s3eFile* file);
# 469 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileFlush(s3eFile* file);
# 500 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" uint32 s3eFileRead(void* buffer, uint32 elemSize, uint32 noElems, s3eFile* file);
# 527 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" uint32 s3eFileWrite(const void* buffer, uint32 elemSize, uint32 noElems, s3eFile* file);
# 541 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" int s3eFilePrintf(s3eFile* f, const char *fmt, ...);
# 561 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" int32 s3eFileGetChar(s3eFile* file);
# 584 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" int32 s3eFilePutChar(char c, s3eFile* file);
# 622 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" char* s3eFileReadString(char* string, uint32 maxLen, s3eFile* file);
# 645 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eBool s3eFileEOF(s3eFile* file);
# 680 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileSeek(s3eFile* file, int32 offset, s3eFileSeekOrigin origin);
# 696 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" int32 s3eFileTell(s3eFile* file);
# 713 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" int32 s3eFileGetSize(s3eFile* file);
# 739 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileMakeDirectory(const char* dirName);
# 764 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileDeleteDirectory(const char* dirName);
# 780 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eBool s3eFileCheckExists(const char* filename);
# 814 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileRename(const char* src, const char* dest);
# 839 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileDelete(const char* filename);
# 867 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileTruncate(const char* filename, uint32 length);
# 877 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" uint64 s3eFileGetLastWriteTime(const char* filename);
# 906 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eFileList* s3eFileListDirectory(const char* dirName);
# 928 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileListNext(s3eFileList* handle, char* filename, int filenameLen);
# 943 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileListClose(s3eFileList* handle);







typedef struct s3eUsrFile s3eUsrFile;
# 961 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef s3eUsrFile*(*s3eUserOpenFn)(const char* filename, const char *mode);
# 973 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef uint32 (*s3eUserReadFn)(void* buffer, uint32 elemLen, uint32 noElems, s3eUsrFile *file);
# 985 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef uint32 (*s3eUserWriteFn)(const void* buffer, uint32 elemLen, uint32 noElems, s3eUsrFile *file);
# 994 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef s3eBool (*s3eUserEOFFn)(s3eUsrFile* file);
# 1005 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserSeekFn)(s3eUsrFile* file, int32 offset, s3eFileSeekOrigin origin);
# 1014 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef int32 (*s3eUserTellFn)(s3eUsrFile* file);
# 1023 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserCloseFn)(s3eUsrFile* file);




typedef struct s3eUsrFileList s3eUsrFileList;
# 1038 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef s3eUsrFileList* (*s3eUserListDirFn)(const char* path);
# 1052 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserListNextFn)(s3eUsrFileList* handle, char* filename, int filenameLen);
# 1062 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserListCloseFn)(s3eUsrFileList* handle);
# 1072 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserDeleteFn)(const char* filename);
# 1109 "c:/marmalade/7.3/s3e/h/s3eFile.h"
typedef struct
{
    s3eUserOpenFn m_Open;
    s3eUserReadFn m_Read;
    s3eUserEOFFn m_EOF;
    s3eUserSeekFn m_Seek;
    s3eUserTellFn m_Tell;
    s3eUserCloseFn m_Close;

    s3eUserListDirFn m_ListDir;
    s3eUserListNextFn m_ListNext;
    s3eUserListCloseFn m_ListClose;

    s3eUserWriteFn m_Write;
    s3eUserDeleteFn m_Delete;

    void* m_Reserved[5];
} s3eFileUserCallbacks;
# 1139 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileAddUserFileSys(s3eFileUserCallbacks* callbacks);
# 1149 "c:/marmalade/7.3/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileRemoveUserFileSys(s3eFileUserCallbacks* callbacks);





# 1 "c:/marmalade/7.3/s3e/h/legacy/s3eFile_legacy.h" 1
# 16 "c:/marmalade/7.3/s3e/h/legacy/s3eFile_legacy.h"
typedef enum s3eFilePath
{
    S3E_FILEPATH_ROM,
    S3E_FILEPATH_RAM,
    S3E_FILEPATH_MMC,
    S3E_FILEPATH_MAX
} s3eFilePath;
# 34 "c:/marmalade/7.3/s3e/h/legacy/s3eFile_legacy.h"
extern "C" uint64 s3eFileGetFree(s3eFilePath path);
# 1156 "c:/marmalade/7.3/s3e/h/s3eFile.h" 2
# 19 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h" 2

class CIwManaged;
class CIwTextParserITX;
# 39 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
typedef void(*IwSerialiseUserCallback)();





struct IwSerialiseContext
{
    bool read;
    uint32 base;
    s3eFile* handle;
    char filename[160];
    uint32 bytesRead;
    uint32 callbackPeriod;
    uint8 buffer[8];
    int32 headBit;
    uint32 version;
    uint16 versionUser;
    uint16 pad;
    IwSerialiseUserCallback callback;
};
extern IwSerialiseContext g_IwSerialiseContext;
extern int g_IwSerialiseContextValid;
# 76 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
enum IwSerialiseMode
{
    IW_SERIALISE_WRITE = 0,
    IW_SERIALISE_READ = 1
};
# 89 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
static inline bool IwSerialiseIsReading() {return g_IwSerialiseContext.read == true;}
# 98 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
static inline bool IwSerialiseIsWriting() {return g_IwSerialiseContext.read == false;}
# 109 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseSetUserVersion(uint16 v) {g_IwSerialiseContext.versionUser = v;}
# 118 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
static inline uint16 IwSerialiseGetUserVersion() {return g_IwSerialiseContext.versionUser;}







static inline bool IwIsSerialiseOpen(){return (g_IwSerialiseContextValid > 0);}
# 135 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseOpen(const char* filename, IwSerialiseMode mode, bool ram=false);
# 145 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseOpen(const char* filename, bool read, bool ram=false)
{
    IwSerialiseOpen(filename, read ? IW_SERIALISE_READ : IW_SERIALISE_WRITE, ram);
}






bool IwSerialiseExists(const char* filename, bool ram=false);







bool IwSerialiseEOF();
# 173 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseOpenFromMemory(void* pBuffer, int size, IwSerialiseMode mode);







static inline void IwSerialiseOpenFromMemory(void* pBuffer, int size, bool read)
{
    IwSerialiseOpenFromMemory(pBuffer, size, read ? IW_SERIALISE_READ : IW_SERIALISE_WRITE);
}






void IwSerialiseClose();






void IwSerialiseResetCallbackCount();






void IwSerialiseSetCallbackPeriod(uint32 p);






void IwSerialiseSetCallback(IwSerialiseUserCallback cb);
# 221 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
static inline void _SerialiseScalarType(IwSerialiseContext& c, void* var, int itemSize, int numItems)
{

    if (c.read == true)
        s3eFileRead(var, itemSize, numItems, c.handle);
    else
        s3eFileWrite(var, itemSize, numItems, c.handle);
# 249 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
}
# 260 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseDouble(double& var, int n=1, int numBits=sizeof(double)*8, int stride=sizeof(double));
# 271 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseFloat(float& var, int n=1, int numBits=sizeof(float)*8, int stride=sizeof(float));
# 282 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt64(uint64& var, int n=1, int numBits=sizeof(uint64)*8, int stride=sizeof(uint64));
# 293 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt64(int64& var, int n=1, int numBits=sizeof(int64)*8-1, int stride=sizeof(int64));
# 305 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt32(uint32& var, int n=1, int numBits=sizeof(uint32)*8, int stride=sizeof(uint32));
# 316 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt32(int32& var, int n=1, int numBits=sizeof(int32)*8-1, int stride=sizeof(int32));
# 327 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt16(uint16& var, int n=1, int numBits=sizeof(uint16)*8, int stride=sizeof(uint16));
# 338 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt16(int16& var, int n=1, int numBits=sizeof(int16)*8-1, int stride=sizeof(int16));
# 349 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt8(uint8& var, int n=1, int numBits=sizeof(uint8)*8, int stride=sizeof(uint8));
# 360 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt8(int8& var, int n=1, int numBits=sizeof(int8)*8-1, int stride=sizeof(int8));
# 371 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseChar(char& var, int n=1, int numBits=sizeof(int8)*8-1, int stride=sizeof(char));
# 382 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseBool(bool& var, int n=1, int numBits=1, int stride=sizeof(bool));
# 392 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseEnum(void* pVar);





template <class T, bool SGN>
void _IwSerialiseBitDepthRequired(T& var, int n, int stride, void(*CB1)(T&, int, int, int))
{

    uint32 mb;
    if (g_IwSerialiseContext.read == false)
    {
        T* pVal = &var;
        uint32 t = n;
        mb = 1;
        while(t-- && (mb < sizeof(T)*8))
        {
            T v = *pVal;
            pVal += stride / sizeof(T);
            if (SGN)
            {
                if (v & (1ul << ((sizeof(T)*8) - 1)))
                    v = ~v;
            }
            while((v >= ((T)1 << mb)) && (mb < sizeof(T)*8))
                mb++;
        }
    }

    IwSerialiseUInt32(mb, 1, 6);
    (CB1)(var, n, mb, stride);



}
# 440 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseCharBitDepthRequired(char& var, int n=1, int stride=sizeof(char))
{
    _IwSerialiseBitDepthRequired<char, true>(var, n, stride, IwSerialiseChar);
}
# 456 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseInt8BitDepthRequired(int8& var, int n=1, int stride=sizeof(int8))
{
    _IwSerialiseBitDepthRequired<int8, true>(var, n, stride, IwSerialiseInt8);
}
# 472 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseUInt8BitDepthRequired(uint8& var, int n=1, int stride=sizeof(uint8))
{
    _IwSerialiseBitDepthRequired<uint8, false>(var, n, stride, IwSerialiseUInt8);
}
# 488 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseInt16BitDepthRequired(int16& var, int n=1, int stride=sizeof(int16))
{
    _IwSerialiseBitDepthRequired<int16, true>(var, n, stride, IwSerialiseInt16);
}
# 504 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseUInt16BitDepthRequired(uint16& var, int n=1, int stride=sizeof(uint16))
{
    _IwSerialiseBitDepthRequired<uint16, false>(var, n, stride, IwSerialiseUInt16);
}
# 520 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseInt32BitDepthRequired(int32& var, int n=1, int stride=sizeof(int32))
{
    _IwSerialiseBitDepthRequired<int32, true>(var, n, stride, IwSerialiseInt32);
}
# 536 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseUInt32BitDepthRequired(uint32& var, int n=1, int stride=sizeof(uint32))
{
    _IwSerialiseBitDepthRequired<uint32, false>(var, n, stride, IwSerialiseUInt32);
}
# 591 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseMappedData(const uint16* pMap, void* _pData, int numStructs, int stride);
# 602 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseString(char* text, int maxLen=0);
# 615 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseManagedHash(void* pptr);






void IwSerialiseManagedObject(CIwManaged*& pObj);
# 633 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
void IwSerialiseFile(CIwTextParserITX* pParser, char const* filename, void* pptr, IwSerialiseMode mode);
# 642 "c:/marmalade/7.3/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseFile(CIwTextParserITX* pParser, char const* filename, void* pptr, bool read)
{
    IwSerialiseFile(pParser, filename, pptr, read ? IW_SERIALISE_READ : IW_SERIALISE_WRITE);
}
# 32 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h" 2

class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwSVec2
{
public:
    int16 x;
    int16 y;


    static CIwSVec2 g_Zero;


    static CIwSVec2 g_AxisX;


    static CIwSVec2 g_AxisY;




    CIwSVec2() {};






    CIwSVec2(int16 _x, int16 _y) : x(_x), y(_y) {};

    explicit CIwSVec2(const CIwVec2& v);
    explicit CIwSVec2(const CIwFVec2& v);
    CIwSVec2 operator = (const CIwVec2& v);
    CIwSVec2 operator = (const CIwFVec2& v);
# 90 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {


        int64 test;
        test = (int64)x*x + (int64)y*y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 101, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        return (x*x + y*y) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 140 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h"
    void NormaliseSlow();
# 150 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h"
    void Normalise();





    CIwSVec2 GetNormalised() const;







    void NormaliseSafe();





    CIwSVec2 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 190 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwSVec2 const & v) const {return *this * v;}
# 219 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h"
    CIwSVec2& operator = (CIwSVec2 const & v);






    CIwSVec2 operator + (CIwSVec2 const & v) const;






    CIwSVec2 & operator += (CIwSVec2 const & v);






    CIwSVec2 operator - (CIwSVec2 const & v) const;






    CIwSVec2 & operator -= (CIwSVec2 const & v);






    int32 operator * (CIwSVec2 const & v) const;







    bool operator == (CIwSVec2 const & v) const;






    bool operator != (CIwSVec2 const & v) const;
# 282 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h"
    CIwSVec2 operator - () const;






    CIwSVec2 operator * (iwfixed l) const;







    CIwSVec2 & operator *= (iwfixed l);






    CIwSVec2 operator / (const iwfixed s) const;






    CIwSVec2 operator >> (const int s) const;







    CIwSVec2 operator >>= (const int s);






    CIwSVec2 operator << (const int s) const;







    CIwSVec2 operator <<= (const int s);






    int16 & operator [] (const int n);






    int16 operator [] (const int n) const;




};




inline CIwSVec2& CIwSVec2::operator = (CIwSVec2 const & v)
{
    x = v.x;
    y = v.y;
    return *this;
}




inline CIwSVec2 CIwSVec2::operator + (CIwSVec2 const & v) const
{

    int32 test;
    test = x + (int32)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator +"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 372, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y + (int32)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator +"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 373, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwSVec2(
        (int16)(x + v.x)
        , (int16)(y + v.y)
        );
}




inline CIwSVec2 & CIwSVec2::operator += (CIwSVec2 const & v)
{

    int32 test;
    test = x + (int32)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator +="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 388, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y + (int32)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator +="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 389, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x += v.x;
    y += v.y;
    return *this;
}




inline CIwSVec2 CIwSVec2::operator - (CIwSVec2 const & v) const
{

    int32 test;
    test = x - (int32)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator -"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 403, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y - (int32)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator -"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 404, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwSVec2(
        (int16)(x - v.x)
        , (int16)(y - v.y)
        );
}




inline CIwSVec2 & CIwSVec2::operator -= (CIwSVec2 const & v)
{

    int32 test;
    test = x - (int32)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator -="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 419, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y - (int32)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator -="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 420, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x -= v.x;
    y -= v.y;
    return *this;
}




inline int32 CIwSVec2::operator * (CIwSVec2 const & v) const
{

    int64 test = (
        (int64)x * v.x +
        (int64)y * v.y +
        0);

    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator *"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 438, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    (void) test;


    return (
        (int32)x * v.x +
        (int32)y * v.y +
        0) >> 12;
}




inline bool CIwSVec2::operator == (CIwSVec2 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        true);
}




inline bool CIwSVec2::operator != (CIwSVec2 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        false);
}




inline CIwSVec2 CIwSVec2::operator * (iwfixed l) const
{



    int32 test;
    test = ((int32)(x) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator *"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 479, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int32)(y) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator *"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 480, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


    return CIwSVec2(
          (int16)IW_FIXED_MUL(x,l)
        , (int16)IW_FIXED_MUL(y,l)
        );
}




inline CIwSVec2 & CIwSVec2::operator *= (iwfixed l)
{



    int32 test;
    test = ((int32)(x) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator *="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 498, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int32)(y) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator *="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 499, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


    x = (int16)IW_FIXED_MUL(x,l);
    y = (int16)IW_FIXED_MUL(y,l);
    return *this;
}




inline CIwSVec2 CIwSVec2::operator - () const
{
    return CIwSVec2(
        (int16)-x
        , (int16)-y
        );
}




inline CIwSVec2 CIwSVec2::operator / (const iwfixed s) const
{
    return CIwSVec2(
        (int16)(IW_FIXED_DIV(x, s))
        , (int16)(IW_FIXED_DIV(y, s))
        );
}




inline CIwSVec2 CIwSVec2::operator >> (const int s) const
{
    return CIwSVec2(
        (int16)(x >> s)
        , (int16)(y >> s)
        );
}

inline CIwSVec2 CIwSVec2::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    return *this;
}




inline CIwSVec2 CIwSVec2::operator << (const int s) const
{

    int32 test;
    test = (x << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator <<"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 554, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (y << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator <<"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 555, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwSVec2(
        (int16)(x << s)
        , (int16)(y << s)
        );
}

inline CIwSVec2 CIwSVec2::operator <<= (const int s)
{

    int32 test;
    test = (int32)(x) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator <<="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 567, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (int32)(y) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec2 overflow: operator <<="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 568, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x <<= s;
    y <<= s;
    return *this;
}


inline int16 & CIwSVec2::operator [] (const int n)
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 2)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 2 dimensional vector", n); switch (IwDebugAssertShow("n < 2", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 578, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}


inline int16 CIwSVec2::operator [] (const int n) const
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 2)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 2 dimensional vector", n); switch (IwDebugAssertShow("n < 2", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h", 585, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}





inline CIwSVec2 operator * (iwfixed l, const CIwSVec2& v)
{
    return v * l;
}





# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h" 1
       
# 33 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwVec2
{
public:
    int32 x;
    int32 y;


    static CIwVec2 g_Zero;


    static CIwVec2 g_AxisX;


    static CIwVec2 g_AxisY;




    CIwVec2() {};






    CIwVec2(int32 _x, int32 _y) : x(_x), y(_y) {};

    explicit CIwVec2(const CIwSVec2& v);
    explicit CIwVec2(const CIwFVec2& v);
    CIwVec2 operator = (const CIwSVec2& v);
    CIwVec2 operator = (const CIwFVec2& v);
# 90 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {


        int64 test;
        test = (int64)x*x + (int64)y*y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 101, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        return (x*x + y*y) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 140 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h"
    void NormaliseSlow();
# 150 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h"
    void Normalise();





    CIwVec2 GetNormalised() const;







    void NormaliseSafe();





    CIwVec2 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 190 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwVec2 const & v) const {return *this * v;}
# 219 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h"
    CIwVec2& operator = (CIwVec2 const & v);






    CIwVec2 operator + (CIwVec2 const & v) const;






    CIwVec2 & operator += (CIwVec2 const & v);






    CIwVec2 operator - (CIwVec2 const & v) const;






    CIwVec2 & operator -= (CIwVec2 const & v);






    int32 operator * (CIwVec2 const & v) const;







    bool operator == (CIwVec2 const & v) const;






    bool operator != (CIwVec2 const & v) const;
# 282 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h"
    CIwVec2 operator - () const;






    CIwVec2 operator * (iwfixed l) const;







    CIwVec2 & operator *= (iwfixed l);






    CIwVec2 operator / (const iwfixed s) const;






    CIwVec2 operator >> (const int s) const;







    CIwVec2 operator >>= (const int s);






    CIwVec2 operator << (const int s) const;







    CIwVec2 operator <<= (const int s);






    int32 & operator [] (const int n);






    int32 operator [] (const int n) const;




};




inline CIwVec2& CIwVec2::operator = (CIwVec2 const & v)
{
    x = v.x;
    y = v.y;
    return *this;
}




inline CIwVec2 CIwVec2::operator + (CIwVec2 const & v) const
{

    int64 test;
    test = x + (int64)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator +"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 372, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y + (int64)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator +"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 373, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwVec2(
        (int32)(x + v.x)
        , (int32)(y + v.y)
        );
}




inline CIwVec2 & CIwVec2::operator += (CIwVec2 const & v)
{

    int64 test;
    test = x + (int64)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator +="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 388, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y + (int64)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator +="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 389, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x += v.x;
    y += v.y;
    return *this;
}




inline CIwVec2 CIwVec2::operator - (CIwVec2 const & v) const
{

    int64 test;
    test = x - (int64)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator -"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 403, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y - (int64)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator -"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 404, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwVec2(
        (int32)(x - v.x)
        , (int32)(y - v.y)
        );
}




inline CIwVec2 & CIwVec2::operator -= (CIwVec2 const & v)
{

    int64 test;
    test = x - (int64)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator -="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 419, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y - (int64)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator -="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 420, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x -= v.x;
    y -= v.y;
    return *this;
}




inline int32 CIwVec2::operator * (CIwVec2 const & v) const
{

    int64 test = (
        (int64)x * v.x +
        (int64)y * v.y +
        0);

    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator *"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 438, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    (void) test;


    return (
        (int32)x * v.x +
        (int32)y * v.y +
        0) >> 12;
}




inline bool CIwVec2::operator == (CIwVec2 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        true);
}




inline bool CIwVec2::operator != (CIwVec2 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        false);
}




inline CIwVec2 CIwVec2::operator * (iwfixed l) const
{



    int64 test;
    test = ((int64)(x) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator *"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 479, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int64)(y) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator *"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 480, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


    return CIwVec2(
          (int32)IW_FIXED_MUL(x,l)
        , (int32)IW_FIXED_MUL(y,l)
        );
}




inline CIwVec2 & CIwVec2::operator *= (iwfixed l)
{



    int64 test;
    test = ((int64)(x) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator *="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 498, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int64)(y) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator *="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 499, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


    x = (int32)IW_FIXED_MUL(x,l);
    y = (int32)IW_FIXED_MUL(y,l);
    return *this;
}




inline CIwVec2 CIwVec2::operator - () const
{
    return CIwVec2(
        (int32)-x
        , (int32)-y
        );
}




inline CIwVec2 CIwVec2::operator / (const iwfixed s) const
{
    return CIwVec2(
        (int32)(IW_FIXED_DIV(x, s))
        , (int32)(IW_FIXED_DIV(y, s))
        );
}




inline CIwVec2 CIwVec2::operator >> (const int s) const
{
    return CIwVec2(
        (int32)(x >> s)
        , (int32)(y >> s)
        );
}

inline CIwVec2 CIwVec2::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    return *this;
}




inline CIwVec2 CIwVec2::operator << (const int s) const
{

    int64 test;
    test = (x << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator <<"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 554, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (y << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator <<"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 555, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwVec2(
        (int32)(x << s)
        , (int32)(y << s)
        );
}

inline CIwVec2 CIwVec2::operator <<= (const int s)
{

    int64 test;
    test = (int64)(x) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator <<="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 567, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (int64)(y) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec2 overflow: operator <<="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 568, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x <<= s;
    y <<= s;
    return *this;
}


inline int32 & CIwVec2::operator [] (const int n)
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 2)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 2 dimensional vector", n); switch (IwDebugAssertShow("n < 2", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 578, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}


inline int32 CIwVec2::operator [] (const int n) const
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 2)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 2 dimensional vector", n); switch (IwDebugAssertShow("n < 2", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h", 585, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}





inline CIwVec2 operator * (iwfixed l, const CIwVec2& v)
{
    return v * l;
}







inline CIwVec2::CIwVec2(const CIwSVec2& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
}

inline CIwVec2 CIwVec2::operator = (const CIwSVec2& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
    return *this;
}


inline bool operator == (const CIwVec2& v1, const CIwSVec2& v2)
{
    return (
        v1.x == (int32)v2.x &&
        v1.y == (int32)v2.y &&
        true);
}


inline CIwVec2 operator + (const CIwVec2& v1, const CIwSVec2& v2)
{
    return CIwVec2(
        v1.x + (int32)v2.x
        , v1.y + (int32)v2.y
        );
}


inline CIwVec2 operator - (const CIwVec2& v1, const CIwSVec2& v2)
{
    return CIwVec2(
        v1.x - (int32)v2.x
        , v1.y - (int32)v2.y
        );
}




inline CIwVec2 operator += (CIwVec2& v1, const CIwSVec2& v2)
{
    v1.x += (int32)v2.x;
    v1.y += (int32)v2.y;
    return v1;
}




inline CIwVec2 operator -= (CIwVec2& v1, const CIwSVec2& v2)
{
    v1.x -= (int32)v2.x;
    v1.y -= (int32)v2.y;
    return v1;
}




inline int32 operator * (const CIwVec2& v1, const CIwSVec2& v2)
{
    return v1 * CIwVec2(v2);
}






# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec2.h" 1
       
# 33 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec2.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwFVec2
{
public:
    float x;
    float y;


    static CIwFVec2 g_Zero;


    static CIwFVec2 g_AxisX;


    static CIwFVec2 g_AxisY;




    CIwFVec2() {};






    CIwFVec2(float _x, float _y) : x(_x), y(_y) {};

    explicit CIwFVec2(const CIwSVec2& v);
    explicit CIwFVec2(const CIwVec2& v);
    CIwFVec2 operator = (const CIwSVec2& v);
    CIwFVec2 operator = (const CIwVec2& v);
# 90 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec2.h"
    float GetLength() const;





    inline float GetLengthSquared() const
    {

        return (x*x + y*y);
    }
# 117 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec2.h"
    void Normalise();






    CIwFVec2 GetNormalised() const;







    bool IsNormalised() const;
# 145 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec2.h"
    void Serialise(void);





    bool IsZero() const;






    inline float Dot(CIwFVec2 const & v) const {return *this * v;}
# 174 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec2.h"
    CIwFVec2& operator = (CIwFVec2 const & v);






    CIwFVec2 operator + (CIwFVec2 const & v) const;






    CIwFVec2 & operator += (CIwFVec2 const & v);






    CIwFVec2 operator - (CIwFVec2 const & v) const;






    CIwFVec2 & operator -= (CIwFVec2 const & v);






    float operator * (CIwFVec2 const & v) const;







    bool operator == (CIwFVec2 const & v) const;






    bool operator != (CIwFVec2 const & v) const;
# 237 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec2.h"
    CIwFVec2 operator - () const;






    CIwFVec2 operator * (float l) const;







    CIwFVec2 & operator *= (float l);






    CIwFVec2 operator / (const float s) const;







    float & operator [] (const int n);






    float operator [] (const int n) const;




};




inline CIwFVec2& CIwFVec2::operator = (CIwFVec2 const & v)
{
    x = v.x;
    y = v.y;
    return *this;
}




inline CIwFVec2 CIwFVec2::operator + (CIwFVec2 const & v) const
{
    return CIwFVec2(
        (float)(x + v.x)
        , (float)(y + v.y)
        );
}




inline CIwFVec2 & CIwFVec2::operator += (CIwFVec2 const & v)
{
    x += v.x;
    y += v.y;
    return *this;
}




inline CIwFVec2 CIwFVec2::operator - (CIwFVec2 const & v) const
{
    return CIwFVec2(
        (float)(x - v.x)
        , (float)(y - v.y)
        );
}




inline CIwFVec2 & CIwFVec2::operator -= (CIwFVec2 const & v)
{
    x -= v.x;
    y -= v.y;
    return *this;
}




inline float CIwFVec2::operator * (CIwFVec2 const & v) const
{

    return (
        (float)x * v.x +
        (float)y * v.y +
        0);
}




inline bool CIwFVec2::operator == (CIwFVec2 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        true);
}




inline bool CIwFVec2::operator != (CIwFVec2 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        false);
}




inline CIwFVec2 CIwFVec2::operator * (float l) const
{
    return CIwFVec2(
        (float)(x * l)
        , (float)(y * l)
        );
}




inline CIwFVec2 & CIwFVec2::operator *= (float l)
{
    x = (float)(x * l);
    y = (float)(y * l);
    return *this;
}




inline CIwFVec2 CIwFVec2::operator - () const
{
    return CIwFVec2(
        (float)-x
        , (float)-y
        );
}




inline CIwFVec2 CIwFVec2::operator / (const float s) const
{
    return CIwFVec2(
        (float)(x / s)
        , (float)(y / s)
        );
}


inline float & CIwFVec2::operator [] (const int n)
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 2)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 2 dimensional vector", n); switch (IwDebugAssertShow("n < 2", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec2.h", 413, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}


inline float CIwFVec2::operator [] (const int n) const
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 2)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 2 dimensional vector", n); switch (IwDebugAssertShow("n < 2", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec2.h", 420, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}





inline CIwFVec2 operator * (float l, const CIwFVec2& v)
{
    return v * l;
}







inline CIwFVec2::CIwFVec2(const CIwSVec2& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
}

inline CIwFVec2 CIwFVec2::operator = (const CIwSVec2& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    return *this;
}


inline bool operator == (const CIwFVec2& v1, const CIwSVec2& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        true);
}


inline CIwFVec2 operator + (const CIwFVec2& v1, const CIwSVec2& v2)
{
    return CIwFVec2(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        );
}


inline CIwFVec2 operator - (const CIwFVec2& v1, const CIwSVec2& v2)
{
    return CIwFVec2(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        );
}




inline CIwFVec2 operator += (CIwFVec2& v1, const CIwSVec2& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    return v1;
}




inline CIwFVec2 operator -= (CIwFVec2& v1, const CIwSVec2& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec2& v1, const CIwSVec2& v2)
{
    return v1 * CIwFVec2(v2);
}
# 514 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec2.h"
inline CIwFVec2::CIwFVec2(const CIwVec2& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
}




inline CIwFVec2 CIwFVec2::operator = (const CIwVec2& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    return *this;
}




inline bool operator == (const CIwFVec2& v1, const CIwVec2& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        true);
}




inline CIwFVec2 operator + (const CIwFVec2& v1, const CIwVec2& v2)
{
    return CIwFVec2(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        );
}




inline CIwFVec2 operator - (const CIwFVec2& v1, const CIwVec2& v2)
{
    return CIwFVec2(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        );
}




inline CIwFVec2 operator += (CIwFVec2& v1, const CIwVec2& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    return v1;
}




inline CIwFVec2 operator -= (CIwFVec2& v1, const CIwVec2& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec2& v1, const CIwVec2& v2)
{
    return v1 * CIwFVec2(v2);
}
# 678 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec2.h" 2

inline CIwVec2::CIwVec2(const CIwFVec2& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
}




inline CIwVec2 CIwVec2::operator = (const CIwFVec2& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
    return *this;
}




inline bool operator == (const CIwVec2& v1, const CIwFVec2& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        true);
}




inline CIwFVec2 operator + (const CIwVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        );
}




inline CIwFVec2 operator - (const CIwVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        );
}




inline CIwVec2 operator += (CIwVec2& v1, const CIwFVec2& v2)
{
    v1.x += IW_FIXED_FROM_FLOAT(v2.x);
    v1.y += IW_FIXED_FROM_FLOAT(v2.y);
    return v1;
}




inline CIwVec2 operator -= (CIwVec2& v1, const CIwFVec2& v2)
{
    v1.x -= IW_FIXED_FROM_FLOAT(v2.x);
    v1.y -= IW_FIXED_FROM_FLOAT(v2.y);
    return v1;
}




inline float operator * (const CIwVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(v1) * v2;
}
# 603 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h" 2

inline CIwSVec2::CIwSVec2(const CIwVec2& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
}

inline CIwSVec2 CIwSVec2::operator = (const CIwVec2& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
    return *this;
}


inline bool operator == (const CIwSVec2& v1, const CIwVec2& v2)
{
    return (
        (int32)v1.x == v2.x &&
        (int32)v1.y == v2.y &&
        true);
}


inline CIwVec2 operator + (const CIwSVec2& v1, const CIwVec2& v2)
{
    return CIwVec2(
        (int32)v1.x + v2.x
        , (int32)v1.y + v2.y
        );
}


inline CIwVec2 operator - (const CIwSVec2& v1, const CIwVec2& v2)
{
    return CIwVec2(
        (int32)v1.x - v2.x
        , (int32)v1.y - v2.y
        );
}




inline CIwSVec2 operator += (CIwSVec2& v1, const CIwVec2& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(v2.x);
    v1.y += IW_SFIXED_FROM_FIXED(v2.y);
    return v1;
}




inline CIwSVec2 operator -= (CIwSVec2& v1, const CIwVec2& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(v2.x);
    v1.y -= IW_SFIXED_FROM_FIXED(v2.y);
    return v1;
}




inline int32 operator * (const CIwSVec2& v1, const CIwVec2& v2)
{
    return CIwVec2(v1) * v2;
}
# 679 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec2.h"
inline CIwSVec2::CIwSVec2(const CIwFVec2& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
}




inline CIwSVec2 CIwSVec2::operator = (const CIwFVec2& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
    return *this;
}




inline bool operator == (const CIwSVec2& v1, const CIwFVec2& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        true);
}




inline CIwFVec2 operator + (const CIwSVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        );
}




inline CIwFVec2 operator - (const CIwSVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        );
}




inline CIwSVec2 operator += (CIwSVec2& v1, const CIwFVec2& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    return v1;
}




inline CIwSVec2 operator -= (CIwSVec2& v1, const CIwFVec2& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    return v1;
}




inline float operator * (const CIwSVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(v1) * v2;
}
# 34 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec.h" 2
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h" 1
       
# 33 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwSVec3
{
public:
    int16 x;
    int16 y;
    int16 z;


    static CIwSVec3 g_Zero;


    static CIwSVec3 g_AxisX;


    static CIwSVec3 g_AxisY;


    static CIwSVec3 g_AxisZ;




    CIwSVec3() {};
# 79 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h"
    CIwSVec3(int16 _x, int16 _y, int16 _z) : x(_x), y(_y), z(_z) {};

    explicit CIwSVec3(const CIwVec3& v);
    explicit CIwSVec3(const CIwFVec3& v);
    CIwSVec3 operator = (const CIwVec3& v);
    CIwSVec3 operator = (const CIwFVec3& v);
# 97 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {


        int64 test;
        test = (int64)x*x + (int64)y*y+ (int64)z*z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 108, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        return (x*x + y*y+ z*z) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 147 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h"
    void NormaliseSlow();
# 157 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h"
    void Normalise();





    CIwSVec3 GetNormalised() const;







    void NormaliseSafe();





    CIwSVec3 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 197 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwSVec3 const & v) const {return *this * v;}






    inline CIwSVec3 Cross(CIwSVec3 const & v) const {return *this ^ v;}
# 234 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h"
    CIwSVec3& operator = (CIwSVec3 const & v);






    CIwSVec3 operator + (CIwSVec3 const & v) const;






    CIwSVec3 & operator += (CIwSVec3 const & v);






    CIwSVec3 operator - (CIwSVec3 const & v) const;






    CIwSVec3 & operator -= (CIwSVec3 const & v);






    int32 operator * (CIwSVec3 const & v) const;






    CIwSVec3 operator ^ (CIwSVec3 const & v) const;






    bool operator == (CIwSVec3 const & v) const;






    bool operator != (CIwSVec3 const & v) const;
# 303 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h"
    CIwSVec3 operator - () const;






    CIwSVec3 operator * (iwfixed l) const;







    CIwSVec3 & operator *= (iwfixed l);






    CIwSVec3 operator / (const iwfixed s) const;






    CIwSVec3 operator >> (const int s) const;







    CIwSVec3 operator >>= (const int s);






    CIwSVec3 operator << (const int s) const;







    CIwSVec3 operator <<= (const int s);






    int16 & operator [] (const int n);






    int16 operator [] (const int n) const;




};




inline CIwSVec3& CIwSVec3::operator = (CIwSVec3 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    return *this;
}




inline CIwSVec3 CIwSVec3::operator + (CIwSVec3 const & v) const
{

    int32 test;
    test = x + (int32)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator +"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 394, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y + (int32)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator +"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 395, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z + (int32)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator +"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 396, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwSVec3(
        (int16)(x + v.x)
        , (int16)(y + v.y)
        , (int16)(z + v.z)
        );
}




inline CIwSVec3 & CIwSVec3::operator += (CIwSVec3 const & v)
{

    int32 test;
    test = x + (int32)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator +="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 412, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y + (int32)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator +="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 413, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z + (int32)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator +="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 414, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}




inline CIwSVec3 CIwSVec3::operator - (CIwSVec3 const & v) const
{

    int32 test;
    test = x - (int32)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator -"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 429, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y - (int32)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator -"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 430, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z - (int32)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator -"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 431, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwSVec3(
        (int16)(x - v.x)
        , (int16)(y - v.y)
        , (int16)(z - v.z)
        );
}




inline CIwSVec3 & CIwSVec3::operator -= (CIwSVec3 const & v)
{

    int32 test;
    test = x - (int32)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator -="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 447, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y - (int32)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator -="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 448, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z - (int32)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator -="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 449, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}




inline int32 CIwSVec3::operator * (CIwSVec3 const & v) const
{

    int64 test = (
        (int64)x * v.x +
        (int64)y * v.y +
        (int64)z * v.z +
        0);

    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator *"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 469, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    (void) test;


    return (
        (int32)x * v.x +
        (int32)y * v.y +
        (int32)z * v.z +
        0) >> 12;
}



inline CIwSVec3 CIwSVec3::operator ^ (CIwSVec3 const & v) const
{

    int chk = ((((x) > 0) ? (x) : -(x)) | (((y) > 0) ? (y) : -(y)) | (((z) > 0) ? (z) : -(z)) | (((v.x) > 0) ? (v.x) : -(v.x)) | (((v.y) > 0) ? (v.y) : -(v.y)) | (((v.z) > 0) ? (v.z) : -(v.z)));
    if (chk > (1<<15))
    {




        int64 test;
        test = ((int64)y*v.z - (int64)z*v.y)>>12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator ^"); switch (IwDebugAssertShow("test >> 63 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 493, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)z*v.x - (int64)x*v.z)>>12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator ^"); switch (IwDebugAssertShow("test >> 63 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 494, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)x*v.y - (int64)y*v.x)>>12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator ^"); switch (IwDebugAssertShow("test >> 63 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 495, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        return CIwSVec3( (int16)(((int64)y*v.z + (int64)z*-v.y)>>12),
                        (int16)(((int64)z*v.x + (int64)x*-v.z)>>12),
                        (int16)(((int64)x*v.y + (int64)y*-v.x)>>12) );
    }
    else
    {




        int64 test;
        test = ((int64)y*v.z)>>0; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator ^"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 508, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)z*v.y)>>0; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator ^"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 509, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)z*v.x)>>0; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator ^"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 510, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)x*v.z)>>0; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator ^"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 511, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)y*v.x)>>0; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator ^"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 512, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)x*v.y)>>0; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator ^"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 513, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        test = ((int64)y*v.z - (int64)z*v.y)>>12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator ^"); switch (IwDebugAssertShow("test >> 63 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 515, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)z*v.x - (int64)x*v.z)>>12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator ^"); switch (IwDebugAssertShow("test >> 63 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 516, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)x*v.y - (int64)y*v.x)>>12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator ^"); switch (IwDebugAssertShow("test >> 63 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 517, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


        return CIwSVec3( (int16)(((int32)y*v.z + (int32)z*-v.y)>>12),
                        (int16)(((int32)z*v.x + (int32)x*-v.z)>>12),
                        (int16)(((int32)x*v.y + (int32)y*-v.x)>>12) );
    }
}




inline bool CIwSVec3::operator == (CIwSVec3 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        true);
}




inline bool CIwSVec3::operator != (CIwSVec3 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        false);
}




inline CIwSVec3 CIwSVec3::operator * (iwfixed l) const
{



    int32 test;
    test = ((int32)(x) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator *"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 559, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int32)(y) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator *"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 560, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int32)(z) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator *"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 561, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


    return CIwSVec3(
          (int16)IW_FIXED_MUL(x,l)
        , (int16)IW_FIXED_MUL(y,l)
        , (int16)IW_FIXED_MUL(z,l)
        );
}




inline CIwSVec3 & CIwSVec3::operator *= (iwfixed l)
{



    int32 test;
    test = ((int32)(x) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator *="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 580, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int32)(y) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator *="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 581, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int32)(z) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator *="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 582, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


    x = (int16)IW_FIXED_MUL(x,l);
    y = (int16)IW_FIXED_MUL(y,l);
    z = (int16)IW_FIXED_MUL(z,l);
    return *this;
}




inline CIwSVec3 CIwSVec3::operator - () const
{
    return CIwSVec3(
        (int16)-x
        , (int16)-y
        , (int16)-z
        );
}




inline CIwSVec3 CIwSVec3::operator / (const iwfixed s) const
{
    return CIwSVec3(
        (int16)(IW_FIXED_DIV(x, s))
        , (int16)(IW_FIXED_DIV(y, s))
        , (int16)(IW_FIXED_DIV(z, s))
        );
}




inline CIwSVec3 CIwSVec3::operator >> (const int s) const
{
    return CIwSVec3(
        (int16)(x >> s)
        , (int16)(y >> s)
        , (int16)(z >> s)
        );
}

inline CIwSVec3 CIwSVec3::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    z >>= s;
    return *this;
}




inline CIwSVec3 CIwSVec3::operator << (const int s) const
{

    int32 test;
    test = (x << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator <<"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 642, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (y << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator <<"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 643, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (z << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator <<"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 644, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwSVec3(
        (int16)(x << s)
        , (int16)(y << s)
        , (int16)(z << s)
        );
}

inline CIwSVec3 CIwSVec3::operator <<= (const int s)
{

    int32 test;
    test = (int32)(x) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator <<="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 657, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (int32)(y) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator <<="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 658, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x <<= s;
    y <<= s;

    test = (int32)(z) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec3 overflow: operator <<="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 663, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    z <<= s;
    return *this;
}


inline int16 & CIwSVec3::operator [] (const int n)
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 3)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 3 dimensional vector", n); switch (IwDebugAssertShow("n < 3", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 672, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}


inline int16 CIwSVec3::operator [] (const int n) const
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 3)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 3 dimensional vector", n); switch (IwDebugAssertShow("n < 3", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h", 679, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}





inline CIwSVec3 operator * (iwfixed l, const CIwSVec3& v)
{
    return v * l;
}





# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h" 1
       
# 33 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwVec3
{
public:
    int32 x;
    int32 y;
    int32 z;


    static CIwVec3 g_Zero;


    static CIwVec3 g_AxisX;


    static CIwVec3 g_AxisY;


    static CIwVec3 g_AxisZ;




    CIwVec3() {};
# 79 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h"
    CIwVec3(int32 _x, int32 _y, int32 _z) : x(_x), y(_y), z(_z) {};

    explicit CIwVec3(const CIwSVec3& v);
    explicit CIwVec3(const CIwFVec3& v);
    CIwVec3 operator = (const CIwSVec3& v);
    CIwVec3 operator = (const CIwFVec3& v);
# 97 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {


        int64 test;
        test = (int64)x*x + (int64)y*y+ (int64)z*z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 108, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        return (x*x + y*y+ z*z) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 147 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h"
    void NormaliseSlow();
# 157 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h"
    void Normalise();





    CIwVec3 GetNormalised() const;







    void NormaliseSafe();





    CIwVec3 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 197 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwVec3 const & v) const {return *this * v;}






    inline CIwVec3 Cross(CIwVec3 const & v) const {return *this ^ v;}
# 234 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h"
    CIwVec3& operator = (CIwVec3 const & v);






    CIwVec3 operator + (CIwVec3 const & v) const;






    CIwVec3 & operator += (CIwVec3 const & v);






    CIwVec3 operator - (CIwVec3 const & v) const;






    CIwVec3 & operator -= (CIwVec3 const & v);






    int32 operator * (CIwVec3 const & v) const;






    CIwVec3 operator ^ (CIwVec3 const & v) const;






    bool operator == (CIwVec3 const & v) const;






    bool operator != (CIwVec3 const & v) const;
# 303 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h"
    CIwVec3 operator - () const;






    CIwVec3 operator * (iwfixed l) const;







    CIwVec3 & operator *= (iwfixed l);






    CIwVec3 operator / (const iwfixed s) const;






    CIwVec3 operator >> (const int s) const;







    CIwVec3 operator >>= (const int s);






    CIwVec3 operator << (const int s) const;







    CIwVec3 operator <<= (const int s);






    int32 & operator [] (const int n);






    int32 operator [] (const int n) const;




};




inline CIwVec3& CIwVec3::operator = (CIwVec3 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    return *this;
}




inline CIwVec3 CIwVec3::operator + (CIwVec3 const & v) const
{

    int64 test;
    test = x + (int64)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator +"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 394, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y + (int64)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator +"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 395, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z + (int64)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator +"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 396, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwVec3(
        (int32)(x + v.x)
        , (int32)(y + v.y)
        , (int32)(z + v.z)
        );
}




inline CIwVec3 & CIwVec3::operator += (CIwVec3 const & v)
{

    int64 test;
    test = x + (int64)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator +="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 412, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y + (int64)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator +="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 413, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z + (int64)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator +="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 414, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}




inline CIwVec3 CIwVec3::operator - (CIwVec3 const & v) const
{

    int64 test;
    test = x - (int64)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator -"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 429, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y - (int64)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator -"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 430, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z - (int64)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator -"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 431, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwVec3(
        (int32)(x - v.x)
        , (int32)(y - v.y)
        , (int32)(z - v.z)
        );
}




inline CIwVec3 & CIwVec3::operator -= (CIwVec3 const & v)
{

    int64 test;
    test = x - (int64)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator -="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 447, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y - (int64)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator -="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 448, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z - (int64)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator -="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 449, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}




inline int32 CIwVec3::operator * (CIwVec3 const & v) const
{

    int64 test = (
        (int64)x * v.x +
        (int64)y * v.y +
        (int64)z * v.z +
        0);

    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator *"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 469, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    (void) test;


    return (
        (int32)x * v.x +
        (int32)y * v.y +
        (int32)z * v.z +
        0) >> 12;
}



inline CIwVec3 CIwVec3::operator ^ (CIwVec3 const & v) const
{

    int chk = ((((x) > 0) ? (x) : -(x)) | (((y) > 0) ? (y) : -(y)) | (((z) > 0) ? (z) : -(z)) | (((v.x) > 0) ? (v.x) : -(v.x)) | (((v.y) > 0) ? (v.y) : -(v.y)) | (((v.z) > 0) ? (v.z) : -(v.z)));
    if (chk > (1<<15))
    {




        int64 test;
        test = ((int64)y*v.z - (int64)z*v.y)>>12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator ^"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 493, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)z*v.x - (int64)x*v.z)>>12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator ^"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 494, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)x*v.y - (int64)y*v.x)>>12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator ^"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 495, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        return CIwVec3( (int32)(((int64)y*v.z + (int64)z*-v.y)>>12),
                        (int32)(((int64)z*v.x + (int64)x*-v.z)>>12),
                        (int32)(((int64)x*v.y + (int64)y*-v.x)>>12) );
    }
    else
    {




        int64 test;
        test = ((int64)y*v.z)>>0; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator ^"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 508, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)z*v.y)>>0; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator ^"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 509, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)z*v.x)>>0; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator ^"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 510, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)x*v.z)>>0; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator ^"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 511, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)y*v.x)>>0; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator ^"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 512, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)x*v.y)>>0; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator ^"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 513, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        test = ((int64)y*v.z - (int64)z*v.y)>>12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator ^"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 515, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)z*v.x - (int64)x*v.z)>>12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator ^"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 516, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = ((int64)x*v.y - (int64)y*v.x)>>12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator ^"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 517, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


        return CIwVec3( (int32)(((int32)y*v.z + (int32)z*-v.y)>>12),
                        (int32)(((int32)z*v.x + (int32)x*-v.z)>>12),
                        (int32)(((int32)x*v.y + (int32)y*-v.x)>>12) );
    }
}




inline bool CIwVec3::operator == (CIwVec3 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        true);
}




inline bool CIwVec3::operator != (CIwVec3 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        false);
}




inline CIwVec3 CIwVec3::operator * (iwfixed l) const
{



    int64 test;
    test = ((int64)(x) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator *"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 559, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int64)(y) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator *"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 560, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int64)(z) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator *"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 561, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


    return CIwVec3(
          (int32)IW_FIXED_MUL(x,l)
        , (int32)IW_FIXED_MUL(y,l)
        , (int32)IW_FIXED_MUL(z,l)
        );
}




inline CIwVec3 & CIwVec3::operator *= (iwfixed l)
{



    int64 test;
    test = ((int64)(x) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator *="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 580, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int64)(y) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator *="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 581, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int64)(z) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator *="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 582, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


    x = (int32)IW_FIXED_MUL(x,l);
    y = (int32)IW_FIXED_MUL(y,l);
    z = (int32)IW_FIXED_MUL(z,l);
    return *this;
}




inline CIwVec3 CIwVec3::operator - () const
{
    return CIwVec3(
        (int32)-x
        , (int32)-y
        , (int32)-z
        );
}




inline CIwVec3 CIwVec3::operator / (const iwfixed s) const
{
    return CIwVec3(
        (int32)(IW_FIXED_DIV(x, s))
        , (int32)(IW_FIXED_DIV(y, s))
        , (int32)(IW_FIXED_DIV(z, s))
        );
}




inline CIwVec3 CIwVec3::operator >> (const int s) const
{
    return CIwVec3(
        (int32)(x >> s)
        , (int32)(y >> s)
        , (int32)(z >> s)
        );
}

inline CIwVec3 CIwVec3::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    z >>= s;
    return *this;
}




inline CIwVec3 CIwVec3::operator << (const int s) const
{

    int64 test;
    test = (x << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator <<"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 642, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (y << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator <<"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 643, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (z << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator <<"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 644, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwVec3(
        (int32)(x << s)
        , (int32)(y << s)
        , (int32)(z << s)
        );
}

inline CIwVec3 CIwVec3::operator <<= (const int s)
{

    int64 test;
    test = (int64)(x) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator <<="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 657, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (int64)(y) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator <<="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 658, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x <<= s;
    y <<= s;

    test = (int64)(z) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec3 overflow: operator <<="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 663, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    z <<= s;
    return *this;
}


inline int32 & CIwVec3::operator [] (const int n)
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 3)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 3 dimensional vector", n); switch (IwDebugAssertShow("n < 3", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 672, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}


inline int32 CIwVec3::operator [] (const int n) const
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 3)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 3 dimensional vector", n); switch (IwDebugAssertShow("n < 3", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h", 679, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}





inline CIwVec3 operator * (iwfixed l, const CIwVec3& v)
{
    return v * l;
}







inline CIwVec3::CIwVec3(const CIwSVec3& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
    z = (int32)v.z;
}

inline CIwVec3 CIwVec3::operator = (const CIwSVec3& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
    z = (int32)v.z;
    return *this;
}


inline bool operator == (const CIwVec3& v1, const CIwSVec3& v2)
{
    return (
        v1.x == (int32)v2.x &&
        v1.y == (int32)v2.y &&
        v1.z == (int32)v2.z &&
        true);
}


inline CIwVec3 operator + (const CIwVec3& v1, const CIwSVec3& v2)
{
    return CIwVec3(
        v1.x + (int32)v2.x
        , v1.y + (int32)v2.y
        , v1.z + (int32)v2.z
        );
}


inline CIwVec3 operator - (const CIwVec3& v1, const CIwSVec3& v2)
{
    return CIwVec3(
        v1.x - (int32)v2.x
        , v1.y - (int32)v2.y
        , v1.z - (int32)v2.z
        );
}




inline CIwVec3 operator += (CIwVec3& v1, const CIwSVec3& v2)
{
    v1.x += (int32)v2.x;
    v1.y += (int32)v2.y;
    v1.z += (int32)v2.z;
    return v1;
}




inline CIwVec3 operator -= (CIwVec3& v1, const CIwSVec3& v2)
{
    v1.x -= (int32)v2.x;
    v1.y -= (int32)v2.y;
    v1.z -= (int32)v2.z;
    return v1;
}




inline int32 operator * (const CIwVec3& v1, const CIwSVec3& v2)
{
    return v1 * CIwVec3(v2);
}




inline CIwVec3 operator ^ (const CIwVec3& v1, const CIwSVec3& v2)
{
    return v1 ^ CIwVec3(v2);
}





# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec3.h" 1
       
# 33 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec3.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwFVec3
{
public:
    float x;
    float y;
    float z;


    static CIwFVec3 g_Zero;


    static CIwFVec3 g_AxisX;


    static CIwFVec3 g_AxisY;


    static CIwFVec3 g_AxisZ;




    CIwFVec3() {};
# 79 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec3.h"
    CIwFVec3(float _x, float _y, float _z) : x(_x), y(_y), z(_z) {};

    explicit CIwFVec3(const CIwSVec3& v);
    explicit CIwFVec3(const CIwVec3& v);
    CIwFVec3 operator = (const CIwSVec3& v);
    CIwFVec3 operator = (const CIwVec3& v);
# 97 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec3.h"
    float GetLength() const;





    inline float GetLengthSquared() const
    {

        return (x*x + y*y+ z*z);
    }
# 124 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec3.h"
    void Normalise();






    CIwFVec3 GetNormalised() const;







    bool IsNormalised() const;
# 152 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec3.h"
    void Serialise(void);





    bool IsZero() const;






    inline float Dot(CIwFVec3 const & v) const {return *this * v;}






    inline CIwFVec3 Cross(CIwFVec3 const & v) const {return *this ^ v;}
# 189 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec3.h"
    CIwFVec3& operator = (CIwFVec3 const & v);






    CIwFVec3 operator + (CIwFVec3 const & v) const;






    CIwFVec3 & operator += (CIwFVec3 const & v);






    CIwFVec3 operator - (CIwFVec3 const & v) const;






    CIwFVec3 & operator -= (CIwFVec3 const & v);






    float operator * (CIwFVec3 const & v) const;






    CIwFVec3 operator ^ (CIwFVec3 const & v) const;






    bool operator == (CIwFVec3 const & v) const;






    bool operator != (CIwFVec3 const & v) const;
# 258 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec3.h"
    CIwFVec3 operator - () const;






    CIwFVec3 operator * (float l) const;







    CIwFVec3 & operator *= (float l);






    CIwFVec3 operator / (const float s) const;







    float & operator [] (const int n);






    float operator [] (const int n) const;




};




inline CIwFVec3& CIwFVec3::operator = (CIwFVec3 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    return *this;
}




inline CIwFVec3 CIwFVec3::operator + (CIwFVec3 const & v) const
{
    return CIwFVec3(
        (float)(x + v.x)
        , (float)(y + v.y)
        , (float)(z + v.z)
        );
}




inline CIwFVec3 & CIwFVec3::operator += (CIwFVec3 const & v)
{
    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}




inline CIwFVec3 CIwFVec3::operator - (CIwFVec3 const & v) const
{
    return CIwFVec3(
        (float)(x - v.x)
        , (float)(y - v.y)
        , (float)(z - v.z)
        );
}




inline CIwFVec3 & CIwFVec3::operator -= (CIwFVec3 const & v)
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}




inline float CIwFVec3::operator * (CIwFVec3 const & v) const
{

    return (
        (float)x * v.x +
        (float)y * v.y +
        (float)z * v.z +
        0);
}



inline CIwFVec3 CIwFVec3::operator ^ (CIwFVec3 const & v) const
{
    return CIwFVec3((y * v.z - z * v.y),
                (z * v.x - x * v.z),
                (x * v.y - y * v.x));
}




inline bool CIwFVec3::operator == (CIwFVec3 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        true);
}




inline bool CIwFVec3::operator != (CIwFVec3 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        false);
}




inline CIwFVec3 CIwFVec3::operator * (float l) const
{
    return CIwFVec3(
        (float)(x * l)
        , (float)(y * l)
        , (float)(z * l)
        );
}




inline CIwFVec3 & CIwFVec3::operator *= (float l)
{
    x = (float)(x * l);
    y = (float)(y * l);
    z = (float)(z * l);
    return *this;
}




inline CIwFVec3 CIwFVec3::operator - () const
{
    return CIwFVec3(
        (float)-x
        , (float)-y
        , (float)-z
        );
}




inline CIwFVec3 CIwFVec3::operator / (const float s) const
{
    return CIwFVec3(
        (float)(x / s)
        , (float)(y / s)
        , (float)(z / s)
        );
}


inline float & CIwFVec3::operator [] (const int n)
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 3)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 3 dimensional vector", n); switch (IwDebugAssertShow("n < 3", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec3.h", 455, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}


inline float CIwFVec3::operator [] (const int n) const
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 3)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 3 dimensional vector", n); switch (IwDebugAssertShow("n < 3", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec3.h", 462, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}





inline CIwFVec3 operator * (float l, const CIwFVec3& v)
{
    return v * l;
}







inline CIwFVec3::CIwFVec3(const CIwSVec3& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
}

inline CIwFVec3 CIwFVec3::operator = (const CIwSVec3& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    return *this;
}


inline bool operator == (const CIwFVec3& v1, const CIwSVec3& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        v1.z == ((float)(v2.z) / (float)(1 << 12)) &&
        true);
}


inline CIwFVec3 operator + (const CIwFVec3& v1, const CIwSVec3& v2)
{
    return CIwFVec3(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        , v1.z + ((float)(v2.z) / (float)(1 << 12))
        );
}


inline CIwFVec3 operator - (const CIwFVec3& v1, const CIwSVec3& v2)
{
    return CIwFVec3(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        , v1.z - ((float)(v2.z) / (float)(1 << 12))
        );
}




inline CIwFVec3 operator += (CIwFVec3& v1, const CIwSVec3& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    v1.z += ((float)(v2.z) / (float)(1 << 12));
    return v1;
}




inline CIwFVec3 operator -= (CIwFVec3& v1, const CIwSVec3& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    v1.z -= ((float)(v2.z) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec3& v1, const CIwSVec3& v2)
{
    return v1 * CIwFVec3(v2);
}




inline CIwFVec3 operator ^ (const CIwFVec3& v1, const CIwSVec3& v2)
{
    return v1 ^ CIwFVec3(v2);
}







inline CIwFVec3::CIwFVec3(const CIwVec3& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
}




inline CIwFVec3 CIwFVec3::operator = (const CIwVec3& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    return *this;
}




inline bool operator == (const CIwFVec3& v1, const CIwVec3& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        v1.z == ((float)(v2.z) / (float)(1 << 12)) &&
        true);
}




inline CIwFVec3 operator + (const CIwFVec3& v1, const CIwVec3& v2)
{
    return CIwFVec3(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        , v1.z + ((float)(v2.z) / (float)(1 << 12))
        );
}




inline CIwFVec3 operator - (const CIwFVec3& v1, const CIwVec3& v2)
{
    return CIwFVec3(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        , v1.z - ((float)(v2.z) / (float)(1 << 12))
        );
}




inline CIwFVec3 operator += (CIwFVec3& v1, const CIwVec3& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    v1.z += ((float)(v2.z) / (float)(1 << 12));
    return v1;
}




inline CIwFVec3 operator -= (CIwFVec3& v1, const CIwVec3& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    v1.z -= ((float)(v2.z) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec3& v1, const CIwVec3& v2)
{
    return v1 * CIwFVec3(v2);
}




inline CIwFVec3 operator ^ (const CIwFVec3& v1, const CIwVec3& v2)
{
    return v1 ^ CIwFVec3(v2);
}
# 786 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec3.h" 2

inline CIwVec3::CIwVec3(const CIwFVec3& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
    z = IW_FIXED_FROM_FLOAT(v.z);
}




inline CIwVec3 CIwVec3::operator = (const CIwFVec3& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
    z = IW_FIXED_FROM_FLOAT(v.z);
    return *this;
}




inline bool operator == (const CIwVec3& v1, const CIwFVec3& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        ((float)(v1.z) / (float)(1 << 12)) == v2.z &&
        true);
}




inline CIwFVec3 operator + (const CIwVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        , ((float)(v1.z) / (float)(1 << 12)) + v2.z
        );
}




inline CIwFVec3 operator - (const CIwVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        , ((float)(v1.z) / (float)(1 << 12)) - v2.z
        );
}




inline CIwVec3 operator += (CIwVec3& v1, const CIwFVec3& v2)
{
    v1.x += IW_FIXED_FROM_FLOAT(v2.x);
    v1.y += IW_FIXED_FROM_FLOAT(v2.y);
    v1.z += IW_FIXED_FROM_FLOAT(v2.z);
    return v1;
}




inline CIwVec3 operator -= (CIwVec3& v1, const CIwFVec3& v2)
{
    v1.x -= IW_FIXED_FROM_FLOAT(v2.x);
    v1.y -= IW_FIXED_FROM_FLOAT(v2.y);
    v1.z -= IW_FIXED_FROM_FLOAT(v2.z);
    return v1;
}




inline float operator * (const CIwVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(v1) * v2;
}




inline CIwFVec3 operator ^ (const CIwVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(v1) ^ v2;
}
# 697 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec3.h" 2

inline CIwSVec3::CIwSVec3(const CIwVec3& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
    z = IW_SFIXED_FROM_FIXED(v.z);
}

inline CIwSVec3 CIwSVec3::operator = (const CIwVec3& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
    z = IW_SFIXED_FROM_FIXED(v.z);
    return *this;
}


inline bool operator == (const CIwSVec3& v1, const CIwVec3& v2)
{
    return (
        (int32)v1.x == v2.x &&
        (int32)v1.y == v2.y &&
        (int32)v1.z == v2.z &&
        true);
}


inline CIwVec3 operator + (const CIwSVec3& v1, const CIwVec3& v2)
{
    return CIwVec3(
        (int32)v1.x + v2.x
        , (int32)v1.y + v2.y
        , (int32)v1.z + v2.z
        );
}


inline CIwVec3 operator - (const CIwSVec3& v1, const CIwVec3& v2)
{
    return CIwVec3(
        (int32)v1.x - v2.x
        , (int32)v1.y - v2.y
        , (int32)v1.z - v2.z
        );
}




inline CIwSVec3 operator += (CIwSVec3& v1, const CIwVec3& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(v2.x);
    v1.y += IW_SFIXED_FROM_FIXED(v2.y);
    v1.z += IW_SFIXED_FROM_FIXED(v2.z);
    return v1;
}




inline CIwSVec3 operator -= (CIwSVec3& v1, const CIwVec3& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(v2.x);
    v1.y -= IW_SFIXED_FROM_FIXED(v2.y);
    v1.z -= IW_SFIXED_FROM_FIXED(v2.z);
    return v1;
}




inline int32 operator * (const CIwSVec3& v1, const CIwVec3& v2)
{
    return CIwVec3(v1) * v2;
}




inline CIwVec3 operator ^ (const CIwSVec3& v1, const CIwVec3& v2)
{
    return CIwVec3(v1) ^ v2;
}







inline CIwSVec3::CIwSVec3(const CIwFVec3& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
    z = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.z));
}




inline CIwSVec3 CIwSVec3::operator = (const CIwFVec3& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
    z = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.z));
    return *this;
}




inline bool operator == (const CIwSVec3& v1, const CIwFVec3& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        ((float)(v1.z) / (float)(1 << 12)) == v2.z &&
        true);
}




inline CIwFVec3 operator + (const CIwSVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        , ((float)(v1.z) / (float)(1 << 12)) + v2.z
        );
}




inline CIwFVec3 operator - (const CIwSVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        , ((float)(v1.z) / (float)(1 << 12)) - v2.z
        );
}




inline CIwSVec3 operator += (CIwSVec3& v1, const CIwFVec3& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    v1.z += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.z));
    return v1;
}




inline CIwSVec3 operator -= (CIwSVec3& v1, const CIwFVec3& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    v1.z -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.z));
    return v1;
}




inline float operator * (const CIwSVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(v1) * v2;
}




inline CIwFVec3 operator ^ (const CIwSVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(v1) ^ v2;
}
# 35 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec.h" 2
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h" 1
       
# 33 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwSVec4
{
public:
    int16 x;
    int16 y;
    int16 z;
    int16 w;


    static CIwSVec4 g_Zero;


    static CIwSVec4 g_AxisX;


    static CIwSVec4 g_AxisY;


    static CIwSVec4 g_AxisZ;


    static CIwSVec4 g_AxisW;




    CIwSVec4() {};
# 86 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h"
    CIwSVec4(int16 _x, int16 _y, int16 _z, int16 _w) : x(_x), y(_y), z(_z), w(_w) {};

    explicit CIwSVec4(const CIwVec4& v);
    explicit CIwSVec4(const CIwFVec4& v);
    CIwSVec4 operator = (const CIwVec4& v);
    CIwSVec4 operator = (const CIwFVec4& v);
# 104 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {


        int64 test;
        test = (int64)x*x + (int64)y*y+ (int64)z*z+ (int64)w*w; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 115, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        return (x*x + y*y+ z*z+ w*w) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 154 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h"
    void NormaliseSlow();
# 164 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h"
    void Normalise();





    CIwSVec4 GetNormalised() const;







    void NormaliseSafe();





    CIwSVec4 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 204 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwSVec4 const & v) const {return *this * v;}
# 233 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h"
    CIwSVec4& operator = (CIwSVec4 const & v);






    CIwSVec4 operator + (CIwSVec4 const & v) const;






    CIwSVec4 & operator += (CIwSVec4 const & v);






    CIwSVec4 operator - (CIwSVec4 const & v) const;






    CIwSVec4 & operator -= (CIwSVec4 const & v);






    int32 operator * (CIwSVec4 const & v) const;







    bool operator == (CIwSVec4 const & v) const;






    bool operator != (CIwSVec4 const & v) const;
# 296 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h"
    CIwSVec4 operator - () const;






    CIwSVec4 operator * (iwfixed l) const;







    CIwSVec4 & operator *= (iwfixed l);






    CIwSVec4 operator / (const iwfixed s) const;






    CIwSVec4 operator >> (const int s) const;







    CIwSVec4 operator >>= (const int s);






    CIwSVec4 operator << (const int s) const;







    CIwSVec4 operator <<= (const int s);






    int16 & operator [] (const int n);






    int16 operator [] (const int n) const;




};




inline CIwSVec4& CIwSVec4::operator = (CIwSVec4 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    w = v.w;
    return *this;
}




inline CIwSVec4 CIwSVec4::operator + (CIwSVec4 const & v) const
{

    int32 test;
    test = x + (int32)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator +"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 388, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y + (int32)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator +"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 389, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z + (int32)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator +"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 390, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = w + (int32)v.w; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator +"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 391, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwSVec4(
        (int16)(x + v.x)
        , (int16)(y + v.y)
        , (int16)(z + v.z)
        , (int16)(w + v.w)
        );
}




inline CIwSVec4 & CIwSVec4::operator += (CIwSVec4 const & v)
{

    int32 test;
    test = x + (int32)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator +="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 408, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y + (int32)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator +="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 409, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z + (int32)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator +="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 410, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = w + (int32)v.w; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator +="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 411, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x += v.x;
    y += v.y;
    z += v.z;
    w += v.w;
    return *this;
}




inline CIwSVec4 CIwSVec4::operator - (CIwSVec4 const & v) const
{

    int32 test;
    test = x - (int32)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator -"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 427, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y - (int32)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator -"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 428, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z - (int32)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator -"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 429, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = w - (int32)v.w; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator -"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 430, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwSVec4(
        (int16)(x - v.x)
        , (int16)(y - v.y)
        , (int16)(z - v.z)
        , (int16)(w - v.w)
        );
}




inline CIwSVec4 & CIwSVec4::operator -= (CIwSVec4 const & v)
{

    int32 test;
    test = x - (int32)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator -="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 447, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y - (int32)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator -="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 448, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z - (int32)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator -="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 449, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = w - (int32)v.w; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator -="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 450, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x -= v.x;
    y -= v.y;
    z -= v.z;
    w -= v.w;
    return *this;
}




inline int32 CIwSVec4::operator * (CIwSVec4 const & v) const
{

    int64 test = (
        (int64)x * v.x +
        (int64)y * v.y +
        (int64)z * v.z +
        (int64)w * v.w +
        0);

    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator *"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 472, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    (void) test;


    return (
        (int32)x * v.x +
        (int32)y * v.y +
        (int32)z * v.z +
        (int32)w * v.w +
        0) >> 12;
}




inline bool CIwSVec4::operator == (CIwSVec4 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        v.w == w &&
        true);
}




inline bool CIwSVec4::operator != (CIwSVec4 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        v.w != w ||
        false);
}




inline CIwSVec4 CIwSVec4::operator * (iwfixed l) const
{



    int32 test;
    test = ((int32)(x) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator *"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 519, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int32)(y) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator *"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 520, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int32)(z) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator *"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 521, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int32)(w) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator *"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 522, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


    return CIwSVec4(
          (int16)IW_FIXED_MUL(x,l)
        , (int16)IW_FIXED_MUL(y,l)
        , (int16)IW_FIXED_MUL(z,l)
        , (int16)IW_FIXED_MUL(w,l)
        );
}




inline CIwSVec4 & CIwSVec4::operator *= (iwfixed l)
{



    int32 test;
    test = ((int32)(x) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator *="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 542, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int32)(y) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator *="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 543, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int32)(z) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator *="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 544, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int32)(w) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator *="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 545, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


    x = (int16)IW_FIXED_MUL(x,l);
    y = (int16)IW_FIXED_MUL(y,l);
    z = (int16)IW_FIXED_MUL(z,l);
    w = (int16)IW_FIXED_MUL(w,l);
    return *this;
}




inline CIwSVec4 CIwSVec4::operator - () const
{
    return CIwSVec4(
        (int16)-x
        , (int16)-y
        , (int16)-z
        , (int16)-w
        );
}




inline CIwSVec4 CIwSVec4::operator / (const iwfixed s) const
{
    return CIwSVec4(
        (int16)(IW_FIXED_DIV(x, s))
        , (int16)(IW_FIXED_DIV(y, s))
        , (int16)(IW_FIXED_DIV(z, s))
        , (int16)(IW_FIXED_DIV(w, s))
        );
}




inline CIwSVec4 CIwSVec4::operator >> (const int s) const
{
    return CIwSVec4(
        (int16)(x >> s)
        , (int16)(y >> s)
        , (int16)(z >> s)
        , (int16)(w >> s)
        );
}

inline CIwSVec4 CIwSVec4::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    z >>= s;
    w >>= s;
    return *this;
}




inline CIwSVec4 CIwSVec4::operator << (const int s) const
{

    int32 test;
    test = (x << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator <<"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 610, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (y << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator <<"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 611, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (z << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator <<"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 612, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (w << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator <<"); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 613, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwSVec4(
        (int16)(x << s)
        , (int16)(y << s)
        , (int16)(z << s)
        , (int16)(w << s)
        );
}

inline CIwSVec4 CIwSVec4::operator <<= (const int s)
{

    int32 test;
    test = (int32)(x) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator <<="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 627, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (int32)(y) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator <<="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 628, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x <<= s;
    y <<= s;

    test = (int32)(z) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator <<="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 633, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    z <<= s;

    test = (int32)(w) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 31 == test >> 15)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwSVec4 overflow: operator <<="); switch (IwDebugAssertShow("test >> 31 == test >> 15", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 637, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    w <<= s;
    return *this;
}


inline int16 & CIwSVec4::operator [] (const int n)
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 4)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 4 dimensional vector", n); switch (IwDebugAssertShow("n < 4", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 646, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}


inline int16 CIwSVec4::operator [] (const int n) const
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 4)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 4 dimensional vector", n); switch (IwDebugAssertShow("n < 4", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h", 653, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}





inline CIwSVec4 operator * (iwfixed l, const CIwSVec4& v)
{
    return v * l;
}





# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h" 1
       
# 33 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwVec4
{
public:
    int32 x;
    int32 y;
    int32 z;
    int32 w;


    static CIwVec4 g_Zero;


    static CIwVec4 g_AxisX;


    static CIwVec4 g_AxisY;


    static CIwVec4 g_AxisZ;


    static CIwVec4 g_AxisW;




    CIwVec4() {};
# 86 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h"
    CIwVec4(int32 _x, int32 _y, int32 _z, int32 _w) : x(_x), y(_y), z(_z), w(_w) {};

    explicit CIwVec4(const CIwSVec4& v);
    explicit CIwVec4(const CIwFVec4& v);
    CIwVec4 operator = (const CIwSVec4& v);
    CIwVec4 operator = (const CIwFVec4& v);
# 104 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {


        int64 test;
        test = (int64)x*x + (int64)y*y+ (int64)z*z+ (int64)w*w; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 115, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        return (x*x + y*y+ z*z+ w*w) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 154 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h"
    void NormaliseSlow();
# 164 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h"
    void Normalise();





    CIwVec4 GetNormalised() const;







    void NormaliseSafe();





    CIwVec4 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 204 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwVec4 const & v) const {return *this * v;}
# 233 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h"
    CIwVec4& operator = (CIwVec4 const & v);






    CIwVec4 operator + (CIwVec4 const & v) const;






    CIwVec4 & operator += (CIwVec4 const & v);






    CIwVec4 operator - (CIwVec4 const & v) const;






    CIwVec4 & operator -= (CIwVec4 const & v);






    int32 operator * (CIwVec4 const & v) const;







    bool operator == (CIwVec4 const & v) const;






    bool operator != (CIwVec4 const & v) const;
# 296 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h"
    CIwVec4 operator - () const;






    CIwVec4 operator * (iwfixed l) const;







    CIwVec4 & operator *= (iwfixed l);






    CIwVec4 operator / (const iwfixed s) const;






    CIwVec4 operator >> (const int s) const;







    CIwVec4 operator >>= (const int s);






    CIwVec4 operator << (const int s) const;







    CIwVec4 operator <<= (const int s);






    int32 & operator [] (const int n);






    int32 operator [] (const int n) const;




};




inline CIwVec4& CIwVec4::operator = (CIwVec4 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    w = v.w;
    return *this;
}




inline CIwVec4 CIwVec4::operator + (CIwVec4 const & v) const
{

    int64 test;
    test = x + (int64)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator +"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 388, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y + (int64)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator +"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 389, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z + (int64)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator +"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 390, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = w + (int64)v.w; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator +"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 391, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwVec4(
        (int32)(x + v.x)
        , (int32)(y + v.y)
        , (int32)(z + v.z)
        , (int32)(w + v.w)
        );
}




inline CIwVec4 & CIwVec4::operator += (CIwVec4 const & v)
{

    int64 test;
    test = x + (int64)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator +="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 408, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y + (int64)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator +="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 409, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z + (int64)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator +="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 410, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = w + (int64)v.w; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator +="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 411, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x += v.x;
    y += v.y;
    z += v.z;
    w += v.w;
    return *this;
}




inline CIwVec4 CIwVec4::operator - (CIwVec4 const & v) const
{

    int64 test;
    test = x - (int64)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator -"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 427, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y - (int64)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator -"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 428, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z - (int64)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator -"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 429, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = w - (int64)v.w; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator -"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 430, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwVec4(
        (int32)(x - v.x)
        , (int32)(y - v.y)
        , (int32)(z - v.z)
        , (int32)(w - v.w)
        );
}




inline CIwVec4 & CIwVec4::operator -= (CIwVec4 const & v)
{

    int64 test;
    test = x - (int64)v.x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator -="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 447, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = y - (int64)v.y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator -="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 448, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = z - (int64)v.z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator -="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 449, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = w - (int64)v.w; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator -="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 450, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x -= v.x;
    y -= v.y;
    z -= v.z;
    w -= v.w;
    return *this;
}




inline int32 CIwVec4::operator * (CIwVec4 const & v) const
{

    int64 test = (
        (int64)x * v.x +
        (int64)y * v.y +
        (int64)z * v.z +
        (int64)w * v.w +
        0);

    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator *"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 472, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    (void) test;


    return (
        (int32)x * v.x +
        (int32)y * v.y +
        (int32)z * v.z +
        (int32)w * v.w +
        0) >> 12;
}




inline bool CIwVec4::operator == (CIwVec4 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        v.w == w &&
        true);
}




inline bool CIwVec4::operator != (CIwVec4 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        v.w != w ||
        false);
}




inline CIwVec4 CIwVec4::operator * (iwfixed l) const
{



    int64 test;
    test = ((int64)(x) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator *"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 519, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int64)(y) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator *"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 520, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int64)(z) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator *"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 521, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int64)(w) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator *"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 522, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


    return CIwVec4(
          (int32)IW_FIXED_MUL(x,l)
        , (int32)IW_FIXED_MUL(y,l)
        , (int32)IW_FIXED_MUL(z,l)
        , (int32)IW_FIXED_MUL(w,l)
        );
}




inline CIwVec4 & CIwVec4::operator *= (iwfixed l)
{



    int64 test;
    test = ((int64)(x) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator *="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 542, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int64)(y) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator *="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 543, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int64)(z) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator *="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 544, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = ((int64)(w) * l) >> 12; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator *="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 545, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


    x = (int32)IW_FIXED_MUL(x,l);
    y = (int32)IW_FIXED_MUL(y,l);
    z = (int32)IW_FIXED_MUL(z,l);
    w = (int32)IW_FIXED_MUL(w,l);
    return *this;
}




inline CIwVec4 CIwVec4::operator - () const
{
    return CIwVec4(
        (int32)-x
        , (int32)-y
        , (int32)-z
        , (int32)-w
        );
}




inline CIwVec4 CIwVec4::operator / (const iwfixed s) const
{
    return CIwVec4(
        (int32)(IW_FIXED_DIV(x, s))
        , (int32)(IW_FIXED_DIV(y, s))
        , (int32)(IW_FIXED_DIV(z, s))
        , (int32)(IW_FIXED_DIV(w, s))
        );
}




inline CIwVec4 CIwVec4::operator >> (const int s) const
{
    return CIwVec4(
        (int32)(x >> s)
        , (int32)(y >> s)
        , (int32)(z >> s)
        , (int32)(w >> s)
        );
}

inline CIwVec4 CIwVec4::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    z >>= s;
    w >>= s;
    return *this;
}




inline CIwVec4 CIwVec4::operator << (const int s) const
{

    int64 test;
    test = (x << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator <<"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 610, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (y << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator <<"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 611, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (z << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator <<"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 612, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (w << s); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator <<"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 613, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    return CIwVec4(
        (int32)(x << s)
        , (int32)(y << s)
        , (int32)(z << s)
        , (int32)(w << s)
        );
}

inline CIwVec4 CIwVec4::operator <<= (const int s)
{

    int64 test;
    test = (int64)(x) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator <<="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 627, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    test = (int64)(y) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator <<="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 628, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    x <<= s;
    y <<= s;

    test = (int64)(z) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator <<="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 633, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    z <<= s;

    test = (int64)(w) << s; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwVec4 overflow: operator <<="); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 637, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

    w <<= s;
    return *this;
}


inline int32 & CIwVec4::operator [] (const int n)
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 4)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 4 dimensional vector", n); switch (IwDebugAssertShow("n < 4", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 646, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}


inline int32 CIwVec4::operator [] (const int n) const
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 4)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 4 dimensional vector", n); switch (IwDebugAssertShow("n < 4", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h", 653, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}





inline CIwVec4 operator * (iwfixed l, const CIwVec4& v)
{
    return v * l;
}







inline CIwVec4::CIwVec4(const CIwSVec4& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
    z = (int32)v.z;
    w = (int32)v.w;
}

inline CIwVec4 CIwVec4::operator = (const CIwSVec4& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
    z = (int32)v.z;
    w = (int32)v.w;
    return *this;
}


inline bool operator == (const CIwVec4& v1, const CIwSVec4& v2)
{
    return (
        v1.x == (int32)v2.x &&
        v1.y == (int32)v2.y &&
        v1.z == (int32)v2.z &&
        v1.w == (int32)v2.w &&
        true);
}


inline CIwVec4 operator + (const CIwVec4& v1, const CIwSVec4& v2)
{
    return CIwVec4(
        v1.x + (int32)v2.x
        , v1.y + (int32)v2.y
        , v1.z + (int32)v2.z
        , v1.w + (int32)v2.w
        );
}


inline CIwVec4 operator - (const CIwVec4& v1, const CIwSVec4& v2)
{
    return CIwVec4(
        v1.x - (int32)v2.x
        , v1.y - (int32)v2.y
        , v1.z - (int32)v2.z
        , v1.w - (int32)v2.w
        );
}




inline CIwVec4 operator += (CIwVec4& v1, const CIwSVec4& v2)
{
    v1.x += (int32)v2.x;
    v1.y += (int32)v2.y;
    v1.z += (int32)v2.z;
    v1.w += (int32)v2.w;
    return v1;
}




inline CIwVec4 operator -= (CIwVec4& v1, const CIwSVec4& v2)
{
    v1.x -= (int32)v2.x;
    v1.y -= (int32)v2.y;
    v1.z -= (int32)v2.z;
    v1.w -= (int32)v2.w;
    return v1;
}




inline int32 operator * (const CIwVec4& v1, const CIwSVec4& v2)
{
    return v1 * CIwVec4(v2);
}






# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec4.h" 1
       
# 33 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec4.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwFVec4
{
public:
    float x;
    float y;
    float z;
    float w;


    static CIwFVec4 g_Zero;


    static CIwFVec4 g_AxisX;


    static CIwFVec4 g_AxisY;


    static CIwFVec4 g_AxisZ;


    static CIwFVec4 g_AxisW;




    CIwFVec4() {};
# 86 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec4.h"
    CIwFVec4(float _x, float _y, float _z, float _w) : x(_x), y(_y), z(_z), w(_w) {};

    explicit CIwFVec4(const CIwSVec4& v);
    explicit CIwFVec4(const CIwVec4& v);
    CIwFVec4 operator = (const CIwSVec4& v);
    CIwFVec4 operator = (const CIwVec4& v);
# 104 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec4.h"
    float GetLength() const;





    inline float GetLengthSquared() const
    {

        return (x*x + y*y+ z*z+ w*w);
    }
# 131 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec4.h"
    void Normalise();






    CIwFVec4 GetNormalised() const;







    bool IsNormalised() const;
# 159 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec4.h"
    void Serialise(void);





    bool IsZero() const;






    inline float Dot(CIwFVec4 const & v) const {return *this * v;}
# 188 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec4.h"
    CIwFVec4& operator = (CIwFVec4 const & v);






    CIwFVec4 operator + (CIwFVec4 const & v) const;






    CIwFVec4 & operator += (CIwFVec4 const & v);






    CIwFVec4 operator - (CIwFVec4 const & v) const;






    CIwFVec4 & operator -= (CIwFVec4 const & v);






    float operator * (CIwFVec4 const & v) const;







    bool operator == (CIwFVec4 const & v) const;






    bool operator != (CIwFVec4 const & v) const;
# 251 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec4.h"
    CIwFVec4 operator - () const;






    CIwFVec4 operator * (float l) const;







    CIwFVec4 & operator *= (float l);






    CIwFVec4 operator / (const float s) const;







    float & operator [] (const int n);






    float operator [] (const int n) const;




};




inline CIwFVec4& CIwFVec4::operator = (CIwFVec4 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    w = v.w;
    return *this;
}




inline CIwFVec4 CIwFVec4::operator + (CIwFVec4 const & v) const
{
    return CIwFVec4(
        (float)(x + v.x)
        , (float)(y + v.y)
        , (float)(z + v.z)
        , (float)(w + v.w)
        );
}




inline CIwFVec4 & CIwFVec4::operator += (CIwFVec4 const & v)
{
    x += v.x;
    y += v.y;
    z += v.z;
    w += v.w;
    return *this;
}




inline CIwFVec4 CIwFVec4::operator - (CIwFVec4 const & v) const
{
    return CIwFVec4(
        (float)(x - v.x)
        , (float)(y - v.y)
        , (float)(z - v.z)
        , (float)(w - v.w)
        );
}




inline CIwFVec4 & CIwFVec4::operator -= (CIwFVec4 const & v)
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    w -= v.w;
    return *this;
}




inline float CIwFVec4::operator * (CIwFVec4 const & v) const
{

    return (
        (float)x * v.x +
        (float)y * v.y +
        (float)z * v.z +
        (float)w * v.w +
        0);
}




inline bool CIwFVec4::operator == (CIwFVec4 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        v.w == w &&
        true);
}




inline bool CIwFVec4::operator != (CIwFVec4 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        v.w != w ||
        false);
}




inline CIwFVec4 CIwFVec4::operator * (float l) const
{
    return CIwFVec4(
        (float)(x * l)
        , (float)(y * l)
        , (float)(z * l)
        , (float)(w * l)
        );
}




inline CIwFVec4 & CIwFVec4::operator *= (float l)
{
    x = (float)(x * l);
    y = (float)(y * l);
    z = (float)(z * l);
    w = (float)(w * l);
    return *this;
}




inline CIwFVec4 CIwFVec4::operator - () const
{
    return CIwFVec4(
        (float)-x
        , (float)-y
        , (float)-z
        , (float)-w
        );
}




inline CIwFVec4 CIwFVec4::operator / (const float s) const
{
    return CIwFVec4(
        (float)(x / s)
        , (float)(y / s)
        , (float)(z / s)
        , (float)(w / s)
        );
}


inline float & CIwFVec4::operator [] (const int n)
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 4)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 4 dimensional vector", n); switch (IwDebugAssertShow("n < 4", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec4.h", 451, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}


inline float CIwFVec4::operator [] (const int n) const
{
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(n < 4)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Attempting to reference %d entry in 4 dimensional vector", n); switch (IwDebugAssertShow("n < 4", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec4.h", 458, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    return (&x)[n];
}





inline CIwFVec4 operator * (float l, const CIwFVec4& v)
{
    return v * l;
}







inline CIwFVec4::CIwFVec4(const CIwSVec4& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    w = ((float)(v.w) / (float)(1 << 12));
}

inline CIwFVec4 CIwFVec4::operator = (const CIwSVec4& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    w = ((float)(v.w) / (float)(1 << 12));
    return *this;
}


inline bool operator == (const CIwFVec4& v1, const CIwSVec4& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        v1.z == ((float)(v2.z) / (float)(1 << 12)) &&
        v1.w == ((float)(v2.w) / (float)(1 << 12)) &&
        true);
}


inline CIwFVec4 operator + (const CIwFVec4& v1, const CIwSVec4& v2)
{
    return CIwFVec4(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        , v1.z + ((float)(v2.z) / (float)(1 << 12))
        , v1.w + ((float)(v2.w) / (float)(1 << 12))
        );
}


inline CIwFVec4 operator - (const CIwFVec4& v1, const CIwSVec4& v2)
{
    return CIwFVec4(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        , v1.z - ((float)(v2.z) / (float)(1 << 12))
        , v1.w - ((float)(v2.w) / (float)(1 << 12))
        );
}




inline CIwFVec4 operator += (CIwFVec4& v1, const CIwSVec4& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    v1.z += ((float)(v2.z) / (float)(1 << 12));
    v1.w += ((float)(v2.w) / (float)(1 << 12));
    return v1;
}




inline CIwFVec4 operator -= (CIwFVec4& v1, const CIwSVec4& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    v1.z -= ((float)(v2.z) / (float)(1 << 12));
    v1.w -= ((float)(v2.w) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec4& v1, const CIwSVec4& v2)
{
    return v1 * CIwFVec4(v2);
}
# 566 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFVec4.h"
inline CIwFVec4::CIwFVec4(const CIwVec4& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    w = ((float)(v.w) / (float)(1 << 12));
}




inline CIwFVec4 CIwFVec4::operator = (const CIwVec4& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    w = ((float)(v.w) / (float)(1 << 12));
    return *this;
}




inline bool operator == (const CIwFVec4& v1, const CIwVec4& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        v1.z == ((float)(v2.z) / (float)(1 << 12)) &&
        v1.w == ((float)(v2.w) / (float)(1 << 12)) &&
        true);
}




inline CIwFVec4 operator + (const CIwFVec4& v1, const CIwVec4& v2)
{
    return CIwFVec4(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        , v1.z + ((float)(v2.z) / (float)(1 << 12))
        , v1.w + ((float)(v2.w) / (float)(1 << 12))
        );
}




inline CIwFVec4 operator - (const CIwFVec4& v1, const CIwVec4& v2)
{
    return CIwFVec4(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        , v1.z - ((float)(v2.z) / (float)(1 << 12))
        , v1.w - ((float)(v2.w) / (float)(1 << 12))
        );
}




inline CIwFVec4 operator += (CIwFVec4& v1, const CIwVec4& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    v1.z += ((float)(v2.z) / (float)(1 << 12));
    v1.w += ((float)(v2.w) / (float)(1 << 12));
    return v1;
}




inline CIwFVec4 operator -= (CIwFVec4& v1, const CIwVec4& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    v1.z -= ((float)(v2.z) / (float)(1 << 12));
    v1.w -= ((float)(v2.w) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec4& v1, const CIwVec4& v2)
{
    return v1 * CIwFVec4(v2);
}
# 760 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec4.h" 2

inline CIwVec4::CIwVec4(const CIwFVec4& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
    z = IW_FIXED_FROM_FLOAT(v.z);
    w = IW_FIXED_FROM_FLOAT(v.w);
}




inline CIwVec4 CIwVec4::operator = (const CIwFVec4& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
    z = IW_FIXED_FROM_FLOAT(v.z);
    w = IW_FIXED_FROM_FLOAT(v.w);
    return *this;
}




inline bool operator == (const CIwVec4& v1, const CIwFVec4& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        ((float)(v1.z) / (float)(1 << 12)) == v2.z &&
        ((float)(v1.w) / (float)(1 << 12)) == v2.w &&
        true);
}




inline CIwFVec4 operator + (const CIwVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        , ((float)(v1.z) / (float)(1 << 12)) + v2.z
        , ((float)(v1.w) / (float)(1 << 12)) + v2.w
        );
}




inline CIwFVec4 operator - (const CIwVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        , ((float)(v1.z) / (float)(1 << 12)) - v2.z
        , ((float)(v1.w) / (float)(1 << 12)) - v2.w
        );
}




inline CIwVec4 operator += (CIwVec4& v1, const CIwFVec4& v2)
{
    v1.x += IW_FIXED_FROM_FLOAT(v2.x);
    v1.y += IW_FIXED_FROM_FLOAT(v2.y);
    v1.z += IW_FIXED_FROM_FLOAT(v2.z);
    v1.w += IW_FIXED_FROM_FLOAT(v2.w);
    return v1;
}




inline CIwVec4 operator -= (CIwVec4& v1, const CIwFVec4& v2)
{
    v1.x -= IW_FIXED_FROM_FLOAT(v2.x);
    v1.y -= IW_FIXED_FROM_FLOAT(v2.y);
    v1.z -= IW_FIXED_FROM_FLOAT(v2.z);
    v1.w -= IW_FIXED_FROM_FLOAT(v2.w);
    return v1;
}




inline float operator * (const CIwVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(v1) * v2;
}
# 671 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h" 2

inline CIwSVec4::CIwSVec4(const CIwVec4& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
    z = IW_SFIXED_FROM_FIXED(v.z);
    w = IW_SFIXED_FROM_FIXED(v.w);
}

inline CIwSVec4 CIwSVec4::operator = (const CIwVec4& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
    z = IW_SFIXED_FROM_FIXED(v.z);
    w = IW_SFIXED_FROM_FIXED(v.w);
    return *this;
}


inline bool operator == (const CIwSVec4& v1, const CIwVec4& v2)
{
    return (
        (int32)v1.x == v2.x &&
        (int32)v1.y == v2.y &&
        (int32)v1.z == v2.z &&
        (int32)v1.w == v2.w &&
        true);
}


inline CIwVec4 operator + (const CIwSVec4& v1, const CIwVec4& v2)
{
    return CIwVec4(
        (int32)v1.x + v2.x
        , (int32)v1.y + v2.y
        , (int32)v1.z + v2.z
        , (int32)v1.w + v2.w
        );
}


inline CIwVec4 operator - (const CIwSVec4& v1, const CIwVec4& v2)
{
    return CIwVec4(
        (int32)v1.x - v2.x
        , (int32)v1.y - v2.y
        , (int32)v1.z - v2.z
        , (int32)v1.w - v2.w
        );
}




inline CIwSVec4 operator += (CIwSVec4& v1, const CIwVec4& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(v2.x);
    v1.y += IW_SFIXED_FROM_FIXED(v2.y);
    v1.z += IW_SFIXED_FROM_FIXED(v2.z);
    v1.w += IW_SFIXED_FROM_FIXED(v2.w);
    return v1;
}




inline CIwSVec4 operator -= (CIwSVec4& v1, const CIwVec4& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(v2.x);
    v1.y -= IW_SFIXED_FROM_FIXED(v2.y);
    v1.z -= IW_SFIXED_FROM_FIXED(v2.z);
    v1.w -= IW_SFIXED_FROM_FIXED(v2.w);
    return v1;
}




inline int32 operator * (const CIwSVec4& v1, const CIwVec4& v2)
{
    return CIwVec4(v1) * v2;
}
# 761 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSVec4.h"
inline CIwSVec4::CIwSVec4(const CIwFVec4& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
    z = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.z));
    w = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.w));
}




inline CIwSVec4 CIwSVec4::operator = (const CIwFVec4& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
    z = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.z));
    w = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.w));
    return *this;
}




inline bool operator == (const CIwSVec4& v1, const CIwFVec4& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        ((float)(v1.z) / (float)(1 << 12)) == v2.z &&
        ((float)(v1.w) / (float)(1 << 12)) == v2.w &&
        true);
}




inline CIwFVec4 operator + (const CIwSVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        , ((float)(v1.z) / (float)(1 << 12)) + v2.z
        , ((float)(v1.w) / (float)(1 << 12)) + v2.w
        );
}




inline CIwFVec4 operator - (const CIwSVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        , ((float)(v1.z) / (float)(1 << 12)) - v2.z
        , ((float)(v1.w) / (float)(1 << 12)) - v2.w
        );
}




inline CIwSVec4 operator += (CIwSVec4& v1, const CIwFVec4& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    v1.z += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.z));
    v1.w += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.w));
    return v1;
}




inline CIwSVec4 operator -= (CIwSVec4& v1, const CIwFVec4& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    v1.z -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.z));
    v1.w -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.w));
    return v1;
}




inline float operator * (const CIwSVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(v1) * v2;
}
# 36 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomVec.h" 2
# 23 "c:/marmalade/7.3/modules/iwgeom/h/IwGeom.h" 2
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h" 1
       
# 35 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
class CIwFMat;
# 63 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
class CIwMat
{
public:



    iwfixed m[3][3];



    CIwVec3 t;




    static CIwMat g_Identity;




    CIwMat() {};





    explicit CIwMat(iwfixed f)
    {
        m[0][0] = m[1][1] = m[2][2] = f;
        m[0][1] = m[0][2] = m[1][0] = m[1][2] = m[2][0] = m[2][1] = 0;
        t.x = t.y = t.z = 0;
    }






    explicit CIwMat(const CIwFMat & M);





    inline CIwFMat ConvertToCIwFMat();
# 116 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
    CIwMat(CIwMat const & R, CIwVec3 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[2][0] = R.m[2][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        m[2][1] = R.m[2][1];
        m[0][2] = R.m[0][2];
        m[1][2] = R.m[1][2];
        m[2][2] = R.m[2][2];
        t = T;
    }







    CIwMat(CIwMat const & R, CIwSVec3 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[2][0] = R.m[2][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        m[2][1] = R.m[2][1];
        m[0][2] = R.m[0][2];
        m[1][2] = R.m[1][2];
        m[2][2] = R.m[2][2];
        t = T;
    }






    void Serialise();





    void Normalise()
    {
        CIwVec3* pVecX = (CIwVec3*)&m[0][0];
        CIwVec3* pVecY = (CIwVec3*)&m[1][0];
        CIwVec3* pVecZ = (CIwVec3*)&m[2][0];

        pVecZ->Normalise();




        pVecX->Normalise();

        *pVecY = *pVecZ ^ *pVecX;
# 183 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(pVecY->GetLengthSquared() > 0x10)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Matrix cannot be normalised. This usually occurs when row vectors X and Z are linearly dependent."); switch (IwDebugAssertShow("pVecY->GetLengthSquared() > 0x10", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 183, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);



        pVecY->Normalise();

        *pVecX = *pVecY ^ *pVecZ;
    }




    void Transpose();





    CIwVec3 const & GetTrans() const
    {
        return t;
    }






    CIwMat & SetTrans(CIwVec3 const & v)
    {
        t = v;
        return *this;
    }






    CIwMat & SetTrans(CIwSVec3 const & v)
    {
        t = v;
        return *this;
    }






    CIwMat & operator += (CIwVec3 const & V)
    {
        t += V;
        return *this;
    }






    CIwMat & operator += (CIwSVec3 const & V)
    {
        t += V;
        return *this;
    }






    CIwMat operator + (CIwVec3 const & V) const
    {
        return CIwMat(*this, t+V);
    }






    CIwMat operator + (CIwSVec3 const & V) const
    {
        return CIwMat(*this, t+V);
    }







    CIwMat& operator <<= (int32 s)
    {
        m[0][0] <<= s; m[0][1] <<= s; m[0][2] <<= s;
        m[1][0] <<= s; m[1][1] <<= s; m[1][2] <<= s;
        m[2][0] <<= s; m[2][1] <<= s; m[2][2] <<= s;
        t.x <<= s, t.y <<= s, t.z <<= s;
        return *this;
    }






    CIwMat& operator >>= (int32 s)
    {
        m[0][0] >>= s; m[0][1] >>= s; m[0][2] >>= s;
        m[1][0] >>= s; m[1][1] >>= s; m[1][2] >>= s;
        m[2][0] >>= s; m[2][1] >>= s; m[2][2] >>= s;
        t.x >>= s, t.y >>= s, t.z >>= s;
        return *this;
    }





    CIwVec3 ColumnX() const
    {
        return CIwVec3(m[0][0], m[1][0], m[2][0]);
    }




    CIwVec3 ColumnY() const
    {
        return CIwVec3(m[0][1], m[1][1], m[2][1]);
    }




    CIwVec3 ColumnZ() const
    {
        return CIwVec3(m[0][2], m[1][2], m[2][2]);
    }







    CIwVec3 RowX() const
    {
        return CIwVec3(m[0][0], m[0][1], m[0][2]);
    }







    CIwVec3 RowY() const
    {
        return CIwVec3(m[1][0], m[1][1], m[1][2]);
    }







    CIwVec3 RowZ() const
    {
        return CIwVec3(m[2][0], m[2][1], m[2][2]);
    }







    CIwVec3 RotateVec(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z),
        IW_FIXED_MUL3(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z),
        IW_FIXED_MUL3(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z)
        );
    }







    CIwSVec3 RotateVec(CIwSVec3 const &V) const
    {
        return CIwSVec3(
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z))
        );
    }







    CIwVec3 RotateVecSafe(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3_SAFE(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z),
        IW_FIXED_MUL3_SAFE(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z),
        IW_FIXED_MUL3_SAFE(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z)
        );
    }







    CIwVec3 TransformVec(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z) + t.x,
        IW_FIXED_MUL3(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z) + t.y,
        IW_FIXED_MUL3(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z) + t.z
        );
    }
# 424 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
    CIwVec3 TransformVec(CIwSVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z) + t.x,
        IW_FIXED_MUL3(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z) + t.y,
        IW_FIXED_MUL3(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z) + t.z
        );
    }
# 441 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
    CIwVec3 TransformVecShift(CIwSVec3 const &V, int32 shift) const
    {
        int32 lDotShift = 12 - shift;
        return CIwVec3(
        IW_MUL_3_SHIFT(m[0][0] >> shift, m[1][0] >> shift, m[2][0] >> shift, V.x, V.y, V.z, lDotShift) + t.x,
        IW_MUL_3_SHIFT(m[0][1] >> shift, m[1][1] >> shift, m[2][1] >> shift, V.x, V.y, V.z, lDotShift) + t.y,
        IW_MUL_3_SHIFT(m[0][2] >> shift, m[1][2] >> shift, m[2][2] >> shift, V.x, V.y, V.z, lDotShift) + t.z
        );
    }
# 459 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
    CIwVec3 TransformVecSafe(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3_SAFE(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z) + t.x,
        IW_FIXED_MUL3_SAFE(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z) + t.y,
        IW_FIXED_MUL3_SAFE(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z) + t.z
        );
    }






    CIwVec3 TransformVecSafe(CIwSVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3_SAFE(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z) + t.x,
        IW_FIXED_MUL3_SAFE(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z) + t.y,
        IW_FIXED_MUL3_SAFE(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z) + t.z
        );
    }







    CIwVec3 TransposeRotateVec(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3(m[0][0], m[0][1], m[0][2], V.x, V.y, V.z),
        IW_FIXED_MUL3(m[1][0], m[1][1], m[1][2], V.x, V.y, V.z),
        IW_FIXED_MUL3(m[2][0], m[2][1], m[2][2], V.x, V.y, V.z)
        );
    }







    CIwSVec3 TransposeRotateVec(CIwSVec3 const &V) const
    {
        return CIwSVec3(
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[0][0], m[0][1], m[0][2], V.x, V.y, V.z)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[1][0], m[1][1], m[1][2], V.x, V.y, V.z)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[2][0], m[2][1], m[2][2], V.x, V.y, V.z))
        );
    }







    CIwVec3 TransposeRotateVecSafe(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3_SAFE(m[0][0], m[0][1], m[0][2], V.x, V.y, V.z),
        IW_FIXED_MUL3_SAFE(m[1][0], m[1][1], m[1][2], V.x, V.y, V.z),
        IW_FIXED_MUL3_SAFE(m[2][0], m[2][1], m[2][2], V.x, V.y, V.z)
        );
    }
# 534 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
    CIwVec3 TransposeTransformVec(CIwVec3 const &V) const
    {
        return CIwVec3(
            IW_FIXED_MUL3(m[0][0], m[0][1], m[0][2], V.x-t.x, V.y-t.y, V.z-t.z),
            IW_FIXED_MUL3(m[1][0], m[1][1], m[1][2], V.x-t.x, V.y-t.y, V.z-t.z),
            IW_FIXED_MUL3(m[2][0], m[2][1], m[2][2], V.x-t.x, V.y-t.y, V.z-t.z)
            );
    }
# 551 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
    iwfixed TransformVecX(CIwVec3 const &V) const { int64 test = (((int64)(IW_FIXED_MUL3(m[0][0],m[1][0],m[2][0],V.x,V.y,V.z))) + ((int64)(t.x))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 551, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }
    iwfixed TransformVecY(CIwVec3 const &V) const { int64 test = (((int64)(IW_FIXED_MUL3(m[0][1],m[1][1],m[2][1],V.x,V.y,V.z))) + ((int64)(t.y))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 552, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }
    iwfixed TransformVecZ(CIwVec3 const &V) const { int64 test = (((int64)(IW_FIXED_MUL3(m[0][2],m[1][2],m[2][2],V.x,V.y,V.z))) + ((int64)(t.z))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 553, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }
    iwfixed TransformVecZ(CIwSVec3 const &V) const { int64 test = (((int64)(IW_FIXED_MUL3(m[0][2],m[1][2],m[2][2],V.x,V.y,V.z))) + ((int64)(t.z))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 554, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }
    iwfixed TransformVecX(iwsfixed x, iwsfixed y, iwsfixed z) const { int64 test = (((int64)(IW_FIXED_MUL3(m[0][0],m[1][0],m[2][0],x,y,z))) + ((int64)(t.x))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 555, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }
    iwfixed TransformVecY(iwsfixed x, iwsfixed y, iwsfixed z) const { int64 test = (((int64)(IW_FIXED_MUL3(m[0][1],m[1][1],m[2][1],x,y,z))) + ((int64)(t.y))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 556, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }
    iwfixed TransformVecZ(iwsfixed x, iwsfixed y, iwsfixed z) const { int64 test = (((int64)(IW_FIXED_MUL3(m[0][2],m[1][2],m[2][2],x,y,z))) + ((int64)(t.z))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 557, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }
    iwfixed TransformVecX(iwfixed x, iwfixed y, iwfixed z) const { int64 test = (((int64)(IW_FIXED_MUL3(m[0][0],m[1][0],m[2][0],x,y,z))) + ((int64)(t.x))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 558, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }
    iwfixed TransformVecY(iwfixed x, iwfixed y, iwfixed z) const { int64 test = (((int64)(IW_FIXED_MUL3(m[0][1],m[1][1],m[2][1],x,y,z))) + ((int64)(t.y))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 559, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }
    iwfixed TransformVecZ(iwfixed x, iwfixed y, iwfixed z) const { int64 test = (((int64)(IW_FIXED_MUL3(m[0][2],m[1][2],m[2][2],x,y,z))) + ((int64)(t.z))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 560, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }







    inline iwfixed RotateVecX(const CIwVec3& V) const
    {
            return IW_FIXED_MUL(m[0][0], V.x) + IW_FIXED_MUL(m[1][0], V.y) + IW_FIXED_MUL(m[2][0], V.z);
    }





    inline iwfixed RotateVecY(const CIwVec3& V) const
    {
            return IW_FIXED_MUL(m[0][1], V.x) + IW_FIXED_MUL(m[1][1], V.y) + IW_FIXED_MUL(m[2][1], V.z);
    }





    inline iwfixed RotateVecZ(const CIwVec3& V) const
    {
            return IW_FIXED_MUL(m[0][2], V.x) + IW_FIXED_MUL(m[1][2], V.y) + IW_FIXED_MUL(m[2][2], V.z);
    }







    inline iwsfixed RotateVecX(const CIwSVec3& V) const
    {
            return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(m[0][0], V.x) + IW_FIXED_MUL(m[1][0], V.y) + IW_FIXED_MUL(m[2][0], V.z));
    }





    inline iwsfixed RotateVecY(const CIwSVec3& V) const
    {
            return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(m[0][1], V.x) + IW_FIXED_MUL(m[1][1], V.y) + IW_FIXED_MUL(m[2][1], V.z));
    }





    inline iwsfixed RotateVecZ(const CIwSVec3& V) const
    {
            return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(m[0][2], V.x) + IW_FIXED_MUL(m[1][2], V.y) + IW_FIXED_MUL(m[2][2], V.z));
    }





    CIwMat GetTranspose() const
    {
        CIwMat N;
        N.m[0][0] = m[0][0];
        N.m[1][0] = m[0][1];
        N.m[2][0] = m[0][2];
        N.m[0][1] = m[1][0];
        N.m[1][1] = m[1][1];
        N.m[2][1] = m[1][2];
        N.m[0][2] = m[2][0];
        N.m[1][2] = m[2][1];
        N.m[2][2] = m[2][2];


        N.t = CIwVec3(0, 0, 0);
        return N;
    }
# 650 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
    inline void SetRotX(iwangle r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][1] = m[0][2] = m[1][0] = m[2][0] = 0;
        m[0][0] = (1 << 12);
        m[1][1] = m[2][2] = IwGeomCos(r);
        m[1][2] = -(m[2][1] = IwGeomSin(r));
    }







    inline void SetRotY(iwangle r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][1] = m[1][2] = m[1][0] = m[2][1] = 0;
        m[1][1] = (1 << 12);
        m[0][0] = m[2][2] = IwGeomCos(r);
        m[2][0] = -(m[0][2] = IwGeomSin(r));
    }







    inline void SetRotZ(iwangle r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][2] = m[1][2] = m[2][0] = m[2][1] = 0;
        m[2][2] = (1 << 12);
        m[0][0] = m[1][1] = IwGeomCos(r);
        m[0][1] = -(m[1][0] = IwGeomSin(r));
    }


    inline void PreRotateX(iwangle r)
    {
        CIwMat rx;
        rx.SetRotX(r, true, true);
        PreRotate(rx);
    }
    inline void PreRotateY(iwangle r)
    {
        CIwMat ry;
        ry.SetRotY(r, true, true);
        PreRotate(ry);
    }
    inline void PreRotateZ(iwangle r)
    {
        CIwMat rz;
        rz.SetRotZ(r, true, true);
        PreRotate(rz);
    }
    inline void PostRotateX(iwangle r)
    {
        CIwMat rx;
        rx.SetRotX(r, true, true);
        PostRotate(rx);
    }
    inline void PostRotateY(iwangle r)
    {
        CIwMat ry;
        ry.SetRotY(r, true, true);
        PostRotate(ry);
    }
    inline void PostRotateZ(iwangle r)
    {
        CIwMat rz;
        rz.SetRotZ(r, true, true);
        PostRotate(rz);
    }







    void SetAxisAngle(CIwVec3 axis, iwangle angle);






    void LookAt(const CIwVec3& from, const CIwVec3& to, const CIwVec3& up)
    {

        CIwVec3 vx, vy, vz;

        vz = (to - from).GetNormalised();
        vx = (up ^ vz);
        if (vx.IsZero())
            vx.x = (1 << 12);
        else
            vx.Normalise();
        vy = (vz ^ vx);
        m[0][0] = vx.x; m[0][1] = vx.y; m[0][2] = vx.z;
        m[1][0] = vy.x; m[1][1] = vy.y; m[1][2] = vy.z;
        m[2][0] = vz.x; m[2][1] = vz.y; m[2][2] = vz.z;
    }







    CIwMat operator * (CIwMat const & M) const
    {
        CIwMat N;
        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);
        N.m[0][2] = FindComponentFromBA(M,*this,0,2);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);
        N.m[1][2] = FindComponentFromBA(M,*this,1,2);

        N.m[2][0] = FindComponentFromBA(M,*this,2,0);
        N.m[2][1] = FindComponentFromBA(M,*this,2,1);
        N.m[2][2] = FindComponentFromBA(M,*this,2,2);

        N.t = M.TransformVec(t);

        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(N.TransformVec(CIwVec3::g_Zero) == M.TransformVec(TransformVec(CIwVec3::g_Zero)))) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwMat overflow: operator *"); switch (IwDebugAssertShow("N.TransformVec(CIwVec3::g_Zero) == M.TransformVec(TransformVec(CIwVec3::g_Zero))",
 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
# 780 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
        ,
 781
# 780 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
        , (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0)
                                                                                           ;

        return N;
    }







    CIwMat & PreMult(CIwMat const & M)
    {
        return (*this = M * (*this));
    }




    CIwMat & PreMultiply(CIwMat const & M)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwMat::PreMult(M)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 802, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        return PreMult(M);
    }







    CIwMat & PostMult(CIwMat const & M)
    {
        return (*this = (*this) * M);
    }




    CIwMat & PostMultiply(CIwMat const & M)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwMat::PostMult(M)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 822, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        return PostMult(M);
    }







    CIwMat& operator *= (CIwMat const & M)
    {
        return PostMult(M);
    }







    CIwMat& PostRotate(CIwMat const& M)
    {
        CIwMat N;

        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);
        N.m[0][2] = FindComponentFromBA(M,*this,0,2);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);
        N.m[1][2] = FindComponentFromBA(M,*this,1,2);

        N.m[2][0] = FindComponentFromBA(M,*this,2,0);
        N.m[2][1] = FindComponentFromBA(M,*this,2,1);
        N.m[2][2] = FindComponentFromBA(M,*this,2,2);

        CopyRot(N);

        return *this;
    }






    CIwMat PreRotate(CIwMat const& M)
    {
        CIwMat t = M;
        t.t = this->t;
        return (*this = t.PostRotate(*this));
    }







    CIwMat& ScaleRot(iwfixed v)
    {
        for (int i=0; i<3; i++)
            for (int j=0; j<3; j++)
                m[i][j] = IW_FIXED_MUL(m[i][j],v);
        return *this;
    }






    CIwMat& ScaleTrans(iwfixed v)
    {
        t *= v;
        return *this;
    }





    CIwMat& Scale(iwfixed v)
    {
        ScaleRot(v);
        ScaleTrans(v);
        return *this;
    }






    CIwMat& operator *= (const iwfixed v)
    {
        Scale(v);
        return *this;
    }
# 933 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
    void InterpRot(CIwMat const & m0, CIwMat const & m1, iwfixed fraction);


    void InterpolateRot(CIwMat const & m0, CIwMat const & m1, iwfixed fraction)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwMat::InterpRot(m0, m1, fraction)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 938, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        InterpRot(m0, m1, fraction);
    }
# 952 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
    void InterpTrans(CIwMat const & m0, CIwMat const & m1, iwfixed fraction);


    void InterpolatePos(CIwMat const & m0, CIwMat const & m1, iwfixed fraction)
    {

        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwMat::InterpTrans(m0, m1, fraction)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 958, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        InterpTrans(m0, m1, fraction);
    }






    void CopyRot(const CIwMat& m0)
    {
        m[0][0] = m0.m[0][0];
        m[0][1] = m0.m[0][1];
        m[0][2] = m0.m[0][2];
        m[1][0] = m0.m[1][0];
        m[1][1] = m0.m[1][1];
        m[1][2] = m0.m[1][2];
        m[2][0] = m0.m[2][0];
        m[2][1] = m0.m[2][1];
        m[2][2] = m0.m[2][2];
    }





    void CopyTrans(const CIwMat& m0)
    {
        t = m0.t;
    }







    bool IsRotSame(CIwMat const& m0) const
    {
        return m[0][0] == m0.m[0][0] &&
        m[0][1] == m0.m[0][1] &&
        m[0][2] == m0.m[0][2] &&
        m[1][0] == m0.m[1][0] &&
        m[1][1] == m0.m[1][1] &&
        m[1][2] == m0.m[1][2] &&
        m[2][0] == m0.m[2][0] &&
        m[2][1] == m0.m[2][1] &&
        m[2][2] == m0.m[2][2];
    }






    bool IsTransSame(CIwMat const& m0) const
    {
        return (t == m0.t);
    }






    bool operator == (CIwMat const & m0) const
    {
        return IsRotSame(m0) && IsTransSame(m0);
    }







    bool operator != (CIwMat const & m0) const
    {
        return !IsRotSame(m0) || !IsTransSame(m0);
    }



    bool IsRotIdentity() const
    {
        return IsRotSame(g_Identity);
    }


    bool IsTransIdentity() const
    {
        return IsTransSame(g_Identity);
    }


    bool IsIdentity() const
    {
        return (*this)==g_Identity;
    }


    void SetIdentity()
    {
        *this = g_Identity;
    }


    bool IsRotZero() const
    {
        return m[0][0] == 0 &&
        m[0][1] == 0 &&
        m[0][2] == 0 &&
        m[1][0] == 0 &&
        m[1][1] == 0 &&
        m[1][2] == 0 &&
        m[2][0] == 0 &&
        m[2][1] == 0 &&
        m[2][2] == 0;
    }


    bool IsTransZero() const
    {
        return t.x == 0 &&
        t.y == 0 &&
        t.z == 0;
    }


    bool IsZero() const
    {
        return IsRotZero() && IsTransZero();
    }


    void SetZero();


    void Zero()
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwMat::SetZero()."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 1098, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        SetZero();
    }
# 1121 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
private:


    static inline iwfixed FindComponentFromBA(const CIwMat& A, const CIwMat& B, const int i, const int j)
    {


        int64 testA = (int64)(B.m[i][0]) * A.m[0][j];
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(testA >> 63 == testA >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Matrix multiplication overflow"); switch (IwDebugAssertShow("testA >> 63 == testA >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 1129, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        int64 testB = (int64)(B.m[i][1]) * A.m[1][j];
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(testB >> 63 == testB >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Matrix multiplication overflow"); switch (IwDebugAssertShow("testB >> 63 == testB >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 1132, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        int64 testC = (int64)(B.m[i][2]) * A.m[2][j];
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(testC >> 63 == testC >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Matrix multiplication overflow"); switch (IwDebugAssertShow("testC >> 63 == testC >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 1135, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        int64 test = testA + testB;
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Matrix multiplication overflow"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 1138, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        test += testC;
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Matrix multiplication overflow"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h", 1141, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        return (B.m[i][0]*A.m[0][j] + B.m[i][1]*A.m[1][j] + B.m[i][2]*A.m[2][j]) >> 12;
    }



};
# 1157 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h"
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h" 1
       
# 35 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h"
class CIwMat;
# 63 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h"
class CIwFMat
{
public:



    float m[3][3];



    CIwFVec3 t;




    static CIwFMat g_Identity;




    CIwFMat() {};





    explicit CIwFMat(float f)
    {
        m[0][0] = m[1][1] = m[2][2] = f;
        m[0][1] = m[0][2] = m[1][0] = m[1][2] = m[2][0] = m[2][1] = 0;
        t.x = t.y = t.z = 0;
    }






    explicit CIwFMat(const CIwMat & M);





    inline CIwMat ConvertToCIwMat();
# 116 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h"
    CIwFMat(CIwFMat const & R, CIwFVec3 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[2][0] = R.m[2][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        m[2][1] = R.m[2][1];
        m[0][2] = R.m[0][2];
        m[1][2] = R.m[1][2];
        m[2][2] = R.m[2][2];
        t = T;
    }







    void Serialise();





    void Normalise()
    {
        CIwFVec3* pVecX = (CIwFVec3*)&m[0][0];
        CIwFVec3* pVecY = (CIwFVec3*)&m[1][0];
        CIwFVec3* pVecZ = (CIwFVec3*)&m[2][0];

        pVecZ->Normalise();


        *pVecY = *pVecZ ^ *pVecX;
# 160 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h"
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(pVecY->GetLengthSquared() > ((float)(0x10) / (float)(1 << 12)))) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Matrix cannot be normalised. This usually occurs when row vectors X and Z are linearly dependent."); switch (IwDebugAssertShow("pVecY->GetLengthSquared() > ((float)(0x10) / (float)(1 << 12))", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h", 160, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);



        pVecY->Normalise();

        *pVecX = *pVecY ^ *pVecZ;
    }




    void Transpose();





    CIwFVec3 const & GetTrans() const
    {
        return t;
    }






    CIwFMat & SetTrans(CIwFVec3 const & v)
    {
        t = v;
        return *this;
    }







    CIwFMat & operator += (CIwFVec3 const & V)
    {
        t += V;
        return *this;
    }







    CIwFMat operator + (CIwFVec3 const & V) const
    {
        return CIwFMat(*this, t+V);
    }
# 225 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h"
    CIwFVec3 ColumnX() const
    {
        return CIwFVec3(m[0][0], m[1][0], m[2][0]);
    }




    CIwFVec3 ColumnY() const
    {
        return CIwFVec3(m[0][1], m[1][1], m[2][1]);
    }




    CIwFVec3 ColumnZ() const
    {
        return CIwFVec3(m[0][2], m[1][2], m[2][2]);
    }







    CIwFVec3 RowX() const
    {
        return CIwFVec3(m[0][0], m[0][1], m[0][2]);
    }







    CIwFVec3 RowY() const
    {
        return CIwFVec3(m[1][0], m[1][1], m[1][2]);
    }







    CIwFVec3 RowZ() const
    {
        return CIwFVec3(m[2][0], m[2][1], m[2][2]);
    }






    CIwFVec3 RotateVec(CIwFVec3 const &V) const
    {
        return CIwFVec3(
        ((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z)),
        ((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z)),
        ((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z))
        );
    }

    CIwSVec3 RotateVec(CIwSVec3 const &V) const
    {
        return CIwSVec3(
        IW_SFIXED_FROM_FLOAT_CAST((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z)),
        IW_SFIXED_FROM_FLOAT_CAST((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z)),
        IW_SFIXED_FROM_FLOAT_CAST((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z))
        );
    }







    CIwFVec3 TransformVec(CIwFVec3 const &V) const
    {
        return CIwFVec3(
        ((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z)) + t.x,
        ((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z)) + t.y,
        ((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z)) + t.z
        );
    }

    CIwVec3 TransformVec(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_FROM_FLOAT_CAST((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z) + t.x),
        IW_FIXED_FROM_FLOAT_CAST((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z) + t.y),
        IW_FIXED_FROM_FLOAT_CAST((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z) + t.z)
        );
    }

    CIwVec3 TransformVec(CIwSVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_FROM_FLOAT_CAST((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z) + t.x),
        IW_FIXED_FROM_FLOAT_CAST((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z) + t.y),
        IW_FIXED_FROM_FLOAT_CAST((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z) + t.z)
        );
    }






    CIwFVec3 TransposeRotateVec(CIwFVec3 const &V) const
    {
        return CIwFVec3(
        ((m[0][0] * V.x) + (m[0][1] * V.y) + (m[0][2] * V.z)),
        ((m[1][0] * V.x) + (m[1][1] * V.y) + (m[1][2] * V.z)),
        ((m[2][0] * V.x) + (m[2][1] * V.y) + (m[2][2] * V.z))
        );
    }

    CIwSVec3 TransposeRotateVec(CIwSVec3 const &V) const
    {
        return CIwSVec3(
        IW_SFIXED_FROM_FLOAT_CAST((m[0][0] * V.x) + (m[0][1] * V.y) + (m[0][2] * V.z)),
        IW_SFIXED_FROM_FLOAT_CAST((m[1][0] * V.x) + (m[1][1] * V.y) + (m[1][2] * V.z)),
        IW_SFIXED_FROM_FLOAT_CAST((m[2][0] * V.x) + (m[2][1] * V.y) + (m[2][2] * V.z))
        );
    }
# 366 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h"
    CIwFVec3 TransposeTransformVec(CIwFVec3 const &V) const
    {
        return CIwFVec3(
            ((m[0][0] * (V.x-t.x)) + (m[0][1] * (V.y-t.y)) + (m[0][2] * (V.z-t.z))),
            ((m[1][0] * (V.x-t.x)) + (m[1][1] * (V.y-t.y)) + (m[1][2] * (V.z-t.z))),
            ((m[2][0] * (V.x-t.x)) + (m[2][1] * (V.y-t.y)) + (m[2][2] * (V.z-t.z)))
            );
    }


    float TransformVecX(CIwFVec3 const &V) const { return (((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z))) + t.x; }
    float TransformVecY(CIwFVec3 const &V) const { return (((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z))) + t.y; }
    float TransformVecZ(CIwFVec3 const &V) const { return (((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z))) + t.z; }
    float TransformVecX(float x, float y, float z) const { return (((m[0][0] * x) + (m[1][0] * y) + (m[2][0] * z))) + t.x; }
    float TransformVecY(float x, float y, float z) const { return (((m[0][1] * x) + (m[1][1] * y) + (m[2][1] * z))) + t.y; }
    float TransformVecZ(float x, float y, float z) const { return (((m[0][2] * x) + (m[1][2] * y) + (m[2][2] * z))) + t.z; }







    inline float RotateVecX(const CIwFVec3& V) const
    {
            return m[0][0] * V.x + m[1][0] * V.y + m[2][0] * V.z;
    }





    inline float RotateVecY(const CIwFVec3& V) const
    {
            return m[0][1] * V.x + m[1][1] * V.y + m[2][1] * V.z;
    }





    inline float RotateVecZ(const CIwFVec3& V) const
    {
            return m[0][2] * V.x + m[1][2] * V.y + m[2][2] * V.z;
    }







    CIwFMat GetTranspose() const
    {
        CIwFMat N;
        N.m[0][0] = m[0][0];
        N.m[1][0] = m[0][1];
        N.m[2][0] = m[0][2];
        N.m[0][1] = m[1][0];
        N.m[1][1] = m[1][1];
        N.m[2][1] = m[1][2];
        N.m[0][2] = m[2][0];
        N.m[1][2] = m[2][1];
        N.m[2][2] = m[2][2];


        N.t = CIwFVec3(0, 0, 0);
        return N;
    }
# 444 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h"
    inline void SetRotX(float r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][1] = m[0][2] = m[1][0] = m[2][0] = 0;
        m[0][0] = 1.0f;
        m[1][1] = m[2][2] = (float)cos(r);
        m[1][2] = -(m[2][1] = (float)sin(r));
    }







    inline void SetRotY(float r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][1] = m[1][2] = m[1][0] = m[2][1] = 0;
        m[1][1] = 1.0f;
        m[0][0] = m[2][2] = (float)cos(r);
        m[2][0] = -(m[0][2] = (float)sin(r));
    }







    inline void SetRotZ(float r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][2] = m[1][2] = m[2][0] = m[2][1] = 0;
        m[2][2] = 1.0f;
        m[0][0] = m[1][1] = (float)cos(r);
        m[0][1] = -(m[1][0] = (float)sin(r));
    }


    inline void PreRotateX(float r)
    {
        CIwFMat rx;
        rx.SetRotX(r, true, true);
        PreRotate(rx);
    }
    inline void PreRotateY(float r)
    {
        CIwFMat ry;
        ry.SetRotY(r, true, true);
        PreRotate(ry);
    }
    inline void PreRotateZ(float r)
    {
        CIwFMat rz;
        rz.SetRotZ(r, true, true);
        PreRotate(rz);
    }
    inline void PostRotateX(float r)
    {
        CIwFMat rx;
        rx.SetRotX(r, true, true);
        PostRotate(rx);
    }
    inline void PostRotateY(float r)
    {
        CIwFMat ry;
        ry.SetRotY(r, true, true);
        PostRotate(ry);
    }
    inline void PostRotateZ(float r)
    {
        CIwFMat rz;
        rz.SetRotZ(r, true, true);
        PostRotate(rz);
    }







    void SetAxisAngle(CIwFVec3 axis, float angle);






    void LookAt(const CIwFVec3& from, const CIwFVec3& to, const CIwFVec3& up)
    {

        CIwFVec3 vx, vy, vz;

        vz = (to - from).GetNormalised();
        vx = (up ^ vz);
        if (vx.IsZero())
            vx.x = 1.0f;
        else
            vx.Normalise();
        vy = (vz ^ vx);
        m[0][0] = vx.x; m[0][1] = vx.y; m[0][2] = vx.z;
        m[1][0] = vy.x; m[1][1] = vy.y; m[1][2] = vy.z;
        m[2][0] = vz.x; m[2][1] = vz.y; m[2][2] = vz.z;
    }







    CIwFMat operator * (CIwFMat const & M) const
    {
        CIwFMat N;
        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);
        N.m[0][2] = FindComponentFromBA(M,*this,0,2);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);
        N.m[1][2] = FindComponentFromBA(M,*this,1,2);

        N.m[2][0] = FindComponentFromBA(M,*this,2,0);
        N.m[2][1] = FindComponentFromBA(M,*this,2,1);
        N.m[2][2] = FindComponentFromBA(M,*this,2,2);

        N.t = M.TransformVec(t);

        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(N.TransformVec(CIwFVec3::g_Zero) == M.TransformVec(TransformVec(CIwFVec3::g_Zero)))) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwFMat overflow: operator *"); switch (IwDebugAssertShow("N.TransformVec(CIwFVec3::g_Zero) == M.TransformVec(TransformVec(CIwFVec3::g_Zero))",
 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h"
# 574 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h"
        ,
 575
# 574 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h"
        , (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0)
                                                                                             ;

        return N;
    }







    CIwFMat & PreMult(CIwFMat const & M)
    {
        return (*this = M * (*this));
    }




    CIwFMat & PreMultiply(CIwFMat const & M)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwFMat::PreMult(M)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h", 596, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        return PreMult(M);
    }







    CIwFMat & PostMult(CIwFMat const & M)
    {
        return (*this = (*this) * M);
    }




    CIwFMat & PostMultiply(CIwFMat const & M)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwFMat::PostMult(M)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h", 616, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        return PostMult(M);
    }







    CIwFMat& operator *= (CIwFMat const & M)
    {
        return PostMult(M);
    }







    CIwFMat& PostRotate(CIwFMat const& M)
    {
        CIwFMat N;

        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);
        N.m[0][2] = FindComponentFromBA(M,*this,0,2);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);
        N.m[1][2] = FindComponentFromBA(M,*this,1,2);

        N.m[2][0] = FindComponentFromBA(M,*this,2,0);
        N.m[2][1] = FindComponentFromBA(M,*this,2,1);
        N.m[2][2] = FindComponentFromBA(M,*this,2,2);

        CopyRot(N);

        return *this;
    }






    CIwFMat PreRotate(CIwFMat const& M)
    {
        CIwFMat t = M;
        t.t = this->t;
        return (*this = t.PostRotate(*this));
    }







    CIwFMat& ScaleRot(float v)
    {
        for (int i=0; i<3; i++)
            for (int j=0; j<3; j++)
                m[i][j] = (m[i][j]*v);
        return *this;
    }






    CIwFMat& ScaleTrans(float v)
    {
        t *= v;
        return *this;
    }





    CIwFMat& Scale(float v)
    {
        ScaleRot(v);
        ScaleTrans(v);
        return *this;
    }






    CIwFMat& operator *= (const float v)
    {
        Scale(v);
        return *this;
    }
# 727 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h"
    void InterpRot(CIwFMat const & m0, CIwFMat const & m1, float fraction);


    void InterpolateRot(CIwFMat const & m0, CIwFMat const & m1, float fraction)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwFMat::InterpRot(m0, m1, fraction)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h", 732, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        InterpRot(m0, m1, fraction);
    }
# 746 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h"
    void InterpTrans(CIwFMat const & m0, CIwFMat const & m1, float fraction);


    void InterpolatePos(CIwFMat const & m0, CIwFMat const & m1, float fraction)
    {

        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwFMat::InterpTrans(m0, m1, fraction)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h", 752, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        InterpTrans(m0, m1, fraction);
    }






    void CopyRot(const CIwFMat& m0)
    {
        m[0][0] = m0.m[0][0];
        m[0][1] = m0.m[0][1];
        m[0][2] = m0.m[0][2];
        m[1][0] = m0.m[1][0];
        m[1][1] = m0.m[1][1];
        m[1][2] = m0.m[1][2];
        m[2][0] = m0.m[2][0];
        m[2][1] = m0.m[2][1];
        m[2][2] = m0.m[2][2];
    }





    void CopyTrans(const CIwFMat& m0)
    {
        t = m0.t;
    }







    bool IsRotSame(CIwFMat const& m0) const
    {
        return m[0][0] == m0.m[0][0] &&
        m[0][1] == m0.m[0][1] &&
        m[0][2] == m0.m[0][2] &&
        m[1][0] == m0.m[1][0] &&
        m[1][1] == m0.m[1][1] &&
        m[1][2] == m0.m[1][2] &&
        m[2][0] == m0.m[2][0] &&
        m[2][1] == m0.m[2][1] &&
        m[2][2] == m0.m[2][2];
    }






    bool IsTransSame(CIwFMat const& m0) const
    {
        return (t == m0.t);
    }






    bool operator == (CIwFMat const & m0) const
    {
        return IsRotSame(m0) && IsTransSame(m0);
    }







    bool operator != (CIwFMat const & m0) const
    {
        return !IsRotSame(m0) || !IsTransSame(m0);
    }



    bool IsRotIdentity() const
    {
        return IsRotSame(g_Identity);
    }


    bool IsTransIdentity() const
    {
        return IsTransSame(g_Identity);
    }


    bool IsIdentity() const
    {
        return (*this)==g_Identity;
    }


    void SetIdentity()
    {
        *this = g_Identity;
    }


    bool IsRotZero() const
    {
        return m[0][0] == 0 &&
        m[0][1] == 0 &&
        m[0][2] == 0 &&
        m[1][0] == 0 &&
        m[1][1] == 0 &&
        m[1][2] == 0 &&
        m[2][0] == 0 &&
        m[2][1] == 0 &&
        m[2][2] == 0;
    }


    bool IsTransZero() const
    {
        return t.x == 0 &&
        t.y == 0 &&
        t.z == 0;
    }


    bool IsZero() const
    {
        return IsRotZero() && IsTransZero();
    }


    void SetZero();


    void Zero()
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwFMat::SetZero()."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h", 892, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        SetZero();
    }
# 975 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h"
private:


    static inline float FindComponentFromBA(const CIwFMat& A, const CIwFMat& B, const int i, const int j)
    {
        return B.m[i][0]*A.m[0][j] + B.m[i][1]*A.m[1][j] + B.m[i][2]*A.m[2][j];

    }



};
# 998 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat.h"
inline CIwMat CIwFMat::ConvertToCIwMat()
    {
        return CIwMat(*this);
    }
# 1158 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat.h" 2


inline CIwFMat CIwMat::ConvertToCIwFMat()
    {
        return CIwFMat(*this);
    }
# 24 "c:/marmalade/7.3/modules/iwgeom/h/IwGeom.h" 2
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h" 1
       
# 35 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h"
class CIwFMat2D;
# 63 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h"
class CIwMat2D
{
public:



    iwfixed m[2][2];



    CIwVec2 t;




    static CIwMat2D g_Identity;




    CIwMat2D() {};





    explicit CIwMat2D(iwfixed f)
    {
        m[0][0] = m[1][1] = f;
        m[0][1] = m[1][0] = 0;
        t.x = t.y = 0;
    }






    explicit CIwMat2D(const CIwFMat2D & M);





    inline CIwFMat2D ConvertToCIwFMat2D();
# 116 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h"
    CIwMat2D(CIwMat2D const & R, CIwVec2 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        t = T;
    }







    CIwMat2D(CIwMat2D const & R, CIwSVec2 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        t = T;
    }






    void Serialise();





    void Normalise()
    {
        CIwVec2* pVecX = (CIwVec2*)&m[0][0];
        CIwVec2* pVecY = (CIwVec2*)&m[1][0];

        pVecX->Normalise();

        *pVecY = CIwVec2(-pVecX->y, pVecX->x);
    }




    void Transpose();





    CIwVec2 const & GetTrans() const
    {
        return t;
    }






    CIwMat2D & SetTrans(CIwVec2 const & v)
    {
        t = v;
        return *this;
    }






    CIwMat2D & SetTrans(CIwSVec2 const & v)
    {
        t = v;
        return *this;
    }






    CIwMat2D & operator += (CIwVec2 const & V)
    {
        t += V;
        return *this;
    }






    CIwMat2D & operator += (CIwSVec2 const & V)
    {
        t += V;
        return *this;
    }






    CIwMat2D operator + (CIwVec2 const & V) const
    {
        return CIwMat2D(*this, t+V);
    }






    CIwMat2D operator + (CIwSVec2 const & V) const
    {
        return CIwMat2D(*this, t+V);
    }







    CIwMat2D& operator <<= (int32 s)
    {
        m[0][0] <<= s; m[0][1] <<= s;
        m[1][0] <<= s; m[1][1] <<= s;
        t.x <<= s, t.y <<= s;
        return *this;
    }






    CIwMat2D& operator >>= (int32 s)
    {
        m[0][0] >>= s; m[0][1] >>= s;
        m[1][0] >>= s; m[1][1] >>= s;
        t.x >>= s, t.y >>= s;
        return *this;
    }





    CIwVec2 ColumnX() const
    {
        return CIwVec2(m[0][0], m[1][0]);
    }




    CIwVec2 ColumnY() const
    {
        return CIwVec2(m[0][1], m[1][1]);
    }







    CIwVec2 RowX() const
    {
        return CIwVec2(m[0][0], m[0][1]);
    }







    CIwVec2 RowY() const
    {
        return CIwVec2(m[1][0], m[1][1]);
    }







    CIwVec2 RotateVec(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2(m[0][0], m[1][0], V.x, V.y),
        IW_FIXED_MUL2(m[0][1], m[1][1], V.x, V.y)
        );
    }







    CIwSVec2 RotateVec(CIwSVec2 const &V) const
    {
        return CIwSVec2(
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL2(m[0][0], m[1][0], V.x, V.y)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL2(m[0][1], m[1][1], V.x, V.y))
        );
    }







    CIwVec2 RotateVecSafe(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2_SAFE(m[0][0], m[1][0], V.x, V.y),
        IW_FIXED_MUL2_SAFE(m[0][1], m[1][1], V.x, V.y)
        );
    }







    CIwVec2 TransformVec(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2(m[0][0], m[1][0], V.x, V.y) + t.x,
        IW_FIXED_MUL2(m[0][1], m[1][1], V.x, V.y) + t.y
        );
    }
# 368 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h"
    CIwVec2 TransformVec(CIwSVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2(m[0][0], m[1][0], V.x, V.y) + t.x,
        IW_FIXED_MUL2(m[0][1], m[1][1], V.x, V.y) + t.y
        );
    }
# 384 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h"
    CIwVec2 TransformVecShift(CIwSVec2 const &V, int32 shift) const
    {
        int32 lDotShift = 12 - shift;
        return CIwVec2(
        IW_MUL_2_SHIFT(m[0][0] >> shift, m[1][0] >> shift, V.x, V.y, lDotShift) + t.x,
        IW_MUL_2_SHIFT(m[0][1] >> shift, m[1][1] >> shift, V.x, V.y, lDotShift) + t.y
        );
    }
# 401 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h"
    CIwVec2 TransformVecSafe(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2_SAFE(m[0][0], m[1][0], V.x, V.y) + t.x,
        IW_FIXED_MUL2_SAFE(m[0][1], m[1][1], V.x, V.y) + t.y
        );
    }






    CIwVec2 TransformVecSafe(CIwSVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2_SAFE(m[0][0], m[1][0], V.x, V.y) + t.x,
        IW_FIXED_MUL2_SAFE(m[0][1], m[1][1], V.x, V.y) + t.y
        );
    }







    CIwVec2 TransposeRotateVec(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2(m[0][0], m[0][1], V.x, V.y),
        IW_FIXED_MUL2(m[1][0], m[1][1], V.x, V.y)
        );
    }







    CIwSVec2 TransposeRotateVec(CIwSVec2 const &V) const
    {
        return CIwSVec2(
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL2(m[0][0], m[0][1], V.x, V.y)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL2(m[1][0], m[1][1], V.x, V.y))
        );
    }







    CIwVec2 TransposeRotateVecSafe(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2_SAFE(m[0][0], m[0][1], V.x, V.y),
        IW_FIXED_MUL2_SAFE(m[1][0], m[1][1], V.x, V.y)
        );
    }
# 471 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h"
    CIwVec2 TransposeTransformVec(CIwVec2 const &V) const
    {
        return CIwVec2(
            IW_FIXED_MUL2(m[0][0], m[0][1], V.x-t.x, V.y-t.y),
            IW_FIXED_MUL2(m[1][0], m[1][1], V.x-t.x, V.y-t.y)
            );
    }
# 487 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h"
    iwfixed TransformVecX(CIwVec2 const &V) const { int64 test = (((int64)(IW_FIXED_MUL2(m[0][0],m[1][0],V.x,V.y))) + ((int64)(t.x))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h", 487, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }
    iwfixed TransformVecY(CIwVec2 const &V) const { int64 test = (((int64)(IW_FIXED_MUL2(m[0][1],m[1][1],V.x,V.y))) + ((int64)(t.y))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h", 488, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }
    iwfixed TransformVecX(iwsfixed x, iwsfixed y) const { int64 test = (((int64)(IW_FIXED_MUL2(m[0][0],m[1][0],x,y))) + ((int64)(t.x))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h", 489, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }
    iwfixed TransformVecY(iwsfixed x, iwsfixed y) const { int64 test = (((int64)(IW_FIXED_MUL2(m[0][1],m[1][1],x,y))) + ((int64)(t.y))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h", 490, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }
    iwfixed TransformVecX(iwfixed x, iwfixed y) const { int64 test = (((int64)(IW_FIXED_MUL2(m[0][0],m[1][0],x,y))) + ((int64)(t.x))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h", 491, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }
    iwfixed TransformVecY(iwfixed x, iwfixed y) const { int64 test = (((int64)(IW_FIXED_MUL2(m[0][1],m[1][1],x,y))) + ((int64)(t.y))); do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Add overflow."); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h", 492, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0); return (iwfixed)test;; }







    inline iwfixed RotateVecX(const CIwVec2& V)
    {
            return IW_FIXED_MUL(m[0][0], V.x) + IW_FIXED_MUL(m[1][0], V.y);
    }





    inline iwfixed RotateVecY(const CIwVec2& V)
    {
            return IW_FIXED_MUL(m[0][1], V.x) + IW_FIXED_MUL(m[1][1], V.y);
    }






    inline iwsfixed RotateVecX(const CIwSVec2& V)
    {
            return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(m[0][0], V.x) + IW_FIXED_MUL(m[1][0], V.y));
    }





    inline iwsfixed RotateVecY(const CIwSVec2& V)
    {
            return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(m[0][1], V.x) + IW_FIXED_MUL(m[1][1], V.y));
    }





    CIwMat2D GetTranspose() const
    {
        CIwMat2D N;
        N.m[0][0] = m[0][0];
        N.m[1][0] = m[0][1];
        N.m[0][1] = m[1][0];
        N.m[1][1] = m[1][1];


        N.t = CIwVec2(0, 0);
        return N;
    }







    inline void SetRot(iwangle r = 0, bool resetTrans = true)
    {
        if (resetTrans) t.x = t.y = 0;
        m[0][0] = m[1][1] = IwGeomCos(-r);
        m[0][1] = -(m[1][0] = IwGeomSin(-r));
    }






    inline void SetRot(iwangle r, const CIwVec2& centre)
    {
        m[0][0] = m[1][1] = IwGeomCos(-r);
        m[0][1] = -(m[1][0] = IwGeomSin(-r));
        t = centre - RotateVec(centre);
    }


    inline void PreRotate(iwangle r)
    {
        CIwMat2D rz;
        rz.SetRot(r, true);
        PreRotate(rz);
    }
    inline void PostRotate(iwangle r)
    {
        CIwMat2D rz;
        rz.SetRot(r, true);
        PostRotate(rz);
    }







    CIwMat2D operator * (CIwMat2D const & M) const
    {
        CIwMat2D N;
        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);

        N.t = M.TransformVec(t);

        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(N.TransformVec(CIwVec2::g_Zero) == M.TransformVec(TransformVec(CIwVec2::g_Zero)))) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwMat2D overflow: operator *"); switch (IwDebugAssertShow("N.TransformVec(CIwVec2::g_Zero) == M.TransformVec(TransformVec(CIwVec2::g_Zero))",
 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h"
# 606 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h"
        ,
 607
# 606 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h"
        , (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0)
                                                                                             ;

        return N;
    }







    CIwMat2D & PreMult(CIwMat2D const & M)
    {
        return (*this = M * (*this));
    }




    CIwMat2D & PreMultiply(CIwMat2D const & M)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwMat2D::PreMult(M)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h", 628, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        return PreMult(M);
    }







    CIwMat2D & PostMult(CIwMat2D const & M)
    {
        return (*this = (*this) * M);
    }




    CIwMat2D & PostMultiply(CIwMat2D const & M)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwMat2D::PostMult(M)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h", 648, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        return PostMult(M);
    }







    CIwMat2D& operator *= (CIwMat2D const & M)
    {
        return PostMult(M);
    }







    CIwMat2D& PostRotate(CIwMat2D const& M)
    {
        CIwMat2D N;

        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);

        CopyRot(N);

        return *this;
    }






    CIwMat2D PreRotate(CIwMat2D const& M)
    {
        CIwMat2D t = M;
        t.t = this->t;
        return (*this = t.PostRotate(*this));
    }







    CIwMat2D& ScaleRot(iwfixed v)
    {
        for (int i=0; i<2; i++)
            for (int j=0; j<2; j++)
                m[i][j] = IW_FIXED_MUL(m[i][j],v);
        return *this;
    }






    CIwMat2D& ScaleTrans(iwfixed v)
    {
        t *= v;
        return *this;
    }





    CIwMat2D& Scale(iwfixed v)
    {
        ScaleRot(v);
        ScaleTrans(v);
        return *this;
    }






    CIwMat2D& operator *= (const iwfixed v)
    {
        Scale(v);
        return *this;
    }
# 753 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h"
    void InterpRot(CIwMat2D const & m0, CIwMat2D const & m1, iwfixed fraction);


    void InterpolateRot(CIwMat2D const & m0, CIwMat2D const & m1, iwfixed fraction)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwMat2D::InterpRot(m0, m1, fraction)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h", 758, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        InterpRot(m0, m1, fraction);
    }
# 772 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h"
    void InterpTrans(CIwMat2D const & m0, CIwMat2D const & m1, iwfixed fraction);


    void InterpolatePos(CIwMat2D const & m0, CIwMat2D const & m1, iwfixed fraction)
    {

        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwMat2D::InterpTrans(m0, m1, fraction)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h", 778, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        InterpTrans(m0, m1, fraction);
    }






    void CopyRot(const CIwMat2D& m0)
    {
        m[0][0] = m0.m[0][0];
        m[0][1] = m0.m[0][1];
        m[1][0] = m0.m[1][0];
        m[1][1] = m0.m[1][1];
    }





    void CopyTrans(const CIwMat2D& m0)
    {
        t = m0.t;
    }







    bool IsRotSame(CIwMat2D const& m0) const
    {
        return m[0][0] == m0.m[0][0] &&
        m[0][1] == m0.m[0][1] &&
        m[1][0] == m0.m[1][0] &&
        m[1][1] == m0.m[1][1];
    }






    bool IsTransSame(CIwMat2D const& m0) const
    {
        return (t == m0.t);
    }






    bool operator == (CIwMat2D const & m0) const
    {
        return IsRotSame(m0) && IsTransSame(m0);
    }







    bool operator != (CIwMat2D const & m0) const
    {
        return !IsRotSame(m0) || !IsTransSame(m0);
    }



    bool IsRotIdentity()
    {
        return IsRotSame(g_Identity);
    }


    bool IsTransIdentity()
    {
        return IsTransSame(g_Identity);
    }


    bool IsIdentity()
    {
        return (*this)==g_Identity;
    }


    void SetIdentity()
    {
        *this = g_Identity;
    }


    bool IsRotZero()
    {
        return m[0][0] == 0 &&
        m[0][1] == 0 &&
        m[1][0] == 0 &&
        m[1][1] == 0;
    }


    bool IsTransZero()
    {
        return t.x == 0 &&
        t.y == 0;
    }


    bool IsZero()
    {
        return IsRotZero() && IsTransZero();
    }


    void SetZero();


    void Zero()
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwMat2D::SetZero()."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h", 902, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        SetZero();
    }

    iwfixed GetDeterminant() const
    {
        return IW_FIXED_MUL(m[0][0], m[1][1]) - IW_FIXED_MUL(m[0][1], m[1][0]);
    }




    CIwMat2D GetInverse() const;
# 930 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h"
private:


    static inline iwfixed FindComponentFromBA(const CIwMat2D& A, const CIwMat2D& B, const int i, const int j)
    {


        int64 testA = (int64)(B.m[i][0]) * A.m[0][j];
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(testA >> 63 == testA >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Matrix multiplication overflow"); switch (IwDebugAssertShow("testA >> 63 == testA >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h", 938, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        int64 testB = (int64)(B.m[i][1]) * A.m[1][j];
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(testB >> 63 == testB >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Matrix multiplication overflow"); switch (IwDebugAssertShow("testB >> 63 == testB >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h", 941, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        int64 test = testA + testB;
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test >> 63 == test >> 31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Matrix multiplication overflow"); switch (IwDebugAssertShow("test >> 63 == test >> 31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h", 944, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


        return (B.m[i][0]*A.m[0][j] + B.m[i][1]*A.m[1][j]) >> 12;
    }



};
# 961 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h"
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h" 1
       
# 35 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h"
class CIwMat2D;
# 63 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h"
class CIwFMat2D
{
public:



    float m[2][2];



    CIwFVec2 t;




    static CIwFMat2D g_Identity;




    CIwFMat2D() {};





    explicit CIwFMat2D(float f)
    {
        m[0][0] = m[1][1] = f;
        m[0][1] = m[1][0] = 0;
        t.x = t.y = 0;
    }






    explicit CIwFMat2D(const CIwMat2D & M);





    inline CIwMat2D ConvertToCIwMat2D();
# 116 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h"
    CIwFMat2D(CIwFMat2D const & R, CIwFVec2 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        t = T;
    }







    void Serialise();





    void Normalise()
    {
        CIwFVec2* pVecX = (CIwFVec2*)&m[0][0];
        CIwFVec2* pVecY = (CIwFVec2*)&m[1][0];

        pVecX->Normalise();

        *pVecY = CIwFVec2(-pVecX->y, pVecX->x);
    }




    void Transpose();





    CIwFVec2 const & GetTrans() const
    {
        return t;
    }






    CIwFMat2D & SetTrans(CIwFVec2 const & v)
    {
        t = v;
        return *this;
    }







    CIwFMat2D & operator += (CIwFVec2 const & V)
    {
        t += V;
        return *this;
    }







    CIwFMat2D operator + (CIwFVec2 const & V) const
    {
        return CIwFMat2D(*this, t+V);
    }
# 203 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h"
    CIwFVec2 ColumnX() const
    {
        return CIwFVec2(m[0][0], m[1][0]);
    }




    CIwFVec2 ColumnY() const
    {
        return CIwFVec2(m[0][1], m[1][1]);
    }







    CIwFVec2 RowX() const
    {
        return CIwFVec2(m[0][0], m[0][1]);
    }







    CIwFVec2 RowY() const
    {
        return CIwFVec2(m[1][0], m[1][1]);
    }






    CIwFVec2 RotateVec(CIwFVec2 const &V) const
    {
        return CIwFVec2(
        ((m[0][0] * V.x) + (m[1][0] * V.y)),
        ((m[0][1] * V.x) + (m[1][1] * V.y))
        );
    }
# 258 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h"
    CIwFVec2 TransformVec(CIwFVec2 const &V) const
    {
        return CIwFVec2(
        ((m[0][0] * V.x) + (m[1][0] * V.y)) + t.x,
        ((m[0][1] * V.x) + (m[1][1] * V.y)) + t.y
        );
    }
# 273 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h"
    CIwFVec2 TransposeRotateVec(CIwFVec2 const &V) const
    {
        return CIwFVec2(
        ((m[0][0] * V.x) + (m[0][1] * V.y)),
        ((m[1][0] * V.x) + (m[1][1] * V.y))
        );
    }
# 289 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h"
    CIwFVec2 TransposeTransformVec(CIwFVec2 const &V) const
    {
        return CIwFVec2(
            ((m[0][0] * (V.x-t.x)) + (m[0][1] * (V.y-t.y))),
            ((m[1][0] * (V.x-t.x)) + (m[1][1] * (V.y-t.y)))
            );
    }


    float TransformVecX(CIwFVec2 const &V) const { return (((m[0][0] * V.x) + (m[1][0] * V.y))) + t.x; }
    float TransformVecY(CIwFVec2 const &V) const { return (((m[0][1] * V.x) + (m[1][1] * V.y))) + t.y; }
    float TransformVecX(float x, float y) const { return (((m[0][0] * x) + (m[1][0] * y))) + t.x; }
    float TransformVecY(float x, float y) const { return (((m[0][1] * x) + (m[1][1] * y))) + t.y; }







    inline float RotateVecX(const CIwFVec2& V)
    {
            return m[0][0] * V.x + m[1][0] * V.y;
    }





    inline float RotateVecY(const CIwFVec2& V)
    {
            return m[0][1] * V.x + m[1][1] * V.y;
    }






    CIwFMat2D GetTranspose() const
    {
        CIwFMat2D N;
        N.m[0][0] = m[0][0];
        N.m[1][0] = m[0][1];
        N.m[0][1] = m[1][0];
        N.m[1][1] = m[1][1];


        N.t = CIwFVec2(0, 0);
        return N;
    }







    inline void SetRot(float r = 0, bool resetTrans = true)
    {
        if (resetTrans) t.x = t.y = 0;
        m[0][0] = m[1][1] = (float)cos(-r);
        m[0][1] = -(m[1][0] = (float)sin(-r));
    }






    inline void SetRot(float r, const CIwFVec2& centre)
    {
        m[0][0] = m[1][1] = (float)cos(-r);
        m[0][1] = -(m[1][0] = (float)sin(-r));
        t = centre - RotateVec(centre);
    }


    inline void PreRotate(float r)
    {
        CIwFMat2D rz;
        rz.SetRot(r, true);
        PreRotate(rz);
    }
    inline void PostRotate(float r)
    {
        CIwFMat2D rz;
        rz.SetRot(r, true);
        PostRotate(rz);
    }







    CIwFMat2D operator * (CIwFMat2D const & M) const
    {
        CIwFMat2D N;
        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);

        N.t = M.TransformVec(t);

        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(N.TransformVec(CIwFVec2::g_Zero) == M.TransformVec(TransformVec(CIwFVec2::g_Zero)))) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwFMat2D overflow: operator *"); switch (IwDebugAssertShow("N.TransformVec(CIwFVec2::g_Zero) == M.TransformVec(TransformVec(CIwFVec2::g_Zero))",
 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h"
# 397 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h"
        ,
 398
# 397 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h"
        , (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0)
                                                                                               ;

        return N;
    }







    CIwFMat2D & PreMult(CIwFMat2D const & M)
    {
        return (*this = M * (*this));
    }




    CIwFMat2D & PreMultiply(CIwFMat2D const & M)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwFMat2D::PreMult(M)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h", 419, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        return PreMult(M);
    }







    CIwFMat2D & PostMult(CIwFMat2D const & M)
    {
        return (*this = (*this) * M);
    }




    CIwFMat2D & PostMultiply(CIwFMat2D const & M)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwFMat2D::PostMult(M)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h", 439, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        return PostMult(M);
    }







    CIwFMat2D& operator *= (CIwFMat2D const & M)
    {
        return PostMult(M);
    }







    CIwFMat2D& PostRotate(CIwFMat2D const& M)
    {
        CIwFMat2D N;

        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);

        CopyRot(N);

        return *this;
    }






    CIwFMat2D PreRotate(CIwFMat2D const& M)
    {
        CIwFMat2D t = M;
        t.t = this->t;
        return (*this = t.PostRotate(*this));
    }







    CIwFMat2D& ScaleRot(float v)
    {
        for (int i=0; i<2; i++)
            for (int j=0; j<2; j++)
                m[i][j] = (m[i][j]*v);
        return *this;
    }






    CIwFMat2D& ScaleTrans(float v)
    {
        t *= v;
        return *this;
    }





    CIwFMat2D& Scale(float v)
    {
        ScaleRot(v);
        ScaleTrans(v);
        return *this;
    }






    CIwFMat2D& operator *= (const float v)
    {
        Scale(v);
        return *this;
    }
# 544 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h"
    void InterpRot(CIwFMat2D const & m0, CIwFMat2D const & m1, float fraction);


    void InterpolateRot(CIwFMat2D const & m0, CIwFMat2D const & m1, float fraction)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwFMat2D::InterpRot(m0, m1, fraction)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h", 549, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        InterpRot(m0, m1, fraction);
    }
# 563 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h"
    void InterpTrans(CIwFMat2D const & m0, CIwFMat2D const & m1, float fraction);


    void InterpolatePos(CIwFMat2D const & m0, CIwFMat2D const & m1, float fraction)
    {

        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwFMat2D::InterpTrans(m0, m1, fraction)."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h", 569, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        InterpTrans(m0, m1, fraction);
    }






    void CopyRot(const CIwFMat2D& m0)
    {
        m[0][0] = m0.m[0][0];
        m[0][1] = m0.m[0][1];
        m[1][0] = m0.m[1][0];
        m[1][1] = m0.m[1][1];
    }





    void CopyTrans(const CIwFMat2D& m0)
    {
        t = m0.t;
    }







    bool IsRotSame(CIwFMat2D const& m0) const
    {
        return m[0][0] == m0.m[0][0] &&
        m[0][1] == m0.m[0][1] &&
        m[1][0] == m0.m[1][0] &&
        m[1][1] == m0.m[1][1];
    }






    bool IsTransSame(CIwFMat2D const& m0) const
    {
        return (t == m0.t);
    }






    bool operator == (CIwFMat2D const & m0) const
    {
        return IsRotSame(m0) && IsTransSame(m0);
    }







    bool operator != (CIwFMat2D const & m0) const
    {
        return !IsRotSame(m0) || !IsTransSame(m0);
    }



    bool IsRotIdentity()
    {
        return IsRotSame(g_Identity);
    }


    bool IsTransIdentity()
    {
        return IsTransSame(g_Identity);
    }


    bool IsIdentity()
    {
        return (*this)==g_Identity;
    }


    void SetIdentity()
    {
        *this = g_Identity;
    }


    bool IsRotZero()
    {
        return m[0][0] == 0 &&
        m[0][1] == 0 &&
        m[1][0] == 0 &&
        m[1][1] == 0;
    }


    bool IsTransZero()
    {
        return t.x == 0 &&
        t.y == 0;
    }


    bool IsZero()
    {
        return IsRotZero() && IsTransZero();
    }


    void SetZero();


    void Zero()
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("This method is deprecated in favour of CIwFMat2D::SetZero()."); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h", 693, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        SetZero();
    }

    float GetDeterminant() const
    {
        return m[0][0] * m[1][1] - m[0][1] * m[1][0];
    }




    CIwFMat2D GetInverse() const;
# 779 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h"
private:


    static inline float FindComponentFromBA(const CIwFMat2D& A, const CIwFMat2D& B, const int i, const int j)
    {
        return B.m[i][0]*A.m[0][j] + B.m[i][1]*A.m[1][j];

    }



};
# 802 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFMat2D.h"
inline CIwMat2D CIwFMat2D::ConvertToCIwMat2D()
    {
        return CIwMat2D(*this);
    }
# 962 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomMat2D.h" 2


inline CIwFMat2D CIwMat2D::ConvertToCIwFMat2D()
    {
        return CIwFMat2D(*this);
    }
# 25 "c:/marmalade/7.3/modules/iwgeom/h/IwGeom.h" 2
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomPlane.h" 1
       
# 51 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomPlane.h"
class CIwPlane
{
public:




    CIwSVec3 v;
    int16 padding;





    int32 k;





    static CIwPlane g_YZ;



    static CIwPlane g_XZ;



    static CIwPlane g_XY;




    CIwPlane() {};





    CIwPlane(CIwSVec3 const & _v, int32 vk) : v(_v), k(vk) {};





    CIwPlane(CIwSVec3 const & _v, CIwVec3 const & vk)
    {
        v = _v;
        if (!v.IsZero())
            v.NormaliseSafe();
        k = v * vk;
    }





    CIwPlane(CIwSVec3 const & _v, CIwSVec3 const & vk)
    {
        v = _v;
        if (!v.IsZero())
            v.NormaliseSafe();
        k = v * vk;
    }






    CIwPlane(CIwVec3 const & _a, CIwVec3 const & _b, CIwVec3 const & _c)
    {
        v = ( (_a-_b)^(_c-_a) );
        if (!v.IsZero())
            v.Normalise();
        k = v * _a;
    }






    CIwPlane(CIwSVec3 const & _a, CIwSVec3 const & _b, CIwSVec3 const & _c)
    {
        v = ( (_a-_b)^(_c-_a) );
        if (!v.IsZero())
            v.Normalise();
        k = v * _a;
    }
# 150 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomPlane.h"
    int32 GetPerpDist(CIwVec3 const & a) const
    {
        return v * a - k;
    }





    CIwPlane operator - () const
    {
        return CIwPlane(-v,-k);
    }





    bool operator == (CIwPlane const & p) const
    {
        return k==p.k && v==p.v;
    }
};
# 26 "c:/marmalade/7.3/modules/iwgeom/h/IwGeom.h" 2
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h" 1
       
# 29 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h"
static inline iwqfixed iwqfixed_mul30to13(iwqfixed a, iwqfixed b) {

    int64 check = (int64(a) * b)>>47;
    int32 out = (((a>>16)*(b>>16))>>15);
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(out>=check-2 && out<=check+1)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("iwqfixed_mul30to13 overflow"); switch (IwDebugAssertShow("out>=check-2 && out<=check+1", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h", 33, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


    return (((a>>16)*(b>>16))>>15);
}
# 56 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h"
class CIwQuat
{
public:



    iwqfixed s,
                x, y, z;




    static CIwQuat g_Identity;




    CIwQuat():x(0),y(0),z(0),s((1 << 30)) {}





    CIwQuat(iwqfixed s,iwqfixed x,iwqfixed y,iwqfixed z):x(x),y(y),z(z),s(s) {}







    CIwQuat(CIwMat const &mat);






    CIwQuat(iwqfixed s):x(0),y(0),z(0),s(s) {}






    CIwQuat(CIwVec3 const& v, iwqangle theta){
        CIwVec3 vn = v.GetNormalised();
        SetAxisAngle(vn.x<<(30 - 12), vn.y<<(30 - 12), vn.z<<(30 - 12), theta);
    }





    void Serialise()
    {
        IwSerialiseInt32(s, 4);
    }






    bool operator == (CIwQuat const &q) const {
        return (x == q.x && y == q.y && z == q.z && s == q.s);
    }






    bool operator != (CIwQuat const &q) const {
        return !(*this == q);
    }
# 140 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h"
    void SetAxisAngle(iwqfixed x, iwqfixed y, iwqfixed z, iwqangle theta);





    iwqfixed GetLengthSquared() const;





    iwqfixed GetLength() const;







    CIwQuat operator * (CIwQuat const & q) const {
        return CIwQuat (IW_QFIXED_MUL_SAFE(s, q.s) - (IW_QFIXED_MUL_SAFE(q.x, x) + IW_QFIXED_MUL_SAFE(q.y, y) + IW_QFIXED_MUL_SAFE(q.z, z)),
            IW_QFIXED_MUL_SAFE(s, q.x) + IW_QFIXED_MUL_SAFE(q.s, x) + IW_QFIXED_MUL_SAFE(y, q.z) - IW_QFIXED_MUL_SAFE(z, q.y),
            IW_QFIXED_MUL_SAFE(s, q.y) + IW_QFIXED_MUL_SAFE(q.s, y) + IW_QFIXED_MUL_SAFE(z, q.x) - IW_QFIXED_MUL_SAFE(x, q.z),
            IW_QFIXED_MUL_SAFE(s, q.z) + IW_QFIXED_MUL_SAFE(q.s, z) + IW_QFIXED_MUL_SAFE(x, q.y) - IW_QFIXED_MUL_SAFE(y, q.x)
            );
    }






    CIwQuat operator << (const int c) const {
        return CIwQuat(s<<c, x<<c, y<<c, z<<c);
    }






    CIwQuat operator >> (const int c) const {
        return CIwQuat(s>>c, x>>c, y>>c, z>>c);
    }
# 193 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h"
    CIwVec3 RotateVector (CIwVec3 const &v) const {


        int64 qxvx = (((int64)v.y * z) - ((int64)v.z * y)) >> (12 -1),
                    qxvy = (((int64)v.z * x) - ((int64)v.x * z)) >> (12 -1),
                    qxvz = (((int64)v.x * y) - ((int64)v.y * x)) >> (12 -1);

        int64 qxqxvx = (((int64)qxvy * z) - ((int64)qxvz * y)) >> (30 + (30 - 12)),
                  qxqxvy = (((int64)qxvz * x) - ((int64)qxvx * z)) >> (30 + (30 - 12)),
                  qxqxvz = (((int64)qxvx * y) - ((int64)qxvy * x)) >> (30 + (30 - 12));

        return CIwVec3(
            (int32)(v.x + ((s*qxvx) >> ((30 - 12) + 30)) + qxqxvx),
            (int32)(v.y + ((s*qxvy) >> ((30 - 12) + 30)) + qxqxvy),
            (int32)(v.z + ((s*qxvz) >> ((30 - 12) + 30)) + qxqxvz));

      }





    CIwQuat operator - () const {
        return CIwQuat(s, -x, -y, -z);
    }





    CIwQuat &NormaliseInPlace() {
        iwqfixed l = GetLengthSquared();

        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(l > 0)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwQuat overflow"); switch (IwDebugAssertShow("l > 0", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h", 226, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        if (l == 0) return *this;





        if (l < 0x3FE00000 || l > 0x40200000) {
            int64 recip = (((int64)1 << (30 << 1)) >> 2) / IW_GEOM_QSQRT(l);
            do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!((recip>>31) == (recip>>63))) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwQuat overflow"); switch (IwDebugAssertShow("(recip>>31) == (recip>>63)", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h", 235, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
            do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(recip > 0x200000)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwQuat overflow"); switch (IwDebugAssertShow("recip > 0x200000", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h", 236, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

            s = IW_QFIXED_MUL_SAFE(s, (iwqfixed)recip)<<2;
            x = IW_QFIXED_MUL_SAFE(x, (iwqfixed)recip)<<2;
            y = IW_QFIXED_MUL_SAFE(y, (iwqfixed)recip)<<2;
            z = IW_QFIXED_MUL_SAFE(z, (iwqfixed)recip)<<2;

        }

        return *this;
    }





    CIwVec3 GetRotationAxis(){
        CIwVec3 v(x>>(30 - 12),y>>(30 - 12),z>>(30 - 12));
        v.Normalise();
        return v;
    }





    iwqangle GetRotationAngle(){
        return IwGeomQACos (s) * 2;
    }




    CIwQuat operator * (iwqfixed const l) const {
        return CIwQuat (
            IW_QFIXED_MUL_SAFE((l<<(30 - 12)), s),
            IW_QFIXED_MUL_SAFE((l<<(30 - 12)), x),
            IW_QFIXED_MUL_SAFE((l<<(30 - 12)), y),
            IW_QFIXED_MUL_SAFE((l<<(30 - 12)), z));
    }






    CIwQuat operator + (CIwQuat const & q) const {

        int64 test;
        test = (int64)q.x + x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwQuat overflow"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h", 285, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = (int64)q.y + y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwQuat overflow"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h", 286, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = (int64)q.z + z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwQuat overflow"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h", 287, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        return CIwQuat(s + q.s, x + q.x, y + q.y, z + q.z);
    }






    CIwQuat operator - (CIwQuat const & q) const {

        int64 test;
        test = (int64)q.x - x; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwQuat overflow"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h", 300, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = (int64)q.y - y; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwQuat overflow"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h", 301, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        test = (int64)q.z - z; do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(test>>63 == test>>31)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("CIwQuat overflow"); switch (IwDebugAssertShow("test>>63 == test>>31", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h", 302, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        return CIwQuat(s - q.s, x - q.x, y - q.y, z - q.z);
    }






    CIwQuat &operator = (CIwQuat const &q) {
        s = q.s;
        x = q.x;
        y = q.y;
        z = q.z;
        return *this;
    }





    operator CIwMat() const {
        CIwMat m;

        iwqfixed x2 = iwqfixed_mul30to13(x,x),
                    y2 = iwqfixed_mul30to13(y,y),
                    z2 = iwqfixed_mul30to13(z,z),
                    xy = iwqfixed_mul30to13(x,y),
                    yz = iwqfixed_mul30to13(y,z),
                    xz = iwqfixed_mul30to13(x,z),
                    wx = iwqfixed_mul30to13(s,x),
                    wy = iwqfixed_mul30to13(s,y),
                    wz = iwqfixed_mul30to13(s,z);



        m.m[0][0] = (1 << 12) - y2 - z2;
        m.m[1][1] = (1 << 12) - x2 - z2;
        m.m[2][2] = (1 << 12) - x2 - y2;
        m.m[1][0] = xy - wz;
        m.m[2][0] = xz + wy;
        m.m[0][1] = xy + wz;
        m.m[2][1] = yz - wx;
        m.m[0][2] = xz - wy;
        m.m[1][2] = yz + wx;

        m.t.x = m.t.y = m.t.z = 0;
        return m;
    }
# 361 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h"
    void Lerp(const CIwQuat &startQ, const CIwQuat &endQ, iwfixed const t);
# 371 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomQuat.h"
    void Slerp(const CIwQuat &startQ, const CIwQuat &endQ, iwfixed const t);
};
# 27 "c:/marmalade/7.3/modules/iwgeom/h/IwGeom.h" 2
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSphere.h" 1
       
# 53 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSphere.h"
template <class V, class R>
class CIwSphereT
{
public:




    V t;




    R r;

    uint32 r2;




    CIwSphereT() {};





    CIwSphereT(V const & _t, R _r) : t(_t)
    {
        SetRadius(_r);
    };





    void Serialise();
# 97 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSphere.h"
    inline void SetRadius(R _r)
    {
        r = _r;
        r2 = ((r) * (r));
    };






    inline uint32 GetRadius() const
    {
        return r;
    };




    inline V const & GetTrans() const
    {
        return t;
    };
# 128 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSphere.h"
    template <class V2>
    void BoundVecs(V2* pVec, uint32 v)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(v > 0)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(390); IwDebugAssertSetMessage ("Must specify non-0 number of vecs"); switch (IwDebugAssertShow("v > 0", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSphere.h", 131, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);


        t.x = t.y = t.z = 0;
        uint32 v2 = v;
        V2* pVec2 = pVec;
        while(v2--)
            t += *pVec2++;


        t = t / ((iwfixed)((v) * (1 << 12)));
        r = 0;
        while(v--)
        {


            CIwVec3 dv(*pVec);
            dv -= t;
            r = (((r) > ((int32)dv.GetLengthSafe())) ? (r) : ((int32)dv.GetLengthSafe()));
            pVec++;
        }


        r2 = ((r) * (r));
    }







    inline bool ClipToPlane(const CIwPlane& plane)
    {
        int32 dot = t * plane.v;
        int32 dotk = dot - plane.k;
        return dotk >= (int32)r;
    }
# 180 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSphere.h"
    bool ClipToFrustrum(CIwPlane* pPlanes, uint32 clipFlags)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(pPlanes)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(391); IwDebugAssertSetMessage ("NULL ptr"); switch (IwDebugAssertShow("pPlanes", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSphere.h", 182, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
        while(clipFlags != 0)
        {
            if (
                (clipFlags & 0x1) &&
                (ClipToPlane(*pPlanes) == true)
                )

                return true;

            pPlanes++;
            clipFlags >>= 1;
        }

        return false;
    }
# 208 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSphere.h"
    iwufixed GetDistSqFromLine(const CIwVec3& point, const CIwVec3& dir) const
    {
        CIwVec3 delta = t-point;
        uint32 hyp2 = delta.GetLengthSquaredSafe();
        iwfixed adj = dir*(delta);
        iwufixed adj2 = IW_FIXED_MUL_SAFE(adj,adj);
        iwufixed perpdist2 = hyp2-adj2;
        return perpdist2;
    }
# 226 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomSphere.h"
    bool IntersectsLine(CIwVec3& point, CIwVec3& dir)
    {
        iwufixed r2_proper = IW_FIXED_MUL_SAFE(r,r);
        return GetDistSqFromLine(point,dir) <= r2_proper;
    }







    template <class V2>
    bool ContainsVec(const V2& v) const
    {
        return (v - t).GetLengthSafe() < r;
    }
};





typedef CIwSphereT<CIwVec3, iwfixed> CIwSphere;





typedef CIwSphereT<CIwSVec3, iwsfixed> CIwSSphere;
# 28 "c:/marmalade/7.3/modules/iwgeom/h/IwGeom.h" 2
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomBBox.h" 1
       
# 26 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomBBox.h"
class CIwMat;
# 54 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomBBox.h"
template <class V>
class CIwBBoxT
{
public:




    V m_Min;





    V m_Max;




    CIwBBoxT() {};
# 82 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomBBox.h"
    CIwBBoxT(const V& _min, const V& _max) : m_Min(_min), m_Max(_max) {};





    void Serialise();





    V GetCentre() { return m_Min + (m_Max - m_Min) / ((iwfixed)((2) * (1 << 12))); }





    template <class V2>
    void BoundVec(V2* pVec)
    {
        m_Min.x = (((m_Min.x) < (pVec->x)) ? (m_Min.x) : (pVec->x));
        m_Min.y = (((m_Min.y) < (pVec->y)) ? (m_Min.y) : (pVec->y));
        m_Min.z = (((m_Min.z) < (pVec->z)) ? (m_Min.z) : (pVec->z));
        m_Max.x = (((m_Max.x) > (pVec->x)) ? (m_Max.x) : (pVec->x));
        m_Max.y = (((m_Max.y) > (pVec->y)) ? (m_Max.y) : (pVec->y));
        m_Max.z = (((m_Max.z) > (pVec->z)) ? (m_Max.z) : (pVec->z));
    }
# 119 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomBBox.h"
    template <class V2>
    void BoundVecs(V2* pVec, uint32 v)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(v > 0)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(348); IwDebugAssertSetMessage ("Must specify non-0 number of vecs"); switch (IwDebugAssertShow("v > 0", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomBBox.h", 122, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        m_Min = V(0x7fff, 0x7fff, 0x7fff);
        m_Max = V((-0x7fff - 1), (-0x7fff - 1), (-0x7fff - 1));
        while(v--)
        {
            BoundVec(pVec);
            pVec++;
        }
    }
# 141 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomBBox.h"
    template <class V2>
    bool ContainsVec(const V2& v, CIwMat* pMat = __null) const
    {
        if (pMat)
        {
            CIwVec3 dv = v - pMat->t;
            int32 lx, ly, lz;
            lx = pMat->RotateVecX(dv);
            if ((lx >= m_Min.x) && (lx <= m_Max.x))
            {
                ly = pMat->RotateVecY(dv);
                if ((ly >= m_Min.y) && (ly <= m_Max.y))
                {
                    lz = pMat->RotateVecZ(dv);
                    if ((lz >= m_Min.z) && (lz <= m_Max.z))
                        return true;
                }
            }
        }
        else
        {
            if (
                (v.x >= m_Min.x) && (v.x <= m_Max.x) &&
                (v.y >= m_Min.y) && (v.y <= m_Max.y) &&
                (v.z >= m_Min.z) && (v.z <= m_Max.z)
                )
                return true;
        }
        return false;
    }
};





typedef CIwBBoxT<CIwSVec3> CIwSBBox;





typedef CIwBBoxT<CIwVec3> CIwBBox;
# 29 "c:/marmalade/7.3/modules/iwgeom/h/IwGeom.h" 2
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomIntersect.h" 1
       
# 40 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomIntersect.h"
extern int32 IW_GEOM_INTERSECT_EPSILON;
# 56 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectLinePlane( const CIwVec3& vFrom,
                                const CIwVec3& vFromTo,
                                const CIwPlane& plane,
                                int32& f,
                                bool finite = true);
# 76 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectLineSegPlaneOneSided(const CIwVec3& vOrg,
                                        const CIwVec3& vDirn,
                                        const CIwPlane& plane,
                                        int32& f,
                                        bool finite = true);
# 91 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectLineSphere( const CIwVec3& vOrg,
                                const CIwVec3& vDirn,
                                const CIwSphere& sphere);
# 111 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectLineTriNorm( const CIwVec3& vOrg,
                                const CIwVec3& vDirn,
                                const CIwVec3& v0,
                                const CIwVec3& v1,
                                const CIwVec3& v2,
                                const CIwSVec3& norm,
                                int32& f,
                                bool finite = true);
# 136 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectLineLine2D( const CIwVec2& p1, const CIwVec2& dir1,
                                const CIwVec2& p2, const CIwVec2& dir2,
                                CIwVec2& collpt,
                                iwfixed& t1,
                                iwfixed& t2,
                                bool finite = true);
# 151 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectSphereSphere(const CIwSphere& s0, const CIwSphere& s1);
# 30 "c:/marmalade/7.3/modules/iwgeom/h/IwGeom.h" 2


# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFIntersect.h" 1
       
# 33 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFIntersect.h"
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFPlane.h" 1
       
# 45 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFPlane.h"
class CIwFPlane
{
public:




    CIwFVec3 v;
    int16 padding;





    float k;





    static CIwFPlane g_YZ;



    static CIwFPlane g_XZ;



    static CIwFPlane g_XY;




    CIwFPlane() {};





    CIwFPlane(CIwFVec3 const & _v, float vk) : v(_v), k(vk) {};





    CIwFPlane(CIwFVec3 const & _v, CIwFVec3 const & vk)
    {
        v = _v;
        if (!v.IsZero())
            v.Normalise();
        k = v * vk;
    }






    CIwFPlane(CIwFVec3 const & _a, CIwFVec3 const & _b, CIwFVec3 const & _c)
    {
        v = ( (_a - _b) ^ (_c - _a) );
        if (!v.IsZero())
            v.Normalise();
        k = v * _a;
    }
# 120 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFPlane.h"
    float GetPerpDist(CIwFVec3 const & a) const
    {
        return v * a - k;
    }





    CIwFPlane operator - () const
    {
        return CIwFPlane(-v, -k);
    }





    bool operator == (CIwFPlane const & p) const
    {
        return k == p.k && v == p.v;
    }
};
# 34 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFIntersect.h" 2
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFSphere.h" 1
# 21 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFSphere.h"
# 1 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFBBox.h" 1
       
# 22 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFBBox.h"
class CIwFMat;





class CIwFBBox
{
public:

    CIwFVec3 minV;
    CIwFVec3 maxV;


    CIwFBBox() {};
    CIwFBBox(const CIwFVec3& _min, const CIwFVec3& _max) : minV(_min), maxV(_max) {};


    CIwFVec3 GetCentre() { return minV + (maxV - minV) / 2; }


    inline void BoundVec(CIwFVec3* pVec)
    {
        minV.x = (((minV.x) < (pVec->x)) ? (minV.x) : (pVec->x));
        minV.y = (((minV.y) < (pVec->y)) ? (minV.y) : (pVec->y));
        minV.z = (((minV.z) < (pVec->z)) ? (minV.z) : (pVec->z));
        maxV.x = (((maxV.x) > (pVec->x)) ? (maxV.x) : (pVec->x));
        maxV.y = (((maxV.y) > (pVec->y)) ? (maxV.y) : (pVec->y));
        maxV.z = (((maxV.z) > (pVec->z)) ? (maxV.z) : (pVec->z));
    }


    void BoundVecs(CIwFVec3* pVec, uint32 v)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(v > 0)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(363); IwDebugAssertSetMessage ("Must specify non-0 number of vecs"); switch (IwDebugAssertShow("v > 0", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFBBox.h", 56, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        minV = CIwFVec3(3.402823466e+38F, 3.402823466e+38F, 3.402823466e+38F);
        maxV = CIwFVec3(-3.402823466e+38F, -3.402823466e+38F, -3.402823466e+38F);
        while(v--)
        {

            minV.x = (((minV.x) < (pVec->x)) ? (minV.x) : (pVec->x));
            minV.y = (((minV.y) < (pVec->y)) ? (minV.y) : (pVec->y));
            minV.z = (((minV.z) < (pVec->z)) ? (minV.z) : (pVec->z));
            maxV.x = (((maxV.x) > (pVec->x)) ? (maxV.x) : (pVec->x));
            maxV.y = (((maxV.y) > (pVec->y)) ? (maxV.y) : (pVec->y));
            maxV.z = (((maxV.z) > (pVec->z)) ? (maxV.z) : (pVec->z));
            pVec++;
        }
    }


    bool ContainsVec(CIwFVec3& v, CIwFMat* pMat = __null)
    {
        if (pMat)
        {
            CIwFVec3 dv = v - pMat->t;
            float lx, ly, lz;
            lx = pMat->m[0][0]*dv.x + pMat->m[1][0]*dv.y + pMat->m[2][0]*dv.z;
            if ((lx >= minV.x) && (lx <= maxV.x))
            {
                ly = pMat->m[0][1]*dv.x + pMat->m[1][1]*dv.y + pMat->m[2][1]*dv.z;
                if ((ly >= minV.y) && (ly <= maxV.y))
                {
                    lz = pMat->m[0][2]*dv.x + pMat->m[1][2]*dv.y + pMat->m[2][2]*dv.z;
                    if ((lz >= minV.z) && (lz <= maxV.z))
                        return true;
                }
            }
        }
        else
        {
            if (
                (v.x >= minV.x) && (v.x <= maxV.x) &&
                (v.y >= minV.y) && (v.y <= maxV.y) &&
                (v.z >= minV.z) && (v.z <= maxV.z)
                )
                return true;
        }
        return false;
    }
};
# 22 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFSphere.h" 2







class CIwFSphere
{
public:

    CIwFVec3 t;
    float r;
    float r2;


    CIwFSphere() {};
    CIwFSphere(const CIwFVec3& _t, float _r) : t(_t)
    {
        SetRadius(_r);
    };

    inline void SetRadius(float _r)
    {
        r = _r;
        r2 = r*r;
    };

    inline float GetRadius()
    {
        return r;
    };

    inline CIwFVec3 const & GetTrans() const
    {
        return t;
    };


    void BoundVecs(CIwFVec3* pVec, uint32 v)
    {
        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(v > 0)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(372); IwDebugAssertSetMessage ("Must specify non-0 number of vecs"); switch (IwDebugAssertShow("v > 0", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFSphere.h", 63, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);

        CIwFBBox bbox;
        bbox.BoundVecs(pVec, v);

        t = bbox.GetCentre();
        r = 0;
        while(v--)
        {
            CIwFVec3 dv = *pVec;
            dv -= t;
            r = (((r) > (dv.GetLengthSquared())) ? (r) : (dv.GetLengthSquared()));
            pVec++;
        }


        r2 = r;

        r = (float)sqrt(r);
    }


    void Combine(CIwFSphere& rhs)
    {

        CIwFVec3 centre = rhs.t - t;
        float dist = centre.GetLength();

        if( dist + rhs.r <= r )
            return;

        if( dist + r <= rhs.r )
        {
            *this = rhs;
            return;
        }

        centre = centre / dist;

        t -= centre * r;

        t += rhs.t + centre * rhs.r;
        t = t / 2.0f;

        r = (dist + r + rhs.r) / 2.0f;
        r2 = r * r;

        do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(r >= rhs.r)) && (IwDebugAssertIsChannelOn("GEOM")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage (__null); switch (IwDebugAssertShow("r >= rhs.r", "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFSphere.h", 110, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
    }
# 146 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFSphere.h"
};




inline void IwSerialiseSphere(CIwFSphere& Sphere)
{
    Sphere.t.Serialise ();
    IwSerialiseFloat(Sphere.r);
    IwSerialiseFloat(Sphere.r2);
}
# 35 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFIntersect.h" 2
# 54 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectLinePlane(const CIwFVec3& vFrom,
                          const CIwFVec3& vFromTo,
                          const CIwFPlane& plane,
                          float& f,
                          bool finite = true);
# 74 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectLineSegPlaneOneSided(const CIwFVec3& vOrg,
                                     const CIwFVec3& vDirn,
                                     const CIwFPlane& plane,
                                     float& f,
                                     bool finite = true);
# 89 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectLineSphere(const CIwFVec3& vOrg,
                           const CIwFVec3& vDirn,
                           const CIwFSphere& sphere);
# 109 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectLineTriNorm(const CIwFVec3& vOrg,
                            const CIwFVec3& vDirn,
                            const CIwFVec3& v0,
                            const CIwFVec3& v1,
                            const CIwFVec3& v2,
                            const CIwFVec3& norm,
                            float& f,
                            bool finite = true);
# 134 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectLineLine2D(const CIwFVec2& p1,
                           const CIwFVec2& dir1,
                           const CIwFVec2& p2,
                           const CIwFVec2& dir2,
                           CIwFVec2& collpt,
                           float& t1,
                           float& t2,
                           bool finite = true);
# 151 "c:/marmalade/7.3/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectSphereSphere(const CIwFSphere& s0, const CIwFSphere& s1);
# 33 "c:/marmalade/7.3/modules/iwgeom/h/IwGeom.h" 2
# 29 "c:/marmalade/7.3/modules/iw2dscenegraphcore/h/Iw2DSceneGraphCore.h" 2
# 56 "c:/marmalade/7.3/modules/iw2dscenegraphcore/h/Iw2DSceneGraphCore.h"
 namespace Iw2DSceneGraphCore {
# 70 "c:/marmalade/7.3/modules/iw2dscenegraphcore/h/Iw2DSceneGraphCore.h"
class CNode
{
public:



    CNode();




    virtual ~CNode();







    float m_X;




    float m_Y;







    float m_W;







    float m_H;






    float m_AnchorX;






    float m_AnchorY;




    float m_ScaleX;




    float m_ScaleY;




    float m_Angle;







    float m_Alpha;




    bool m_IsVisible;
protected:
    float m_AlphaGlobal;


    CNode* m_Parent;
    _STL::vector<CNode*> m_Children;


    CIwFMat2D m_MatLocal;
    CIwFMat2D m_MatGlobal;

public:





    void AddChild(CNode* pChild);







    void RemoveChild(CNode* pChild);





    int GetNumChildren() const { return m_Children.size(); }





    bool IsChild(CNode* pChild);





    const CIwFMat2D& GetMatLocal() const { return m_MatLocal; }





    const CIwFMat2D& GetMatGlobal() const { return m_MatGlobal; }





    void CalculateMatrices();
# 217 "c:/marmalade/7.3/modules/iw2dscenegraphcore/h/Iw2DSceneGraphCore.h"
    virtual void Update(float deltaTime = 0.0f, float alphaMul = 1.0f);





    virtual void Render();




 bool HitTest(int x, int y);

};

}
# 24 "c:/marmalade/7.3/modules/iw2dscenegraphcore/source/Iw2DSceneGraphCore.cpp" 2


namespace Iw2DSceneGraphCore {




CNode::CNode()
{

    m_X = m_Y = m_W = m_H = 0.0f;
    m_ScaleX = m_ScaleY = 1.0f;
    m_AnchorX = m_AnchorY = 0.0f;
    m_Angle = 0.0f;


    m_Alpha = m_AlphaGlobal = 1.0f;
    m_IsVisible = true;


    m_Parent = __null;
}

CNode::~CNode()
{


    _STL::vector<CNode*>::iterator itN = m_Children.begin();
    _STL::vector<CNode*>::iterator etN = m_Children.end();
    for (; itN != etN; ++itN)
        delete *itN;
}

void CNode::CalculateMatrices()
{

    CIwFMat2D* pMatParent;
    if (m_Parent)
        pMatParent = &m_Parent->m_MatGlobal;
    else
        pMatParent = &CIwFMat2D::g_Identity;

    m_MatLocal.t.x = m_X;
    m_MatLocal.t.y = m_Y;

    double angr = m_Angle * 2 * 3.141592653589793f / 360;
    m_MatLocal.m[0][0] = (float)cos(angr) * m_ScaleX;
    m_MatLocal.m[0][1] = -(float)sin(angr) * m_ScaleY;
    m_MatLocal.m[1][0] = (float)sin(angr) * m_ScaleX;
    m_MatLocal.m[1][1] = (float)cos(angr) * m_ScaleY;

    CIwFVec2 anchorOfs = m_MatLocal.RotateVec(CIwFVec2(m_W * m_AnchorX, m_H * m_AnchorY));
    m_MatLocal.t -= anchorOfs;


    m_MatGlobal = m_MatLocal * *pMatParent;
}

void CNode::Update(float deltaTime, float alphaMul)
{

    m_AlphaGlobal = m_Alpha * alphaMul;
    alphaMul *= m_Alpha;


    CalculateMatrices();


    _STL::vector<CNode*>::iterator itN = m_Children.begin();
    _STL::vector<CNode*>::iterator etN = m_Children.end();
    for (; itN != etN; ++itN)
        (*itN)->Update(deltaTime, alphaMul);
}

void CNode::Render()
{
 if (!m_IsVisible)
  return;

    _STL::vector<CNode*>::iterator itN = m_Children.begin();
    _STL::vector<CNode*>::iterator etN = m_Children.end();
    for (; itN != etN; ++itN)
        (*itN)->Render();
}

void CNode::AddChild(CNode* pChild)
{
    if (pChild->m_Parent)
        pChild->m_Parent->RemoveChild(pChild);

    m_Children.push_back(pChild);
    pChild->m_Parent = this;
}

void CNode::RemoveChild(CNode* pChild)
{
    _STL::vector<CNode*>::iterator itN = m_Children.begin();
    _STL::vector<CNode*>::iterator etN = m_Children.end();
    for (; itN != etN; ++itN)
    {
        if (*itN == pChild)
        {
            (*itN)->m_Parent = __null;
            m_Children.erase(itN);
            return;
        }
    }
    do { do { static uint8 _s_IwAssertIgnoreThis = 0;; if ((!(false)) && (IwDebugAssertIsChannelOn("SCENEGRAPHCORE")) && (_s_IwAssertIgnoreThis==0)) { IwDebugAssertSetSolution (__null); IwDebugAssertSetUID(0); IwDebugAssertSetMessage ("Specified node is not a child of this node"); switch (IwDebugAssertShow("false", "c:/marmalade/7.3/modules/iw2dscenegraphcore/source/Iw2DSceneGraphCore.cpp", 131, (1))) { case S3E_ERROR_SHOW_STOP: do { if (s3eDebugIsDebuggerPresent()) do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); else IwDebugExit(); } while(0); break; case S3E_ERROR_SHOW_IGNORE: _s_IwAssertIgnoreThis = 1;; break; default:; } IwDebugAssertSetUID(0); } } while (0); } while (0);
}

bool CNode::IsChild(CNode* pChild)
{
    _STL::vector<CNode*>::iterator itN = m_Children.begin();
    _STL::vector<CNode*>::iterator etN = m_Children.end();
    for (; itN != etN; ++itN)
    {
        if (*itN == pChild)
            return true;
    }
    return false;
}


bool CNode::HitTest(int x, int y)
{
 CIwFVec2 v[4];

 v[0].x = 0;
 v[1].x = 0 + m_W;
 v[2].x = 0 + m_W;
 v[3].x = 0;
 v[0].y = 0;
 v[1].y = 0;
 v[2].y = 0 + m_H;
 v[3].y = 0 + m_H;

 CIwFVec2 ov = m_MatGlobal.TransformVec(v[3]);
 for (int t = 0; t < 4; t++)
 {
  CIwFVec2 nv = m_MatGlobal.TransformVec(v[t]);
  float x0 = nv.x - ov.x;
  float y0 = nv.y - ov.y;
  float x1 = x - ov.x;
  float y1 = y - ov.y;

  if ((x1 * y0 - x0 * y1) >= 0)
   return false;

  ov = nv;
 }

 return true;
}

}
